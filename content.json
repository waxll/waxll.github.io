{"meta":{"title":"Waxll'Blog","subtitle":"","description":"","author":"XieSenshi","url":"http://waxll.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-03-24T10:59:39.311Z","updated":"2021-03-24T09:55:49.594Z","comments":true,"path":"404.html","permalink":"http://waxll.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"404 Not Found","date":"2021-03-24T09:55:49.594Z","updated":"2021-03-24T09:55:49.594Z","comments":true,"path":"404/index.html","permalink":"http://waxll.top/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 返回"},{"title":"关于","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"about/index.html","permalink":"http://waxll.top/about/index.html","excerpt":"","text":"关于我 在这里我主要分享一些技巧、教程、单片机程序以及记录学习上的心得。希望用这个博客记录我学习提升的过程，多年以后再回头看看，看看自己成长了多少。 为什么写博客？应为牛人都这么干。希望有一天我也能成为一个牛人，毕竟梦想一定要有，万一实现了呢！ 返回"},{"title":"所有分类","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"categories/index.html","permalink":"http://waxll.top/categories/index.html","excerpt":"","text":""},{"title":"更新日志","date":"2020-07-15T12:48:41.000Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"journal/index.html","permalink":"http://waxll.top/journal/index.html","excerpt":"","text":"更新日志 2020-04-12 开始博客搭建 创建GitHub账号 油管学习 2020-04-15 博客初成发布第一篇文章 使用Lx作为主题 以lovekmjb.ml作为域名 2020-07-12 更换博客主题为Volantis 优化页面显示 新增Valine评论系统 新增百度统计 添加网站运行时间及访问量功能 新增字数统计和阅读时长插件 使用 pjax 新增大量特效 2020-07-15 优化体验 更换国内图床 使用hexo-offline-popup插件可自动检测网站更新并以弹窗显示 2020-07-27 增加功能 新增黑暗模式可跟据时间自动识别，并有记忆功能 2020-07-28 优化体验 搬家至Coding，大幅降低链接延迟，提升网站链接速度与体验 持续更新中……"},{"title":"我的朋友们","date":"2021-03-24T15:29:51.981Z","updated":"2021-03-24T15:29:51.981Z","comments":true,"path":"friends/index.html","permalink":"http://waxll.top/friends/index.html","excerpt":"我的朋友们","text":"我的朋友们"},{"title":"","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"js/dj.js","permalink":"http://waxll.top/js/dj.js","excerpt":"","text":"/* * 鼠标点击特效，canvas点击效果 */ /* Copyright (C) 2013 Justin Windle sketch.min.js, http://soulwire.co.uk */ var Sketch=function(){\"use strict\";function e(e){return\"[object Array]\"==Object.prototype.toString.call(e)}function t(e){return\"function\"==typeof e}function n(e){return\"number\"==typeof e}function o(e){return\"string\"==typeof e}function r(e){return E[e]||String.fromCharCode(e)}function i(e,t,n){for(var o in t)(n||!e.hasOwnProperty(o))&&(e[o]=t[o]);return e}function u(e,t){return function(){e.apply(t,arguments)}}function a(e){var n={};for(var o in e)n[o]=t(e[o])?u(e[o],e):e[o];return n}function c(e){function n(n){t(n)&&n.apply(e,[].splice.call(arguments,1))}function u(e){for(_=0;_= 0; i--) { particles[i].draw(clickparticle); } }; //按下时显示效果，mousedown 换成 click 为点击时显示效果（我用的 click） document.addEventListener(\"mousedown\", function(e) { var max, j; //排除一些元素 \"TEXTAREA\" !== e.target.nodeName && \"INPUT\" !== e.target.nodeName && \"A\" !== e.target.nodeName && \"I\" !== e.target.nodeName && \"IMG\" !== e.target.nodeName && function() { for (max = random(15, 20), j = 0; j < max; j++) clickparticle.spawn(e.clientX, e.clientY); }(); }); }"},{"title":"","date":"2021-03-24T11:00:47.707Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"mylist/index.html","permalink":"http://waxll.top/mylist/index.html","excerpt":"","text":""},{"title":"图库","date":"2020-07-15T12:48:41.000Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"photo2/index.html","permalink":"http://waxll.top/photo2/index.html","excerpt":"","text":"图库 返回 上一页 下一页 2/3"},{"title":"图库","date":"2020-07-15T12:48:41.000Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"photo/index.html","permalink":"http://waxll.top/photo/index.html","excerpt":"","text":"图库 返回 下一页 1/3"},{"title":"图库","date":"2020-07-15T12:48:41.000Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"photo3/index.html","permalink":"http://waxll.top/photo3/index.html","excerpt":"","text":"图库 返回 上一页 3/3"},{"title":"所有标签","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"tags/index.html","permalink":"http://waxll.top/tags/index.html","excerpt":"","text":""},{"title":"鼠标点击效果","date":"2020-07-24T22:00:03.000Z","updated":"2021-03-24T09:55:49.614Z","comments":true,"path":"鼠标点击效果/index.html","permalink":"http://waxll.top/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C/index.html","excerpt":"","text":"返回 移动端可能无法正常显示"},{"title":"热门标签","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"blog/tags/index.html","permalink":"http://waxll.top/blog/tags/index.html","excerpt":"","text":""},{"title":"爱国富强专供","date":"2020-08-10T05:17:30.000Z","updated":"2021-03-24T09:55:49.614Z","comments":true,"path":"vpn/index.html","permalink":"http://waxll.top/vpn/index.html","excerpt":"","text":"Clash ShadowsocksR Shadowsocks Quantumult"},{"title":"文章分类","date":"2021-03-24T09:55:49.604Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"blog/categories/index.html","permalink":"http://waxll.top/blog/categories/index.html","excerpt":"","text":""},{"title":"Clash for Windos及Clash for Android使用教程","date":"2020-08-10T05:17:30.000Z","updated":"2021-03-24T09:55:49.604Z","comments":true,"path":"vpn/Clash for Windows/index.html","permalink":"http://waxll.top/vpn/Clash%20for%20Windows/index.html","excerpt":"","text":"Clash for Windos已经安装的直接进入第二步 1.安装应用下载安装包 2.订阅链接 打开应用后在状态栏单击图标打开面板 显示如下界面System Proxy默认为关闭 点击左侧的Profiles 打开如下界面 将订阅链接填入文本框中点击Download下载订阅3.启用代理 点击左侧的Proxies 打开如下界面 上方是四个模式的切换，分别为： Global：全局模式，即代理所有流量。在打开一些冷门的外国网站时选择，平时打开会导致国内的一些网站应用打开变慢，甚至无法打开。Rule：规则模式，会按照后台规则进行代理，会绕过国内流量。通常使用该模式。Direct：直连，不代理任何流量，即关闭代理。Script：脚本，按照脚本规则代理。一般不用。通常的设置为Rule模式以及中继线路（推荐中继香港线路）打开General的System Proxy开关启用代理。 4.更新订阅 请确保更新前已关闭代理 若订阅链接没有改变请点击如下最右侧按钮进行更新。若更新失败请重复第二步操作 若订阅链接更改请重复第二步操作 Clash for Android1.安装应用下载安装包 2.订阅链接 安装完成后打开显示如下界面： 点击配置 点击新配置 点击从URL导入1）名称随便填；2）URL填入订阅链接；3）点击右上角保并更新； 3.启用代理 如下图所示选择配置 返回打开代理 点击代理选择节点 右上角可选择模式,默认规则模式 节点选择中继节点(建议香港中继节点) 4.更新订阅 请确保更新前已关闭代理 点击配置–&gt;更多: 点击更新 若订阅链接更改,点击参数更改URL 返回"},{"title":"Quantumult","date":"2020-08-10T05:17:30.000Z","updated":"2021-03-24T09:55:49.614Z","comments":true,"path":"vpn/Quantumult/index.html","permalink":"http://waxll.top/vpn/Quantumult/index.html","excerpt":"","text":""},{"title":"Shadowsocks","date":"2020-08-10T05:17:30.000Z","updated":"2021-03-24T09:55:49.614Z","comments":true,"path":"vpn/Shadowsocks/index.html","permalink":"http://waxll.top/vpn/Shadowsocks/index.html","excerpt":"","text":"返回"},{"title":"ShadowsocksR","date":"2020-08-10T05:17:30.000Z","updated":"2021-03-24T09:55:49.614Z","comments":true,"path":"vpn/SSR/index.html","permalink":"http://waxll.top/vpn/SSR/index.html","excerpt":"","text":"1.下载软件下载压缩包 解压后进入文件夹打开如下软件: 2.订阅链接3.启用代理4.更新订阅返回"}],"posts":[{"title":"Python学习笔记12","slug":"Python学习笔记12","date":"2021-06-16T16:41:47.000Z","updated":"2021-06-16T16:43:10.070Z","comments":true,"path":"2021/06/17/py12.html","link":"","permalink":"http://waxll.top/2021/06/17/py12.html","excerpt":"","text":"第十三章 文件13.1 计算机眼中的文件任务一：文件的概念和作用知识点： 计算机的文件，就是存储在某种长期储存设备上的一段数据 存储设备包括：硬盘、U 盘、移动硬盘、光盘… 文件的作用：将数据长期保存下来，在需要的时候使用 任务二：计算机的文件储存方式知识点： 在计算机中，文件是以二进制的方式保存在磁盘上的 文本文件： 可以使用文本编辑软件查看内容，本质上还是二进制文件 例如：python 的源程序 二进制文件： 保存的内容不是给人直接阅读的，而提供给计算机其他程序使用的 例如：图片文件、音频文件、视频文件等等 二进制文件不能使用文本编辑软件查看 任务三：在控制台中查看文件内容知识点： 在Windows中，控制台指令type查看文件内容 在Linux或Mac中，控制台指令cat查看文件内容 在Jupyter中，cell中输入指令**%pycat**查看文件内容 中文字符可能会在控制台中乱码 13.2 文件操作13.2.1 基本流程任务一：文件操作的基本流程知识点：在计算机中要操作文件方式是非常固定，共包含三个步骤： 1、打开文件 2、读或写文件 读将文件内容读入内存 写将内存内容写入文件 3、关闭文件 任务二：操作文件的基本流程在 Python 中要操作文件需要记住1个函数和3个文件方法 open 函数负责打开文件，并且返回文件对象 read/write/close 三个方法都需要通过文件对象来调用 函数/方法 说明 open 打开文件，并且返回文件操作对象 read 将文件内容读取到内存 write 将指定内容写入文件 close 关闭文件 知识点：文件操作的常用流程 调用**open()**函数打开要操作的文件 调用文件方法**read()或write()**方法对文件进行读写操作 调用**close()**方法关闭文件，释放资源 13.2.2 文件的open()函数与close()方法任务一：open()函数用法知识点： 语法：open(name[, mode, encoding]) 描述：open()函数用于打开一个文件名为name的文件 如果文件存在，返回一个file类型的对象，后续通过该对象进行文件的读写操作 如果文件不存在，会抛出异常 参数：name为包含相对路径或绝对路径的文件名 文件名区分大小写 由于路径中会包含\\字符，与转移标识符冲突。为此，需要使用r字符串前缀，告知Python当前字符串不进行转义 返回：file类型的对象fileObject，用于后续的文件读写操作 例子：相对路径和绝对路径的文件打开方式 在当前目录下创建一个名为README.txt文件 文件中输入几行字符串，然后保存关闭 12345# 相对路径，打开当前根目录文件f = open(&quot;README.txt&quot;)# 绝对路径，字符串前的r表示直接使用字符\\而非转义字符f = open(r&quot;D:\\README.txt&quot;) 任务二：open()函数的可选参数知识点： 参数：mode可选，指定文件打开模式(后续将给出详解)。默认以只读模式打开 参数：encoding关键字参数，可选，指定文件编码方式 对于中文文件，如果编码不匹配，会造成乱码 目前国际上最通用的是**’utf-8’编码。因此，可以设置文件打开的编码为encoding=’utf-8’** 1234# 使用默认只读&quot;r&quot;、&#x27;utf-8&#x27;编码打开&quot;README.txt&quot;# 返回文件对象为ff = open(&quot;README.txt&quot;, encoding=&#x27;utf-8&#x27;)print(type(f)) *任务三：文件的关闭**close()*方法知识点：关闭文件**close()**方法 语法：fileObject.close() 描述：**close()**方法用于关闭一个已打开的文件 关闭后的文件不能再进行读写操作，否则会触发ValueError异常 当文件不再需要使用时，用 **close()**方法关闭文件释放资源是一个好的习惯 参数和返回：无 注意：如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 1234# 关闭的文件对象必须要在内存中存在，否则会出错f = open(&quot;README.txt&quot;)# 文件不再使用，释放资源f.close() 任务四：3种自定义文件路径方式(重要)知识点： 本地文件的访问需要指定路径。如果文件不在当前目录下，就需要明确文件的详细路径 由于常用的路径使用\\来标识路径的层级关系，但是这与\\转移字符的标识冲突。为此，提供了三种解决方案 单个反斜杠：/ 两个斜杠：\\(第一个\\是转义符) r用于防止字符转义 123456789101112# 本地文件的界定：指向一个本地存储的文件，是一个链接或者一个映射# 单个反斜杠：/path1 = &#x27;C:/Users/Hjx/Desktop/text.txt&#x27;# 两个斜杠：\\\\（第一个\\是转义符）path2 = &#x27;C:\\\\Users\\\\Hjx\\\\Desktop\\\\text.txt&#x27; # r用于防止字符转义path3 = r&#x27;C:\\Users\\Hjx\\Desktop\\text.txt&#x27; # 输出文件路径print(path1)print(path2)print(path3) 扩展：任何文件都可以使用鼠标右键-&gt;属性来查看具体文件的绝对路径 13.2.3 open()函数配置读写模式任务一：文件的打开模式知识点： open()函数默认以只读方式打开文件，并且返回文件类型的对象 Python通过open()函数mode参数对文件的操作提供了丰富的控制模式 语法如下： 1f = open(&quot;文件名&quot;, &quot;访问mode&quot;) 任务二：6种文件读写模式知识点：open()函数mode参数解析 r以只读模式打开文件，增强型 r+以可读写模式打开文件 文件的指针将会放在文件的开头 需要该文件必须存在，否则会出错 例如：f = open(“README.txt”, “r”) w以只写模式打开文件，增强型w+以可读写模式打开文件 若文件存在则原内容会被清空 若文件不存在则建立该文件 例如：f = open(“README.txt”, “w”) a以追加只写模式打开文件，增强型a+以追加可读写模式打开文件 如果该文件已存在，文件指针将会放在文件的结尾 如果文件不存在，新建文件进行写入 例如：f = open(“README.txt”, “a”) 注意： 频繁的移动文件指针，会影响文件的读写效率 开发中更多的时候会以只读、只写的方式来操作文件 任务三：文件对象的属性知识点：文件对象的3个属性 fileObject.closed：返回True如果文件已被关闭，否则返回False fileObject.mode：返回被打开文件的访问模式 fileObject.name：返回文件的名称 12345f = open(&quot;README.txt&quot;)print(f&#x27;.closed: &#123;f.closed&#125;&#x27;)print(f&#x27;.mode: &#123;f.mode&#125;&#x27;)print(f&#x27;.name: &#123;f.name&#125;&#x27;)f.close() 13.2.4 文件的读方法任务一：文件的读方法知识点： 语法：fileObject.read(size) 描述：read()从文件中一次性读入并返回文件的所有内容 参数：size为非负整数，可选 指定读取文件的字节数，包括 **”\\n”**字符 默认值，尝试尽可能多地读取文件内容，甚至读取当前整个文件内容 返回：从文件中读取的字符串 注意：read()方法执行后，会把文件指针移动到文件的末尾 例子：文件读程序 首先在当前目录下手动创建一个名为README.txt的文本文件，里面随意写几行内容并保存关闭 然后使用**read()**读取文件 123456789# 1. 打开 - 文件名需要注意大小写file = open(&quot;README.txt&quot;)# 2. 读取text = file.read()print(text)# 3. 关闭file.close() 注意：在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读/写 操作！ 任务二：文件指针知识点： 文件指针并非C语言里的指针 文件指针标记从文件的哪个位置开始读写数据 第一次打开文件时，通常文件指针会指向文件的开始位置 当执行了read()方法后，文件指针会随着读取的内容进行移动 对于当前文件对象，文件指针具有记忆性 即下次再次调用read()方法会从上次读取内容之后开始 默认情况下会移动到文件末尾，除非指定read()方法的size参数 思考： 如果执行了一次**read()**方法，读取了所有内容，那么再次调用 **read()**方法，还能够获得到内容吗 答案：不能。第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容 13.2.5 按行读取文件任务一：按行读取文件需求分析： read()方法默认会把文件的所有内容一次性读取到内存中 如果文件太大，对内存消耗会非常严重 知识点： 语法：fileObject.readline() 描述：**readline()**方法一次读取文件的一行内容 参数：无 返回：返回从文件当前行中读取的字符串 注意：该方法执行后，会把文件指针移动到下一行，准备下次读取。依次读取所有行，直到文件结束符 EOF 例子：大文件读取方式 1234567891011121314# 打开文件file = open(&quot;README.txt&quot;)while True: # 读取一行内容 text = file.readline() # 判断是否读到内容 if not text: break # 每读取一行的末尾已经有了一个 `\\n` print(text, end=&quot;&quot;)# 关闭文件file.close() 实例：爬取POI数据并转换为JSON格式需求： 利用百度POI小插件爬取一些POI数据，然后存成txt文档 再用Python读取，编写成一个json格式(列表嵌套字典)：**[{‘name’:’…’,’lng’:…,’lat’:…,’address’:’…’},{…},…,]** 第一步：爬取数据地址：https://www.metrodata.cn/poi 。输入地区和关键字，稍等几分钟就会出现爬取的数据。可以自定义查询参数 第二步：使用Python将数据转换为JSON格式 1234567891011121314151617181920f = open(&#x27;shaoxian.txt&#x27;,&#x27;r&#x27;) # 读取txt文件m = [] # 新建一个空列表，用于存储数据n = 0for line in f.readlines(): n += 1 st1 = line.split(&#x27;:&#x27;) name = st1[0] # 先以:拆分，筛选出name文本 information = st1[1] # 第二部分包括lng，lat，address st2 = information.split(&#x27;,&#x27;) lng = float(st2[0]) # 筛选出lng lat = float(st2[1]) # 筛选出lat ad = st2[2].strip() # 筛选出address，去除末尾空格 # 做成嵌套列表 data = [[&#x27;name&#x27;,name],[&#x27;lng&#x27;,lng],[&#x27;lat&#x27;,lat],[&#x27;address&#x27;,ad]] m.append(dict(data)) # 生成字典，并追加如列表m #print(&#x27;成功转换%i个数据&#x27;%n)print(m)print(&#x27;\\n数据转换完成！总共转换%i个数据&#x27;%n) 13.2.6 文件的写方法任务一：文件写方法write()知识点： 语法：fileObject.write(str) 描述：**write()**方法用于向文件中写入指定字符串 参数：str为向文件写入指定的字符串 返回：返回的是写入的字符长度 注意：write()方法不会向字符串尾部自定添加换行符，需要手动添加**”\\n”** 例子：文件写操作 12345678# 需要以写模式&quot;w&quot;打开文件f = open(&quot;README.txt&quot;, &quot;w&quot;)f.write(&quot;hello python！\\n&quot;)f.write(&quot;今天天气真好&quot;)# 关闭文件f.close() 任务二：将列表写入文件通过**writelines()**函数，将列表作为参数，写入文件 1234567# 当前目录f = open(&#x27;test_write.txt&#x27;, &#x27;w&#x27;, encoding = &#x27;utf8&#x27;)lst = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]f.writelines(lst)f.close()# f.writelines(list)：依次把列表元素写入，但这里有没有换行？# 如果想每一个元素换行怎么办？每个元素后都有&quot;\\n&quot; 通过遍历为列表的每个元素添加换行符，考虑列表推导式方式 123456789f = open(&#x27;test_write2.txt&#x27;, &#x27;w&#x27;, encoding = &#x27;utf8&#x27;)lst = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]for i in range(len(lst)): lst[i] = lst[i] + &#x27;\\n&#x27; f.writelines(lst)f.close()# 通过遍历给每个元素最后加上&quot;\\n&quot; 13.2.7 (重要) with as语句维护文件操作环境需求分析： 任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃 例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患 但是，即便使用close()做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件 知识点： 在Python中，对应的解决方式是使用 with as 语句操作上下文管理器(context manager)，它能够帮助我们自动分配并且释放资源 通过使用 with as 语句，打开的文件对象，无论期间是否抛出异常，都能保证with as语句执行完毕后自动调用**close()**方法 知识点：with as 语句的基本语法格式为： 12with 表达式 as obj： 代码块 表达式：可以是资源打开函数的返回对象。比如文件**open()**函数，数据库连接函数等 obj：资源对象。比如文件**open()**函数返回的文件对象 将下面的代码改为为with…as语句 12345678# 需要以写模式&quot;w&quot;打开文件f = open(&quot;README.txt&quot;, &quot;w&quot;)f.write(&quot;hello python！\\n&quot;)f.write(&quot;今天天气真好&quot;)# 关闭文件f.close() 有时候不得不承认Python编程就是一种享受，只要掌握该语言的某些特性 123456# 将open()函数的返回值通过as赋值给f文件对象with open(&quot;README.txt&quot;, &quot;w&quot;) as f: f.write(&quot;hello python！\\n&quot;) f.write(&quot;今天天气真好&quot;) # 退出with作用域(语句块)，f对象自动销毁 13.3 综合实例13.3.1 实例：文件指针问题下面程序功能，打开一个文件，然后先向文件**write()写入字符串，然后再read()**读取字符串，并输出 1234567891011121314# 请换一个文件名，&quot;w+&quot;为读写模式f = open(&quot;Data.txt&quot;, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;)# 手动添加换行符\\ndata_str = &quot;hello python\\n&quot;# 写3行data_strf.write(data_str)f.write(data_str)f.write(data_str)file_str = f.read()print(file_str)f.close() 程序解析： **f = open(“Data.txt”, “w+”, encoding=’utf-8’)，以增强型“w+”读写方式、‘utf-8’编码打开文件“Data.txt”，由于该文件不存在，所以“Data.txt”**文件会被创建 调用3次写文件**f.write(data_str)**方法，在文件中写入3行字符串 然后，再调用读文件**f.read()方法，希望读取之前写入的内容。但是发现，读取内容为空。但是打开“Data.txt”**后，发现字符串已经被写入到文件中 原因分析： 当写文件完成时，文件的当前文件指针会处于文件末尾处 如果继续执行读取操作，系统从该光标处向后读取，但该文件指针已处于文件的末尾，所以读出内容为空 解决方法一：规范代码，将写文件和读文件分开。在执行完一个操作后应及时关闭文件对象**f.close()**。使用这种方法可以是文件安全有效，不会被其他操作影响预计效果 123456789101112f = open(&quot;Data.txt&quot;, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;)data_str = &quot;hello python\\n&quot;f.write(data_str)f.write(data_str)f.write(data_str)f.close() #关闭文件# 重新打开文件，文件指针回到文件开始f = open(&quot;Data.txt&quot;, &quot;r+&quot;, encoding=&#x27;utf-8&#x27;)file_str = f.read()print(file_str)f.close() 或者使用文件的逐行遍历 12345f = open(&quot;Data.txt&quot;, &quot;r+&quot;, encoding=&#x27;utf-8&#x27;)for line in f.readlines(): print(line, end = &#x27;&#x27;)f.close() 解决方法二：使用**seek()**方法移动光标至指定位置 知识点：文件光标移动 语法：fileObject.seek(offset,whence=0) 参数：offset为偏移量，即需要移动偏移的字节数 参数：whence为要从哪个位置开始偏移，默认值为0；0代表从文件开始为起始点，1代表从当前位置为起始点，2代表从文件末尾为起始点 12345678910111213f = open(&quot;Data.txt&quot;, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;)data_str = &quot;hello python\\n&quot;f.write(data_str)f.write(data_str)f.write(data_str)# offset= 0，whence=0# 从文件开始，以偏移量为0设置光标。f.seek(0,0)file_str = f.read()print(file_str)f.close() 习题：将上面文件操作程序修改为with as语句结构 12345678with open(&quot;Data.txt&quot;, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;) as f: data_str = &quot;hello python\\n&quot; f.write(data_str) f.write(data_str) f.write(data_str) f.seek(0,0) file_str = f.read() print(file_str) 13.3.2 实例：文件数据的数值求和需求分析： 在while循环章节中，所有平均值计算程序都有一个缺点：数字都需要用户手动输入。试想用户正在尝试着求100个数字的平均值，而恰巧在接近尾声时发生了打字错误。如果用户使用上面编写的程序，就需要从头开始，想想就崩溃 为此，解决该问题的一个可行方法是首先将所有数字都输入到文件中，即使用户在文件中输错了数字，也可以很轻易地进行修改和编辑 因此，需要将之前设计的平均值计算程序从用户输入数据改写为从文件中读取数据 这种面向文件的程序数据处理方式在现实应用中非常常见 本节将学习如何从文件中读取数据，然后实现哨兵式循环来计算平均数 任务一：数据生成创建一个数据文件，共100行，每一行为一个随机数 1234567891011121314import random as rd# 例如：Data.txtname = input(&#x27;请输入文件名: &#x27;)f = open(name, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;)for i in range(100): # 随机生成[-10,10]区间的整数 num = rd.randint(-10, 10) # 将num转换为字符串，与换行符&#x27;\\n&#x27;拼接，写入文件中 f.write(str(num) + &#x27;\\n&#x27;)print(f&#x27;生成结束，请打开&#123;name&#125;查看结果&#x27;) f.close() 任务二：while哨兵式循环来计算平均值下面将对文件中的数字进行求平均，使用文件结束符EOF或空字符**””**作为循环的哨兵 123456789101112131415161718# 输入之前生成数字的文件：Data.txtfileName = input(&quot;输入文件名: &quot;)infile = open(fileName,&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)total = 0.0count = 0# 从文件中先读一行line = infile.readline()# 将line为空作为哨兵，即读到文件末尾while line != &quot;&quot;: total += float(line) count += 1 line = infile.readline()print(&quot;平均值为：&quot;, total / count)f.close() 任务三：for循环来计算平均值相对于其他语言，Python提供了简便的文件读取方式，使用**readlines()**方法读取整个文件，返回以行为元素的列表。然后，通过for循环遍历元素(行)，并对其做运算 1234567891011121314# 输入之前生成数字的文件：Data.txtfileName = input(&quot;输入文件名: &quot;)infile = open(fileName,&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)total = 0.0# 将文件按行读，返回列表lines = infile.readlines()# 再用for循环遍历列表元素for line in lines: total = total + float(line)print(&quot;平均值为：&quot;, total / len(lines))f.close() 程序解析： 显然，for循环比while循环更简洁 这程序for循环之所以能用，是因为Python提供了readlines()方法将整个文件以行为元素，返回列表。然后，就可以使用Python的确定循环(for循环)，来遍历和处理列表元素 对于非Python语言，并不一定提供readlines()这么方便的方法。因此，只能通过哨兵式的while循环，进行文件读和相关运算 习题：将上面文件操作程序修改为with as语句结构 1234567import random as rdname = input(&#x27;请输入文件名: &#x27;)with open(name, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;) as f: for i in range(100): num = rd.randint(-10, 10) f.write(str(num) + &#x27;\\n&#x27;) print(f&#x27;生成结束，请打开&#123;name&#125;查看结果&#x27;) 13.3.3 实例：复制文件任务一：小文件复制打开一个已有文件，读取完整内容，并写入到另外一个文件 1234567891011# 1. 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)# 2. 读取并写入文件text = file_read.read()file_write.write(text)# 3. 关闭文件file_read.close()file_write.close() 任务二：大文件复制打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件 123456789101112131415161718# 1. 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)# 2. 读取并写入文件while True: # 每次读取一行 text = file_read.readline() # 判断是否读取到内容 if not text: break file_write.write(text)# 3. 关闭文件file_read.close()file_write.close() 13.4 (常识) 文件和目录管理操作13.4.1 常用文件和目录函数介绍知识点： 在控制台终端或文件系统中可以执行常规的文件/目录管理操作，例如：创建、重命名、删除、改变路径、查看目录内容等 在Python中，实现上述功能需要导入 os 模块 注意： Jupyter的cell支持IPython的文件和目录管理指令 文件查询命令：**%ls** 显示文件内容：**%cat** 任务三：文件操作 方法名 说明 示例 rename 重命名文件 os.rename(源文件名, 目标文件名) remove 删除文件 os.remove(文件名) 任务四：目录操作 方法名 说明 示例 listdir 目录列表 os.listdir(目录名) mkdir 创建目录 os.mkdir(目录名) rmdir 删除目录 os.rmdir(目录名） getcwd 获取当前目录 os.getcwd(） chdir 修改工作目录 os.chdir(目标目录) path.isdir 判断是否是文件 os.path.isdir(文件路径) 13.4.2 相对路径和绝对路径任务一：当前目录知识点：什么是当前工作目录？ 每个运行在计算机上的程序，都有一个“当前工作目录”( cwd) 使用**os.getcwd()**函数取得当前工作路径 使用os.chdir() 切换当前目录，类似控制台的cd指令 123456789# 导入os模块import os# 获得当前目录print(os.getcwd())# 切换当前目录os.chdir(&#x27;C:\\Windows\\System32&#x27;)print(os.getcwd()) 注意： 如果使用os.chdir()修改当前目录，当指定目录不存在时，Python 解释器触发异常FileNotFoundError 例如，os.chdir(‘C:\\error’)，假设error目录不存在 任务二：相对路径和绝对路径 (重要)知识点：明确一个文件所在的路径，有 2 种表示方式，分别是： 绝对路径：总是从根文件夹开始 Window 系统中以盘符(C:、D:)作为根文件夹 Mac或Linux系统中以**/**作为根文件夹 相对路径：指的是文件相对于当前工作目录所在的位置 例如，当前工作目录为”C:\\Windows\\System32”，若文件 demo.txt 就位于这个 System32 文件夹下，则demo.txt的相对路径表示为 “.\\demo.txt” 其中 .\\ 就表示当前所在目录 知识点(常识)：常用的相对路径表示 .\\ 表示当前所在目录。例如 .\\data.txt，表示当前文件夹中data.txt文件 ..\\ 表示当前所在目录的父目录。例如 ..\\data.txt，表示父文件夹中的data.txt文件 任务三：os.path模块知识点：Python os.path 模块提供了一些函数，可以实现绝对路径和相对路径之间的转换，以及检查给定的路径是否为绝对路径，例如： 调用 os.path.abspath(path) 将返回 path 参数的绝对路径的字符串，这是将相对路径转换为绝对路径的简便方法 调用 **os.path.isabs(path)**，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False 调用 os.path.relpath(path, start) 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径 调用 os.path.dirname(path) 将返回一个字符串，表示文件夹路径。它包含 path 参数中最后一个斜杠之前的所有内容 调用 os.path.basename(path) 将返回一个字符串，表示文件名。它包含 path 参数中最后一个斜杠之后的所有内容 注意：例子中的路径可以根据实际情况自定义，不必要完全遵照本节的例子，根据自己的系统环境对本节代码做适当调整即可 1234567891011# 获得当前路径print(os.getcwd())# 获得当前路径的绝对路径print(os.path.abspath(&#x27;.&#x27;))# 获得相对路径&#x27;.\\Scripts&#x27;的的绝对路径print(os.path.abspath(&#x27;.\\Scripts&#x27;))# 测试当前path是否为绝对路径，输出Falseprint(os.path.abspath(&#x27;.&#x27;)) 123456789101112# os.path.abspath(&#x27;.&#x27;)获得绝对路径# 然后作为实参传递给os.path.isabs()函数# 输出为Trueprint(os.path.isabs(os.path.abspath(&#x27;.&#x27;)))# 从&#x27;C:\\&#x27;开始，到&#x27;C:\\Windows&#x27;的相对路径# 输出为&#x27;Windows&#x27;，结合截图来理解print(os.path.relpath(&#x27;C:\\Windows&#x27;, &#x27;C:\\&#x27;))# 从&#x27;C:\\spam\\eggs&#x27;开始，到&#x27;C:\\Windows&#x27;的相对路径# 输出为&#x27;..\\..\\Windows&#x27;，结合截图来理解print(os.path.relpath(&#x27;C:\\Windows&#x27;, &#x27;C:\\spam\\eggs&#x27;)) 123456# 获得文件名(不含路径)，输出为&#x27;calc.exe&#x27;path = &#x27;C:\\Windows\\System32\\calc.exe&#x27;print(os.path.basename(path))# 获得路径名(不含文件)print(os.path.dirname(path)) 13.4.3 实例：文件目录操作例子中的文件路径都需要根据具体文件位置进行自定义 12345678910111213141516171819202122232425# os模块：系统模块 - 常用命令import os # 导入模块# 输出字符串指示正在使用的平台。# 如果是window 则用&#x27;nt&#x27;表示# 对Linux/Unix用户，它是&#x27;posix&#x27;。print(os.name) # 函数得到当前工作目录，即当前Python脚本工作的目录路径。print(os.getcwd()) # 返回指定目录下的所有文件和目录名。print(os.listdir()) # 切换到目标路径#os.chdir(&#x27;C:\\\\Users\\\\Hjx\\\\Desktop\\\\&#x27; ) #print(os.getcwd())# 删除一个文件#os.remove(&#x27;text2.txt&#x27;) # 函数返回一个路径的目录名和文件名print(os.path.split(&#x27;C:\\\\Users\\\\Hjx\\\\Desktop\\\\text.txt&#x27;)) # 用来检验给出的路径是否真地存在# 这里不存在改文件故False，但路径存在故Trueprint(os.path.exists(&#x27;C:\\\\Users\\\\Hjx\\\\Desktop\\\\heheh.txt&#x27;))print(os.path.exists(&#x27;C:\\\\Users\\\\Hjx\\\\Desktop\\\\&#x27;)) 13.5 (常识) UTF-8编码解决中文乱码问题知识点：文本文件存储的内容是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等 Python 2默认使用 ASCII 编码格式 Python 3默认使用 UTF-8 编码格式 如果文件或网络爬虫数据中包含非 ASCII 编码字符，首先要将字符转换为 UTF-8 编码，才能被不会出现乱码问题 任务一：ASCII 编码和 UTF-8 编码知识点：ASCII 编码 计算机中只有 256 个 ASCII 字符。 一个 ASCII 在内存中占用 1 个字节 的空间。 8 个 0/1 的排列组合方式一共有 256 种，也就是 2 ** 8 对于中文如果使用ASCII 码，将会出现乱码 知识点：UTF-8 编码格式 计算机中使用 1~6 个字节来表示一个UTF-8字符，涵盖了地球上几乎所有地区的文字 大多数汉字会使用3 个字节表示 UTF-8是UNICODE编码的一种编码格式 任务二：使用UTF-8 编码防止中文乱码虽然Python 3.x默认使用 UTF-8 编码格式，但是对于中文文件也会出现乱码问题，特别是读取包含中文的文本 知识点：建议在源文件的第一行增加以下代码，解释器会以 utf-8 编码来处理 python文件 123#在源文件的第一行增加以下代码(二选一)# *-* coding:utf8 *-*# coding=utf8 在读取包含中文文件时，**open()**函数指定encoding参数为 utf-8 。例如： 12345f = open(&quot;Data.txt&quot;, &quot;r+&quot;, encoding=&#x27;utf-8&#x27;)for line in f.readlines(): print(line, end = &#x27;&#x27;)f.close() 任务三：使用UTF-8编码字符串知识点： 在 Python 2 中，即使指定了文件使用 UTF-8 的编码格式，但是在遍历字符串时，仍然会以字节为单位遍历字符串 要能够正确的遍历字符串，在定义字符串时，需要在字符串的引号前，增加一个小写字母 u，告诉解释器这是一个 unicode 字符串 虽然Python 3的字符串都使用 UTF-8编码，但是如果字符串来自文件或网络爬虫数据(可能不是使用UTF-8)，需要将它们先转换为UTF-8，程序才不会出现乱码问题 123456789# *-* coding:utf8 *-*# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串hello_str = u&quot;你好世界&quot;print(hello_str)for c in hello_str: print(c)","categories":[],"tags":[]},{"title":"Python学习笔记11","slug":"Python学习笔记11","date":"2021-06-16T16:39:55.000Z","updated":"2021-06-16T16:41:30.877Z","comments":true,"path":"2021/06/17/py11.html","link":"","permalink":"http://waxll.top/2021/06/17/py11.html","excerpt":"","text":"第十一章 函数：返回值与进阶用法11.1 函数的返回值11.1.1 向函数外部传递信息：返回值函数返回值的用法需求：函数并非总是直接通过print()来显示结果。有时，希望函数在执行完成后，将有用的处理结果，返回给调用者，以便做后续的处理 知识点： 返回值：在函数执行完后，返回给它的调用者一个结果 如果把函数看作是一个黑箱的话，那么输入就是函数的参数，输出就是函数的返回值 通过使用函数的返回值，可以让将程序的大部分繁重工作都移到函数子程序中去完成，从而简化主程序 知识点： 在函数中，可使用return关键字来返回结果 外部调用函数之处，可以使用变量来接收函数的返回 任务一：改进带返回的求和函数例子：带返回的两个数求和程序 123456789def sum_2_num(num1, num2): &quot;&quot;&quot;对两个数字的求和&quot;&quot;&quot; return num1 + num2# 调用函数，并使用 result 变量接收计算结果result = sum_2_num(10, 20)print(f&quot;计算结果是 &#123;result&#125;&quot;) 任务二：返回之后的代码将不被执行注意：return 表示返回，当执行return 后，它后续代码都会不被执行 例子： 12345678910def sum_2_num(num1, num2): &quot;&quot;&quot;对两个数字的求和&quot;&quot;&quot; return num1 + num2 # return之后的代码永远不被执行 num = 1000 print(num)# 调用函数，并使用 result 变量接收计算结果result = sum_2_num(10, 20)print(f&quot;计算结果是 &#123;result&#125;&quot;) 11.1.2 利用元组函数返回多个值任务一：函数多个返回值的需求分析问题：在Python中，一个函数执行后能否返回多个结果 下面将通过一个例子来分析函数多个返回值的实际需求 例子：温度和湿度测量程序。假设要开发一个函数能够同时返回当前的温度和湿度。首先，实现函数的单个返回值(温度)功能 123456789def measure(): &quot;&quot;&quot;返回当前的温度&quot;&quot;&quot; print(&quot;开始测量...&quot;) temp = 39 print(&quot;测量结束...&quot;) return tempresult = measure()print(result) 任务二：使用元组传递函数多个返回值知识点(回顾)： 函数传递多个返回值 在C++中，函数允许最多传回一个返回值，否则会出错 在Python中，通过元组可以实现传递函数的多个返回值功能。对函数的多个返回值使用元组进行打包，然后在函数调用之处进行解包赋值 1234567#观察divmod()函数# 返回值：商和余数，被打包在一个元组print(divmod(15, 2))# 通过元组解包，接受函数的多个返回值x, y = divmod(15, 2)print(&#x27;divmod(15, 2)，商：&#123;&#125;，余数：&#123;&#125;&#x27;.format(x, y)) 下面，将利用元组在返回温度的同时，也能够返回湿度信息 12345678910111213141516def measure(): &quot;&quot;&quot;测量温度和湿度&quot;&quot;&quot; print(&quot;测量开始...&quot;) temp = 39 wetness = 50 print(&quot;测量结束...&quot;) # 元组-可以包含多个数据，因此可以使用元组让函数一次返回多个值 # 如果函数返回的类型是元组，小括号可以省略 # return (temp, wetness) return temp, wetness# 元组result = measure()print(result) 知识点： 如果一个函数返回值是元组，括号可以省略 在 Python 中，可以将一个元组通过赋值语句解包给给多个变量 注意：解包时，变量数量需要与元组元素数量保持一致 1234567891011# 需要单独的处理温度或者湿度 - 不方便print(result[0])print(result[1])# 如果函数返回的类型是元组，同时希望单独的处理元组中的元素# 可以使用多个变量，一次接收函数的返回结果# 注意：使用多个变量接收结果时，变量的个数应该和元组中元素的个数保持一致gl_temp, gl_wetness = measure()print(gl_temp)print(gl_wetness) 11.1.3 实例：交换两个数字要求：有两个整数变量 a = 6, b = 100，如果不使用其他变量，如何交换两个变量的值 解法 1 —— 使用其他变量123456789# 解法 1 - 使用临时变量a = 6b = 100print(a,b)c = bb = aa = cprint(a,b) 解法 2 —— 不使用临时变量123456789# 解法 2 - 不使用临时变量a = 6b = 100print(a,b)a = a + bb = a - ba = a - bprint(a,b) 解法 3 —— Python 专有，利用元组1234567# 通过元组的封包和解包功能a = 6b = 100print(a,b)a, b = b, aprint(a,b) 11.1.4 实例：人物信息构建任务一：带返回的姓名拼接函数需求：接受姓和名，并返回首字母大写的全名 1234567def get_formatted_name(first_name, last_name): &quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot; full_name = first_name + &#x27; &#x27; + last_name return full_name.title()name = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)print(name) 程序解析： 函数get_formatted_name()接受两个参数first_name名和last_name姓 函数体中，名和姓进行拼接(中间加1空格)，并将结果存储在变量full_name中 然后，将full_name字符串调用**.title()**方法转换为首字母大写格式，并将其作为返回值 主程序中，使用变量name接受函数**get_formatted_name()**的返回值，并打印输出结果 任务二：使用默认值实参改进姓名函数需求：有些人还拥有中间名 因此，需要扩展函数get_formatted_name()，来满足中间名需求 1234567def get_formatted_name(first_name, middle_name, last_name): &quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot; full_name = first_name + &#x27; &#x27; + middle_name + &#x27; &#x27; + last_name return full_name.title()name = get_formatted_name(&#x27;john&#x27;, &#x27;lee&#x27;, &#x27;hooker&#x27;)print(name) 程序解析： 在调用函数时，只需提供名、中间名和姓，**get_formatted_name()**函数就能正确地运行 它根据三个实参，创建一个以空格为分隔符的拼接full_name字符串，并将结果转换为首字母大写格式 需求： 并非所有的人都有中间名。如果调用函数时，只提供了名和姓两个实参，它将不能正确地运行 为让中间名变成可选的，可给实参middle_name指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参 函数体中，需要对2个参数(名+姓)和3个参数(名+中间名+姓)进行分别处理，可以借助if语句实现流程控制 注意：带默认值的参数，必须要在非默认值参数之后 1234567891011121314def get_formatted_name(first_name, last_name, middle_name=&#x27;&#x27;): &quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot; if middle_name: full_name = first_name + &#x27; &#x27; + middle_name + &#x27; &#x27; + last_name else: full_name = first_name + &#x27; &#x27; + last_name return full_name.title()name = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)print(name)name = get_formatted_name(&#x27;john&#x27;, &#x27;hooker&#x27;, &#x27;lee&#x27;)print(name) 程序解析： 由于每个人都拥有名和姓，因此在函数定义中首先给出这两个形参。中间名是可选的，因此在函数定义中最后列出该形参，并将其默认值设置为空字符串 在函数体中，通过if判断检查参数middle_name是否为空。然后使用两种full_name的拼接方式，最后再将其修改为首字母大写格式，并返回给外部 位置参数调用函数时，必须要确保每个位置实参能正确地关联到相应的形参。调用函数时，如果只指定名和姓，调用起来将非常简单。如果需要指定中间名，就必须确保中间名传递给middle_name(最后个参数) 任务三：改进函数返回值为字典知识点：函数可返回任何类型的值，包括列表和字典等较复杂的数据结构 例子：人物构建函数，接受名和姓，返回一个表示人属性的字典： 1234567def build_person(first_name, last_name): &quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息&quot;&quot;&quot; person = &#123;&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name&#125; return personname = build_person(&#x27;三&#x27;, &#x27;张&#x27;)print(name) 程序解析： 函数**build_person()**接受名和姓，并将这些值封装到字典中 存储first_name的值时，使用的键为**’first’；而存储last_name的值时，使用的键为‘last’**。最后，返回表示人属性的字典 在主程序中，打印返回值(字典)，此时原来的两项文本信息存储在一个字典中：**{‘first’: ‘三’, ‘last’: ‘张’}** 任务四：改进函数接受年龄参数扩展函数功能，让它能接受更多的参数，如中间名、年龄、职业或你要存储的其他任何信息。例如，下面程序可以储存姓名和年龄： 123456789def build_person(first_name, last_name, age=&#x27;&#x27;): &quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息&quot;&quot;&quot; person = &#123;&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name&#125; if age: person[&#x27;age&#x27;] = age return personname = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, age=27)print(name) 程序解析： 在函数定义中，新增一个可选形参age，并将其默认值设置为空字符串 如果函数调用中包含这个形参的值，就将该值将存储到字典中；否则，直接返回无年龄信息的字典 任务五：循环接受外部输入储存用户信息需求： 使用while哨兵式循环，不断接受用户循环输入,直到输入q为止 调用之前姓名构造函数，将用户输入作为函数的参数，并返回完整的姓名 1234567891011121314151617181920212223def get_formatted_name(first_name, last_name): &quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot; full_name = first_name + &#x27; &#x27; + last_name return full_name.title()# 循环条件为Truewhile True: print(&quot;\\nPlease tell me your name:&quot;) print(&quot;(enter &#x27;q&#x27; at any time to quit)&quot;) # 遇到用户输入q，则退出循环 f_name = input(&quot;First name: &quot;) if f_name == &#x27;q&#x27;: break l_name = input(&quot;Last name: &quot;) if l_name == &#x27;q&#x27;: break # 打印输出结果 formatted_name = get_formatted_name(f_name, l_name) print(&quot;\\nHello, &quot; + formatted_name + &quot;!&quot;) 在程序中，添加了一条消息来告诉用户如何退出，然后在每次提示用户输入时，都检查他输入的是否是退出值，如果是，就退出循环。现在，这个程序将不断地问候，直到用户输入的姓或名为**’q’**为止 11.2（重要）进阶函数11.2.1 分析函数参数和返回值的作用任务一：四种组合形式知识点：函数根据有没有参数以及有没有返回值，可以相互组合，一共有4 种组合形式。 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 知识点： 定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来决定的 如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部。 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 任务二：无参数，无返回值知识点： 此类函数，不接收参数，也没有返回值 应用场景：只是单纯地做一件事情，例如显示菜单、打印提示语等 在函数内部针对全局变量进行操作，例如：新建名片，将最终结果记录在全局变量中 注意： 如果全局变量的数据类型是一个可变类型，在函数内部可以使用方法修改全局变量的内容，变量的引用不会改变 在函数内部，使用赋值语句才会修改变量的引用 任务三：无参数，有返回值知识点： 此类函数，不接收参数，但是有返回值 例如，采集数据程序(温度计)。返回结果就是当前的温度，而不需要传递任何的参数 任务四：有参数，无返回值知识点： 此类函数，接收参数，没有返回值 函数内部的代码保持不变，针对不同的参数处理不同的数据 例如，名片管理系统针对找到的名片做修改、删除操作 任务五：有参数，有返回值知识点： 此类函数，接收参数，同时有返回值 应用场景：函数内部的代码保持不变，针对不同的参数 处理 不同的数据，并且返回期望的处理结果 例如，名片管理系统使用字典默认值和提示信息提示用户输入内容：如果输入，返回输入内容；如果没有输入，返回字典默认值 11.2.2 函数的嵌套调用任务一：嵌套的函数流程分析知识点：所谓的函数嵌套调用就是在一个函数里面又调用了另外的函数 例子：函数的嵌套使用 123456789101112131415def test1(): print(&quot;*&quot; * 50) print(&quot;test 1&quot;) print(&quot;*&quot; * 50)def test2(): print(&quot;-&quot; * 50) print(&quot;test 2&quot;) #先执行完的嵌套函数test1()再继续外层函数 test1() print(&quot;-&quot; * 50)test2() 程序解析：如果函数 test2 中，调用了另外一个函数 test1 那么执行到调用 test1 函数时，会先把函数 test1 中的任务都执行完 才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码 任务二：百度网站解读函数嵌套调用例子：通过百度网站列举说明现实应用中的嵌套调用，仅为了直观解释什么是函数的嵌套 实例：打印分隔符知识点： 程序往往会因需求而不停地调整和更新 通过函数可以实现对功能代码的统一管理 当需求发生变化时，只需对相应函数的内部进行更新，而其他外部代码不变 需求 1：定义一个 print_line 函数能够打印 ***** 组成的一条分隔线 12def print_line(char): print(&quot;*&quot; * 50) 需求 2：定义一个函数能够打印由任意字符组成的分隔线 12def print_line(char): print(char * 50) 需求 3：定义一个函数能够打印任意重复次数的分隔线 12def print_line(char, times): print(char * times) 需求 4：定义一个函数能够打印5行的分隔线，分隔线要求符合需求3 注意：在面对实际问题变化时，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数 123456789def print_line(char, times): print(char * times)def print_lines(char, times): row = 0 while row &lt; 5: print_line(char, times) row += 1 11.2.3 模块中的函数任务一：认识模块的功能知识点： 模块是Python程序架构的一个核心概念，将多个拥有功能类似的函数打包封装到模块中。它是比函数更高一级的程序集 模块就好比是拥有某种功能的工具包，如果要想使用工具包中的工具(函数)，就需要提前通过import导入该模块。 每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块 模块名就是文件名。在其他程序中，通过import 模块名来导入该模块 实例：体验模块步骤一：新建 py_seplines.py 步骤二：复制打印5行的分隔线程序，并添加一个额外的字符串变量name 注意：复制代码时小心代码块的缩进，建议先放cell中用小锤子插件格式化后，再复制到**.py**文件中 1234567891011def print_line(char, times): print(char * times)def print_lines(char, times): row = 0 while row &lt; 5: print_line(char, times) row += 1 name = &#x27;张三的模块&#x27; 步骤三：在Jupyter中，新建一个cell，并添加如下代码 12345# 模块名为文件名import py_seplinespy_seplines.print_line(&quot;-&quot;, 80)print(py_seplines.name) 或者使用as关键字对import模块进行重命名： 1234import py_seplines as py_seppy_sep.print_line(&quot;-&quot;, 80)print(py_sep.name) 总结： 可以在一个Python 文件中定义变量或者函数 然后在另外一个文件中使用 import 导入该模块 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，调用该模块中定义的变量或函数 模块可以让曾编写过的代码集方便的被复用 函数是多行代码块的复用，而模块是多个函数和变量的复用 任务二：模块名也是一个标识符知识点： 模块名、函数名、变量都属于标识符 标示符的命名可由字母、下划线 和数字组成 不能以数字开头 不能与关键字或保留字重名 注意：如果在给Python文件起名时，以数字开头导入模块会出错 任务三：模块的Pyc文件知识点： 为了提高模块的运行效率，Python对模块进行预编译 预编译后的模块名文件为**.pyc。放在与.py**模块源代码同级目录的__pycache__文件夹中 这里的c 是 compiled 编译过的程序 知识点：查看**.pyc**文件 浏览与**.py**模块源代码同级目录的__pycache__文件夹 该目录下会有一个 py_seplines.cpython-37.pyc 文件，cpython-37 表示 Python 解释器的版本是3.7 这个 pyc 文件是由Python解释器将模块的源码转换为字节码。Python 通过字节码来优化代码运行效率 知识点：字节码 Python 在解释源程序时是分成两个步骤的： 首先处理源代码，编译生成一个二进制字节码 再对字节码进行处理，才会生成 CPU 能够识别的机器码 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python将会直接加载 .pyc文件并跳过编译这个步骤。 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳。如果发现源代码被修改，那么下次程序运行时，字节码将被重新创建 模块是Python程序架构的一个核心概念 11.2.4 函数中的变量引用任务一：变量与数据知识点：函数通过引用传递数据 变量和数据都是保存在内存中的 在 Python 中函数的参数传递以及返回值都是靠引用传递的 知识点：变量与数据 变量和数据 是分开存储的 数据保存在内存中的一个位置 变量中保存着数据在内存中的地址 变量中记录数据的地址，就叫做引用 使用 id() 函数可以查看变量中保存数据所在的内存地址 知识点：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量不再对之前的数据引用 变量改为对新赋值的数据引用 任务二：数据的赋值在 Python 中，变量类似于 贴在数据上的标签 定义一个整数变量 a，并且赋值为 1。a=1 将变量 a 赋值为 2。a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b。b = a 变量 b 是第 2 个贴在数字 2 上的标签 任务三：函数的参数和返回值的传递知识点：在 Python 中，函数的实参/返回值都是是靠引用来传递来的 函数的参数是通过引用来传递 函数的返回值也是通过引用来传递 12345678910111213141516def test(num): print(&quot;-&quot; * 50) print(f&quot;&#123;num&#125; 在函数内的内存地址是 &#123;id(num)&#125;&quot;) result = 100 print(f&quot;返回值 &#123;result&#125; 在内存中的地址是 &#123;id(result)&#125;&quot;) print(&quot;-&quot; * 50) return resulta = 10print(f&quot;调用函数前 内存地址是 &#123;id(a)&#125;&quot;)r = test(a)print(f&quot;调用函数后 实参内存地址是 &#123;id(a)&#125;&quot;)print(f&quot;调用函数后 返回值内存地址是 &#123;id(r)&#125;&quot;) 11.2.5 不可变类型与哈希函数 (重要)任务一：基本概念解析知识点：不可变类型，内存中的数据不允许被修改 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 知识点：可变类型，内存中的数据可以被修改 列表 list 字典 dict 1234a = 1a = &quot;hello&quot;a = [1, 2, 3]a = [3, 2, 1] 任务二：赋值与可变类型修改知识点： 初学者很容易将赋值误认为是对变量对应内存内容修改 通过赋值修改变量时，原内存内容不变，而内存地址变化。重新把标签贴在另个空间上 可变类型数据，通过方法修改数据时，原内存内容变化，而内存地址不变化 任务三：列表和字典的修改和赋值知识点： 可变类型的数据修改，是通过方法来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量不再对之前的数据引用。 变量改为对新赋值的数据引用 12345678910111213141516demo_list = [1, 2, 3]print(f&quot;定义列表后的内存地址 &#123;id(demo_list)&#125;&quot;)demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print(f&quot;修改数据后的内存地址 &#123;id(demo_list)&#125;&quot;)demo_dict = &#123;&quot;name&quot;: &quot;小明&quot;&#125;print(f&quot;定义字典后的内存地址 &#123;id(demo_dict)&#125;&quot;)demo_dict[&quot;age&quot;] = 18demo_dict.pop(&quot;name&quot;)demo_dict[&quot;name&quot;] = &quot;老王&quot;print(f&quot;修改数据后的内存地址 &#123;id(demo_dict)&#125;&quot;) 任务四：字典的key是不可变类型知识点：字典的 key 只能使用不可变类型的数据 允许：不可变类型可以作为key 123456789d = &#123;&#125;d[&quot;name&quot;] = &quot;xiaoming&quot;print(d)d[1] = &quot;整数&quot;print(d)d[(1,)] = &quot;元组&quot;print(d) 不允许：可变类型不可以作为key。TypeError:unhashable type错误 12345d[[1,2,3] = &quot;列表&quot;print(d)d[&#123;&quot;n&quot;:&quot;xxx&quot;&#125;] = &quot;字典&quot;print(d) 任务五：认识哈希函数知识点：哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 参数：接收一个不可变类型的数据作为参数 返回：一个整数 哈希 是一种算法，其作用就是提取数据的特征码(指纹) 相同的内容得到相同的结果 不同的内容得到不同的结果 在Python中，设置字典的键值对时，会首先对key进行 hash 来决定如何在内存中保存字典的数据，以便后续对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 允许：不可变类型可以用hash函数生成它的特征码 12h = hash(1)print(h) 12345678910# 传入相同的数据，hash值永远一样h = hash(&quot;hello&quot;)print(h)h = hash(&quot;hello&quot;)print(h)# 数据稍微变化，hash值变化很大h = hash(&quot;hello1&quot;)print(h) 1234# 元组是不可变类型# hash函数生成元组数据特征码h = hash((1,))print(h) 不允许：可变类型不可以用hash函数生成它的特征码 1234# 列表是可变类型# unhashable typeh = hash([1])print(h) 1234# 字典是可变类型# unhashable typeh = hash(&#123;&#125;)print(h) 11.2.6 递归函数任务一：递归函数的定义知识点： 在函数体内部，可以调用其他函数也可以调用自己。将函数调用自身的编程技巧称为递归 递归函数的特点： 函数内部的代码是相同的，只是针对参数不同，处理的结果不同 当参数满足递归终止条件时，函数不再执行。这个非常重要，通常被称为递归的出口，否则会出现死循环 例子：递归函数实现倒计时程序 12345678910def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return # 当不满足终止条件，则进入递归 sum_numbers(num - 1) sum_numbers(3) 实例：递归实现计算数字累加需求分析： 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num的结果 12345678910111213141516171819# 定义一个函数 sum_numbers# 能够接收一个 num 的整数参数# 计算 1 + 2 + ... num 的结果def sum_numbers(num): # 1. 出口 if num == 1: return 1 # 2. 数字的累加 num + (1...num -1) # 假设 sum_numbers 能够正确的处理 1...num - 1 temp = sum_numbers(num - 1) # 两个数字的相加 return num + tempresult = sum_numbers(100)print(result) 提示： 递归是一个编程技巧，初次接触递归会感觉有些吃力 建议先想好递归通项和递归出口条件，然后再编写递归函数 在处理不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 递归可以等价看作是while循环+函数的流程结构 11.2.7 匿名函数lambda11.2.8 eval()函数任务一：eval()函数基本用法知识点：eval()函数十分强大，它将字符串当成有效的表达式来求值 并返回计算结果 123456789101112131415# 基本的数学计算# Out: 2print(eval(&quot;1 + 1&quot;))# 字符串重复# Out: &#x27;**********&#x27;print(eval(&quot;&#x27;*&#x27; * 10&quot;))# 将字符串转换成列表# Out: listprint(type(eval(&quot;[1, 2, 3, 4, 5]&quot;)))# 将字符串转换成字典# Out: dictprint(type(eval(&quot;&#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 18&#125;&quot;))) 任务二：使用eval()函数实现计算器功能需求分析： 提示用户输入一个 加减乘除混合运算 返回计算结果 123input_str = input(&quot;请输入一个算术题：&quot;)print(eval(input_str)) 任务三： eval()函数的危险性危险： 在开发时千万不要使用**eval()**直接转换 input 的结果 用户就可以控制计算机做任何事情 主要的原因是因为用户可以通过eval()函数间接的执行各种终端指令 eval()函数执行终端指令来对计算机进行各种操作 1__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;) 等价代码 12import osos.system(&quot;ls&quot;) 执行成功，返回 0 执行失败，返回错误信息 11.3 局部变量和全局变量11.3.1 局部变量任务一：局部变量和全局变量的基本概念知识点： 局部变量是在函数内部定义的变量，只能在函数内部使用 全局变量是在函数外部定义的变量(没有定义在函数内)，所有函数内部都可以使用这个变量 区别： 局部变量和全局变量的定义位置不一样 局部变量和全局变量的作用域范围不一样 全局变量一般用于在所有函数中共享全局信息。由于作用域范围太大，开发中慎用全局变量。如果全局变量出现错误，那么程序的错误调试将会变得非常复杂 任务二：认识局部变量知识点： 局部变量是在函数内部定义的变量，只能在函数内部使用 作用域范围：函数执行结束后，函数内部的局部变量，会被系统回收 123456789101112131415161718def demo1(): # 局部变量出生：定义局部变量时，才会被创建 num = 10 print(f&quot;在demo1函数内部的变量是&#123;num&#125;&quot;) # 局部变量死亡：函数执行完成之后def demo2(): num = 99 # 此num和demo1相互独立无关 print(f&quot;demo2 ==&gt; &#123;num&#125;&quot;) pass# 在函数内部定义的变量，不能在其他位置使用# print(f&quot;&#123;num&#125;&quot;)demo1()demo2() 局部变量的生命周期(重要)知识点： 所谓生命周期就是变量从被创建到被系统回收的过程。 出生：局部变量在函数执行时才会被创建。定义变量时被创建。 消亡：函数执行结束后局部变量被系统回收。函数return或执行所有代码时，变量消亡。 在生命周期内，局部变量可以用来存储函数内部临时使用到的数据 任务三：不同函数中的局部变量相互不影响知识点： 不同的函数可以定义相同的名字的局部变量，但是彼此之间不会产生影响。 在函数内部使用，局部变量用于临时保存函数内部需要使用的数据 1234567891011121314def demo1(): # 局部变量出生：定义局部变量时，才会被创建 num = 10 print(f&quot;在demo1函数内部的变量是&#123;num&#125;&quot;) # 局部变量死亡：函数执行完成之后def demo2(): # num = 99 # 由于局部变量相互独立，此num和demo1相互独立无关 print(f&quot;demo2 ==&gt; &#123;num&#125;&quot;)demo1()demo2() 11.3.2 全局变量任务一：认识全局变量知识点： 全局变量是在函数外部定义的变量 作用域是整个程序，即所有函数内部都可以使用该变量 12345678910111213141516# 定义一个全局变量num = 10def demo1(): # 函数内部可以使用全局变量num print(f&quot;demo1 ==&gt; &#123;num&#125;&quot;)def demo2(): # 函数内部可以使用全局变量num print(f&quot;demo2 ==&gt; &#123;num&#125;&quot;)demo1()demo2()print(&quot;over&quot;) 任务二：PyCharm单步调试解析全局变量知识点： 使用PyCharm调试功能，查看定义在函数和模块中的变量 注意：一个python源文件或主程序可以看作是一个模块 在模块中，可以定义多个函数和变量 在模块中定义的变量，相对于函数来说是全局变量。换言之，模块中的变量级别和函数是相同的 任务三：函数内部不能直接修改 全局变量的引用知识点： 全局变量：在函数外部定义的变量，与函数同一个级别。因此，所有函数内部都可以使用这个变量 虽然要慎用全局变量，但是它可以在各函数中，共享数据信息。所以，对某些需要共享数据的程序开发，使用全局变量会带来很大的便利，可以减少参数个数 全局变量的只读属性，为了防止修改全局变量而影响其他函数的运行： 在函数中，可以通过全局变量的引用获取对应的数据 但是Python不允许直接修改全局变量的引用 ，即不能通过赋值语句来修改全局变量的值 知识点：在函数中，如果使用赋值语句尝试着来修改全局变量值，会发生什么事情 本质上，Python会定义一个新的和全局变量同名的局部变量 因此，在对该变量赋值，本质上是对同名的局部变量进行修改，并不影响原全局变量的值 12345678910111213141516num = 10def demo1(): print(&quot;demo1&quot; + &quot;-&quot; * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(&quot;demo2&quot; + &quot;-&quot; * 50) print(num)demo1()demo2()print(&quot;over&quot;) 任务四：函数变量查找过程的深度解析知识点：函数执行时，需要处理变量时 会： 首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用。 如果没有，查找函数外部是否存在指定名称 的全局变量，如果有，直接使用。 如果还没有，程序报错 任务五：global 关键字开启全局变量修改权限知识点： 在函数中需要修改全局变量，需要使用 global 关键字来进行声明 通过 global 关键字开启全局变量修改权限 如果修改没有 global 前缀的全局变量，函数会新建一个同名的局部变量 12345678910111213141516171819# 全局变量num = 10def demo1(): # 希望修改全局变量的值 - 使用 global 声明一下变量即可 # global 关键字会告诉解释器后面的变量是一个全局变量 # 再使用赋值语句时，就不会创建局部变量 global num num = 99 print(f&quot;demo1 ==&gt; &#123;num&#125;&quot;)def demo2(): print(f&quot;demo2 ==&gt; &#123;num&#125;&quot;)demo1()demo2() 任务六：全局变量定义的位置知识点： 全局变量可以定义在函数定义之后 全局变量必须要在函数调用之前被定义，否则会引发异常 在Python程序运行中，程序遇到函数定义时会被跳过，而真正的函数代码执行会发生在函数调用 因此，为了保障函数能够正确使用全局变量，建议将全局变量定义在函数定义之前 123456789101112131415161718192021222324# 注意：在开发时，应该把模块中的所有全局变量# 定义在所有函数上方，就可以保证所有的函数# 都能够正常的访问到每一个全局变量了num = 10# 再定义一个全局变量title = &quot;编程爱好者&quot;# 再定义一个全局变量name = &quot;小明&quot;def demo(): print(num) print(title) print(name)# 在函数调用之前定义全局变量，不会异常# title = &quot;编程爱好者&quot;demo()# 由于全局变量，是在调用函数之后，才定义的。# 在执行函数时，变量还没有定义，所以程序会报错！# name = &quot;小明&quot; 常用的代码结构规范如下图。关于shebang或**#!标识，属于Linux的shell**编程，有兴趣可以课外查阅相关资料 任务七：全局变量命名规范知识点：为了避免局部变量和全局变量出现混淆，在定义全局变量时，变量名前应该增加 g_ 或者 gl_ 的前缀 12345678910111213141516171819202122gl_num = 10# 再定义一个全局变量gl_title = &quot;编程爱好者&quot;# 再定义一个全局变量gl_name = &quot;小明&quot;def demo(): # 如果局部变量的名字和全局变量的名字相同 # pycharm会在局部变量下方显示一个灰色的虚线 num = 99 # 这里的num是局部变量 print(num) print(gl_title) print(gl_name)# # 再定义一个全局变量# title = &quot;编程爱好者&quot;demo()","categories":[],"tags":[]},{"title":"Python学习笔记10","slug":"Python学习笔记10","date":"2021-06-16T16:37:58.000Z","updated":"2021-06-16T16:39:37.775Z","comments":true,"path":"2021/06/17/py10.html","link":"","permalink":"http://waxll.top/2021/06/17/py10.html","excerpt":"","text":"第十章 函数：定义与参数10.1 函数的定义10.1.1 为何需要函数？任务一：函数的需求分析函数的需求分析： 代码的组织结构不清晰，可读性差 遇到重复的功能只能重复编写实现相同的代码，冗余度大 对某个功能需要扩展时，需要找出所有实现该功能的程序修改之，无法统一管理，且后期更新难度极大 因此，需要通过某种方式，对需要重复使用的代码进行有组织的打包，便于其他地方使用和统一维护管理。为满足以上需求，在计算机程序中，通过一种称之为函数的编程技术来实现代码复用功能 知识点： 所谓函数，就是把具有独立功能的代码块组织(封装)为一个功能模块中；之后遇到类似的需求，直接使用(调用)，而不再需要重复编写 函数包含两个步骤： 定义函数：将代码块封装为功能独立的代码块 调用函数：站在巨人肩膀上，拿来主义，不需要了解函数具体实现细节，享受封装成果 函数的作用：在开发程序时，使用函数可以提高编写的效率以及代码的重用 函数相关的术语：封装、重用、调用 10.1.2 体验函数功能任务一：体验函数功能目标： 创建一个python源代码(.py)，用于独立管理函数 在主程序中，通过import导入函数，并调用函数 步骤一：在Jupyter中，New-&gt;Text File，新建Python源代码(非notebook源代码)，File-&gt;Rename重命名为multiple99.py，然后将下面的九九乘法表代码复制 1234567891011121314151617181920212223# 定义起始行row = 1# 最大打印 9 行while row &lt;= 9: # 定义起始列 col = 1 # 最大打印 row 列 while col &lt;= row: # end = &quot;&quot;，表示输出结束后，不换行 # &quot;\\t&quot; 可以在控制台输出一个制表符，协助在输出文本时对齐 # f-string方式，相对%输出更简洁 print(f&quot;&#123;col&#125; * &#123;row&#125; = &#123;row * col&#125;&quot;, end=&quot;\\t&quot;) # 列数 + 1 col += 1 # 一行打印完成的换行 print(&quot;&quot;) # 行数 + 1 row += 1 步骤二：根据视频的第3步，将python源代码，定义为一个函数def multiple_table():，然后将上面代码通过缩进方式(选中按Tab键)，转化为函数体语句块。保存Ctrl+S并退出 1234def multiple_table(): # 定义起始行 row = 1 ..... 步骤三：在Jupyter notebook中，添加一个cell，通过import multiple99导入函数模块，并在cell中调用函数，打印输出结果 12import multiplemultiple.multiple_table() 10.1.3 函数的定义任务一：函数的定义函数的定义格式如下： 123def fun_name(): 函数封装的代码 …… def 是英文 define 的缩写。python函数定义关键字 fun_name：函数名称。建议使用有意义的命名，能够明确表达函数封装代码的功能，便于后续调用 函数名之后的括号里用于传递函数的参数。可以为空参数，也可以为通过,分割的多个参数 :，指明后续跟着的是函数体(缩进语句块) 函数命名规则类似于变量的命名： 可以由字母、下划线 和 数字组成 不能以数字开头 不能与关键字重名 下面例子为一个简单的函数定义 123def greet_user(): &quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot; print(&quot;Hello!&quot;) 程序解析： def greet_user():。使用关键字def来定义函数，函数名为greet_user() 紧跟在def greet_user():后面的所有缩进行构成了函数体 第2行注释被称为文档字符串(docstring)，用于描述函数的功能。文档字符串用三引号括起，Python使用它们来生成函数帮助文档 代码行print(“Hello!”)是函数体内的唯一一行代码，greet_user()只做一项工作：打印Hello! 任务二：函数的调用知识点： 定义好函数之后，只表示这个函数封装了一段代码而已如果不主动调用函数，函数是不会主动执行的 调用函数：需要在程序中，通过 fun_name() 即可完成对函数的调用 例如，Jupyter中，新建一个cell，然后添加下面代码，用于调用之前定义的函数 1greet_user() 任务三：函数演练需求分析： 编写一个打招呼 say_hello 的函数，封装三行打招呼的代码 在函数下方调用打招呼的代码 1234567891011121314name = &quot;小明&quot;# 解释器知道这里定义了一个函数def say_hello(): print(&quot;hello 1&quot;) print(&quot;hello 2&quot;) print(&quot;hello 3&quot;)print(name)# 只有在调用函数时，之前定义的函数才会被执行# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码say_hello()print(name) 任务四：函数调用流程分析任务五：函数调用能否放函数定义之前？知识点：函数的定义和调用顺序关系 函数调用是不能放函数定义之前 因为在 使用函数名调用函数之前，必须要保证 Python 已经知道函数的存在 否则控制台会提示 NameError: name ‘say_hello’ is not defined (名称错误：say_hello 这个名字没有被定义) 任务六：函数的文档注释知识点： 函数注释是为了协助开发者(其他人调用函数)能快速掌握函数的调用方式： 函数的功能 函数的参数说明 函数的返回 在开发中，如果希望给函数添加注释，应该在定义函数的下方，使用连续的三对引号。然后在连续的三对引号之间编写对函数的说明文字 在函数调用位置，PyCharm中使用快捷键 CTRL + Q 可以查看函数的说明信息；Jupyter中使用快捷键Shift+Tab 注意：由于函数体相对比较独立，因此在函数定义的上方，应该和其他代码(包括注释)保留两个空行 10.2 函数的参数10.2.1 向函数传递信息：参数任务一：需求分析下面将通过一个两数求和函数，来说明向函数传递参数的必要性 1234567def sum_2_num(): num1 = 10 num2 = 20 result = num1 + num2 print(f&quot;&#123;num1&#125; + &#123;num2&#125; = &#123;result&#125;&quot;) sum_2_num() 思考： 虽然**sum_2_num()**函数实现了两个数的相加，但是该函数功能非常局限 因为两个相加的值num1和num2直接被固定在函数体中 如果能将需要计算的数字，在调用函数时，传递到函数内部就好了 为满足此需求，函数在设计时，可以通过参数向函数传递必要的信息 任务二：向函数传递参数知识点：函数参数语法 在函数名的后面的小括号内部填写函数的参数 多个参数之间使用 , 分隔 例子1：求和计算函数，传递两个参数，需要计算的数 12345def sum_2_num(num1, num2): result = num1 + num2 print(f&quot;&#123;num1&#125; + &#123;num2&#125; = &#123;result&#125;&quot;)sum_2_num(50, 20) 例子2：欢迎语打印函数，传递一个参数，用户名 12345def greet_user(username): &quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot; print(&quot;Hello, &quot; + username.title() + &quot;!&quot;)greet_user(&#x27;jesse&#x27;) 程序分析： 在函数声明时，**def greet_user()的括号内添加username(形参)**，向函数传递参数 在函数调用时，需要外部程序向函数传递具体的值(实参)给username参数 10.2.2 (重要) 实参与形参任务一：参数的作用知识点： 如果把函数比喻成一台机器，那么参数就是原材料，返回值就是最终产品 从一定程度上讲，函数的作用就是根据不同的参数产生不同的返回值 知识点：函数参数，极大的提高了函数的通用性。在函数定义时，对具体的数据使用参数来抽象，那么在设计函数时，只需关注函数本身的业务逻辑和流程处理 在函数定义时，把参数(形参)当做变量使用，重点围绕参数展开函数功能设计和数据计算处理 在函数调用时，向函数传递函数定义时需要的参数，然后通过函数来对这些具体的数据(实参)实现某些功能 任务二：(重要)函数的形参与实参形参： 英语术语：argument 在函数定义中，出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参 在函数内部作为变量使用 占位符，没有实际数据 实参： 英语术语：parameter 在函数调用时，给出的参数包含了实实在在的数据，这些数据将被传递到函数内部使用，所以称为实际参数，简称实参 是用来把数据传递到函数内部用的 实实在在的数据 12345def sum_2_num(num1, num2): result = num1 + num2 print(f&quot;&#123;num1&#125; + &#123;num2&#125; = &#123;result&#125;&quot;)sum_2_num(50, 20) 程序分析： **sum_2_num(num1, num2)**函数实现对两个数的求和计算 形参：在函数定义时，num1和num2在函数体中是个占位符，被称为形参。用于设计函数的逻辑运算：result = num1 + num2 实参：在函数调用时，sum_2_num(50, 20)，将50和20数据通过形参num1和num2传递到函数内部。这里的50和20是真实数据，被称为实参 习题：消息：编写一个名为**display_message()**的函数，它打印一个句子，指出你在本章学的是什么。调用这个函数，确认显示的消息正确无误 1234def display_message(): print(&quot;In the chapter 8, we will learn how to define a function!&quot;)display_message() 1In the chapter 8, we will learn how to define a function! 喜欢的图书：编写一个名为favorite_book()的函数，其中包含一个名为title的形参。这个函数打印一条消息，如One of my favorite books is Alice in Wonderland。调用这个函数，并将一本图书的名称作为实参传递给它 12345def favorite_book(title): &quot;&quot;&quot;favorite books&quot;&quot;&quot; print(&quot;One of my favorite books is &quot; +title.title() +&quot;.&quot;)favorite_book(&quot;No Longer Human&quot;) 1One of my favorite books is No Longer Human. 10.2.3 位置实参知识点：由于函数定义中可能包含多个形参，因此函数调用时也可能包含多个实参。向函数传递实参的方式很多，例如： 位置实参，要求实参的顺序与形参的顺序相同 关键字实参，其中每个实参都由变量名和值组成 将参数使用列表和字典打包传参数 知识迁移：字符串格式化函数**.format()**函数的使用 任务一：位置实参的用法知识点： 调用函数时，Python必须将每个实参一一对应地与形参进行关联，且不能有任何歧义 最简单的关联方式是基于参数的顺序。因此，这种关联方式被称为位置实参 下面通过显示宠物信息函数来理解位置实参的原理 需求： 输入：输入宠物类型和名字 功能：打印特定的宠物信息 123456def describe_pet(animal_type, pet_name): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(&#x27;hamster&#x27;, &#x27;harry&#x27;) 这个函数的定义表明，它需要两个参数：动物类型animal_type和名字pet_name 调用describe_pet(‘hamster’, ‘harry’)时，需要按顺序提供相应的实参 实参**’hamster’存储在形参animal_type中，实参‘harry’存储在形参pet_name**中 在函数体内，对这两个参数进行相关功能处理，打印输出特定的宠物信息 任务二：多次调用函数知识点：多次调用函数时，函数的参数和结果是相互独立的 可根据需要调用函数任意次。要再描述一个宠物，只需再次调用**describe_pet()**即可： 1234567def describe_pet(animal_type, pet_name): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(&#x27;hamster&#x27;, &#x27;harry&#x27;)describe_pet(&#x27;dog&#x27;, &#x27;willie&#x27;) 两次调用函数，分别独立地赋予了不同的实参 第二次调用函数时，传递了实参**’dog’和‘willie’** 与第一次调用时类似，通过位置顺序信息，将实参**’dog’关联到形参animal_type，并将实参‘willie’关联到形参pet_name** 任务三：位置实参的顺序很重要知识点： 使用位置实参来调用函数时，如果实参的顺序不正确，要么程序会崩溃，要么会出现出乎意料的结果 除了某些特殊的函数，本身就可以互换参数，比如求和函数 例如，在调用**describe_pet()**函数时，互换参数，虽然程序也可以输出结果，但是结果变得很荒谬 1describe_pet(&#x27;harry&#x27;, &#x27;hamster&#x27;) # I have a harry. # My harry&#x27;s name is Hamster. 程序分析： 在这个函数调用中，先指定名字，再指定动物类型 由于实参**’harry’在前，这个值将存储到形参animal_type中；同理，‘hamster’将存储到形参pet_name**中 结果得到了一个名为Hamster的harry 10.2.4 关键字实参任务一：关键字实参用法知识点： 关键字实参是传递给函数的名称—值对。(类似字典) 由于在实参中将参数名(key)和值(value)关联起来，所以在传入时无需考虑函数调用中的实参顺序 通过关键字实参还可以清楚地了解函数各参数的意义 例如，print()函数的end参数 关键字实参是传递给函数的名称—值对。下面将通过关键字实参来调用describe_pet()，函数定义与位置实参一样 123456def describe_pet(animal_type, pet_name): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;) 函数describe_pet()还是原来那样，但调用这个函数时，明确地指出了各个实参对应的形参 看到这个函数调用时，解释器将实参**’hamster’和‘harry’分别存储在形参animal_type和pet_name**中 关键字实参的顺序无关紧要，因为解释器知道各个值与哪个形参进行关联。 下面两个函数调用是等效的： 12describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;) 任务二：关键字实参易错点知识点：两个必须 错误1：使用关键字实参时，必须准确无误地指明函数定义的形参名，否则会出错 错误2：如果位置实参和关键字实参混用时，位置实参必须在关键字实参之前 12# 错误的关键字实参describe_pet(animal_type1=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;) 12# 位置实参必须在关键字实参之前describe_pet(pet_name=&#x27;harry&#x27;,&#x27;hamster&#x27;) 10.2.5 默认值实参任务一：默认值实参的用法知识点： 在定义函数时，可给形参指定默认值 在调用函数时，如果为形参指定实参，那么解释器将使用传入的实参；否则，将使用该形参的默认值实参 默认值实参的用法，简化了函数的调用。特别是对于参数非常多的参数，如果使用默认值实参可以极大提升开发效率 例子1：通过Shift+Tab观察**print()函数的定义，该函数共使用了4个默认值实参。如果没有默认值实参，那么高频繁地使用print()**函数将会非常繁琐 例子2：对函数**describe_pet()**使用关键字实参 123456def describe_pet(pet_name, animal_type=&#x27;dog&#x27;): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(pet_name=&#x27;willie&#x27;) 程序解析： 这里修改了函数describe_pet()的定义，在其中给形参animal_type指定了默认值**’dog’** 调用函数时，如果没有给animal_type指定值，Python将把这个形参设置为默认值**’dog’** 知识点： 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用 例子3：对列表排序程序 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 任务二：为函数指定参数的缺省值知识点： 在定义函数时，在形参后使用赋值语句来指定缺省值 缺省参数，需要使用最常见的值作为默认值 如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递 123456def print_info(name, gender=True): gender_text = &quot;男生&quot; if not gender: gender_text = &quot;女生&quot; print(f&quot;&#123;name&#125;是&#123;gender_text&#125;&quot;) 任务三：默认值实参的易错点易错点： 拥有默认值的形参必须放非默认形参之后 SyntaxError: non-default argument follows default argument。语法错误，非默认参数在默认参数之后 注意：形参的英语是argument 1234567# 将默认实参放非默认实参之前，将会导致错误def describe_pet(animal_type=&#x27;dog&#x27;, pet_name): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(pet_name=&#x27;willie&#x27;) 知识点： 缺省参数的定义位置必须保证带有默认值的缺省参数在参数列表末尾 **def print_info(name, gender=True, title):**是错误的缺省值定义方式 知识点： 调用带有多个缺省参数的函数 在调用函数时，如果有多个缺省参数中部分参数需要传递实参，那么必需要使用关键字实参来指定参数名，这样解释器才能够知道参数的对应关系 12345678910111213141516171819def print_info(name, title=&quot;&quot;, gender=True): &quot;&quot;&quot; :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 &quot;&quot;&quot; gender_text = &quot;男生&quot; if not gender: gender_text = &quot;女生&quot; print(f&quot;&#123;title&#125;&#123;name&#125;是&#123;gender_text&#125;&quot;)# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info(&quot;小明&quot;)# 如果为默认值参数传递实参时，必需要使用关键字实参，否则会引起异常print_info(&quot;老王&quot;, title=&quot;班长&quot;)print_info(&quot;小美&quot;, gender=False) 10.2.6 实参调用的等价形式任务一：函数调用时的实参等价形式知识点： 可以混合使用位置实参、关键字实参和默认值实参，通常有多种等效的函数调用方式 注意：如果要使用默认值实参，函数定义的时候必须要有形参赋值为默认值 例子：函数describe_pet()的定义，为形参animal_type提供默认值 1234def describe_pet(pet_name, animal_type=&#x27;dog&#x27;): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;) 函数调用说明： 第一个参数：位置实参和关键字实参。在任何情况下都必须给没有默认值的形参pet_name提供实参 第二个参数：位置实参、关键字实参和默认值实参。如果要指定动物类型，可以对animal_type提供实参 下面对这个函数的所有调用都可行： 123456789101112# 第二个参数为默认值# 第一个参数位置实参describe_pet(&#x27;willie&#x27;)# 第一个参数关键字实参describe_pet(pet_name=&#x27;willie&#x27;)# 第二个参数为非默认值# 位置实参describe_pet(&#x27;harry&#x27;, &#x27;hamster&#x27;)# 关键字实参，可以互换位置describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;) 注意： 使用哪种调用方式无关紧要，只要函数调用能生成你希望的输出就行 使用对你来说最容易理解和最简便的调用方式即可 任务二：常见实参调用错误知识点：实参个数与函数定义的参数不匹配 多于形参个数时，程序肯定会出错 少于形参个数时，程序首先会匹配默认值实参；当不匹配时会出错 例子：如果调用函数**describe_pet()**时没有指定任何实参，结果将如何呢 123456def describe_pet(pet_name, animal_type=&#x27;dog&#x27;): &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot; print(f&quot;I have a &#123;animal_type&#125;.&quot;) print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet() Python发现该函数调用缺少必要的信息，而traceback指出了TypeError: describe_pet() missing 2 required positional arguments。类型错误，该函数缺失2个必须的位置参数 习题：8-3 T恤：编写一个名为**make_shirt()**的函数，它接受一个尺码以及要印到T恤上的字样。这个函数应打印一个句子，概要地说明T恤的尺码和字样。使用位置实参调用这个函数来制作一件T恤；再使用关键字实参来调用这个函数 123456def make_shirt(size,letter_sample): &quot;&quot;&quot;information of size and letter sample&quot;&quot;&quot; print(&quot;\\nThis T-shirt is in size &quot; + size.upper() + &quot;, and please print &quot; + letter_sample.upper() + &quot; on it.&quot;)make_shirt(&quot;S&quot;,&quot;Lakers&quot;)make_shirt(letter_sample= &quot;King&quot;,size=&quot;XL&quot;) 123This T-shirt is in size S, and please print LAKERS on it.This T-shirt is in size XL, and please print KING on it. 8-4 大号T恤：修改函数**make_shirt()**，使其在默认情况下制作一件印有字样“I love Python”的大号T恤。调用这个函数来制作如下T恤：一件印有默认字样的大号T恤、一件印有默认字样的中号T恤和一件印有其他字样的T恤（尺码无关紧要） 1234567def make_shirt(size=&quot;L&quot;,letter_sample=&quot;Lakers&quot;): &quot;&quot;&quot;information of size and letter sample&quot;&quot;&quot; print(&quot;\\nPlease make a T-shirt is in size &quot; + size.upper() + &quot;, and print &quot; + letter_sample + &quot; on it.&quot;)make_shirt()make_shirt(size=&quot;xl&quot;)make_shirt(&quot;m&quot;,&#x27;James&#x27;) 12345Please make a T-shirt is in size L, and print Lakers on it.Please make a T-shirt is in size XL, and print Lakers on it.Please make a T-shirt is in size M, and print James on it. 8-5 城市：编写一个名为describe_city()的函数，它接受一座城市的名字以及该城市所属的国家。这个函数应打印一个简单的句子，如Reykjavik is in Iceland。给用于存储国家的形参指定默认值。为三座不同的城市调用这个函数，且其中至少有一座城市不属于默认国家 123456def describe_city(city,country=&#x27;china&#x27;): print(&quot;\\n&quot; + city.title() + &quot; is in &quot; + country.title() +&quot;.&quot;)describe_city(&quot;shanghai&quot;)describe_city(&quot;hongkong&quot;)describe_city(&quot;Los Angeles&quot;,&quot;America&quot;) 12345Shanghai is in China.Hongkong is in China.Los Angeles is in America. 10.3 进阶函数的参数10.3.1 函数的不可变和可变参数任务一：变量赋值不影响外部变量知识点：函数内部赋值变量不影响外部实参变量 形参也是函数的局部变量 变量赋值修改的是变量的引用，即换个贴标签的内存空间 在函数内部，针对参数使用赋值语句，不影响函数外部传递的实参 无论向函数传递的参数是可变还是不可变类型，在函数体内通过赋值修改该局部变量的引用，不影响外部变量的引用 12345678910111213141516171819def demo(num, num_list): print(&quot;函数内部&quot;) # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(&quot;函数代码完成&quot;) # 整形是不可变类型gl_num = 99# 列表是可变类型gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 任务二：通过方法修改数据会影响到外部变量知识点： 如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据 调用方法并未更改变量的引用，而是直接修改了真实数据的内容 关键点：变量引用(赋值)、实际内存空间(调用修改方法) 1234567891011def demo(num_list): print(&quot;函数内部的代码&quot;) # 使用方法修改列表的内容 num_list.append(9) print(num_list) print(&quot;函数执行完成&quot;)gl_list = [1, 2, 3]demo(gl_list)print(gl_list) 任务三：面试题 +=的使用知识点：列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 123456789def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list) gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 123456789101112131415161718def demo(num, num_list): print(&quot;函数内部代码&quot;) # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(&quot;函数代码完成&quot;)gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 10.3.2 函数传递不确定数量的参数任务一：定义支持多值参数的函数知识点：需求分析 当函数需要接受任意数量的实参，即在函数定义时，并不能确定函数参数数量。为此，Python使用函数的多值参数技术来满足此需求 例如：**print(str1,str2,…)**函数，可以打印数量不定的字符串 知识点：多值参数两种用法 Python函数参数的两种方式：位置实参和关键字实参。那么对应的多值参数方法也有两种： 参数名前增加一个 *** 用于接收元组。对应位置实参** 参数名前增加两个 *** 用于接收字典。对应关键字实参** 一般在给多值参数命名时，习惯使用以下两个名字： args* ：存放元组**参数，前面有一个 ***** *kwargs* ：存放字典**参数，前面有两个 ***** args 是 arguments 的缩写，表示参数的含义 kw 是 keyword 的缩写，kwargs 可以记忆键值对参数 1234567def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name=&quot;小明&quot;, age=18, gender=True) 知识点： 多值参数必须放在非多值(普通)参数之后 Python解释器会先匹配位置实参和关键字实参，然后再将余下的实参都收集到最后个多值参数中 例如，**def demo(*args, num,**kwargs):**将会引起异常 实例：计算任意多个数字的和需求分析： 定义一个函数 sum_numbers，可以接收的任意多个整数 功能要求：将传递的所有数字累加并且返回累加结果 12345678910111213def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)# 拆包语法，简化元组变量/字典变量的传递demo(*gl_nums, **gl_xiaoming) 任务二：元组和字典的拆包知识点： 在调用带有多值参数的函数时，如果希望： 将一个元组变量，直接传递给 args 将一个字典变量，直接传递给kwargs 就可以使用 拆包，简化参数的传递，拆包的方式是： 在元组变量前，增加一个* 在字典变量前，增加两个* 解包或拆包操作： 先将参数用元组或字典打包，然后在函数传递参数时使用解包操作 使函数参数传递变得很简洁 123456789101112def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)demo(*gl_nums, **gl_xiaoming)","categories":[],"tags":[]},{"title":"Python学习笔记9","slug":"Python学习笔记9","date":"2021-06-16T16:36:01.000Z","updated":"2021-06-16T16:37:26.304Z","comments":true,"path":"2021/06/17/py9.html","link":"","permalink":"http://waxll.top/2021/06/17/py9.html","excerpt":"","text":"第九章 不定循环：while循环9.1 （回顾）用户输入与for循环9.1.1 用户输入任务一：用户输入input()函数知识点：接收用户输入 语法：input([prompt]) 描述：程序会一直等待用户输入，直到用户按回车键后继续运行 参数：(可选) prompt为字符串类型，用于提示输入信息 返回：字符串类型 当等待输入时，程序会被中断/阻塞(cell的左边In[*])，直到接收输入后程序才能继续运行 注意：此中断是全局的，即会影响当前整个jupyter程序的其他cell，导致其他cell运行程序时也会出现In[*] input()函数的程序中断测试 首先运行下面的输入程序，不输入，此时程序会阻塞，左边出现In[*] 再运行其他cell的程序程序，会发现其他cell程序也会被中断，左边出现In[*] 然后在**input()**函数的cell中输入数据之后，程序的阻塞会被解除。此时，其他cell的程序也恢复了正常 12# 首先运行这个cell，不输入任何东西a = input(&quot;请输入：&quot;) 12# 然后 运行这个cell，会发现程序被中断print(&#x27;只有在解除中断之后，才能运行该cell&#x27;) 任务二：多次运行带input()的cell知识点： 多次运行带**input()的cell，不接受用户输入，整个jupyter将会卡死，此时input()**输入框也会消失 为此，需要手动重启kernel：Kernel–&gt; Restart 多次运行下面cell，然后通过手动重启kernel来重置Python解释器 12# 首先运行这个cell，不输入任何东西a = input(&quot;请输入：&quot;) 任务三：input()函数的的返回是字符串知识点(回顾)： **input()**函数的返回是字符串类型 如果直接对返回值进行数值运算，会引起异常TypeError 为此，需要对返回值显式地调用类型转换函数，例如：**int()、float()**等 12345a = input(&quot;请输入整形：&quot;)print(type(a), a)b = int(a)print(type(b), b) 任务四：求模运算符(%)知识点： 求模运算符(%)将两个数相除并返回余数 如果一个数可被另一个数整除，余数就为0，因此**%**将返回0 1234print(4 % 3)print(5 % 3)print(6 % 3)print(7 % 3) 奇偶数判断程序。偶数都能被2整除，因此对number和2执行求模运算的结果为零，即number % 2 == 0；否则就是奇数 123456number = int(input(&quot;输入整数：&quot;))if number % 2 == 0: print(f&quot;数字&#123;number&#125;为偶数。&quot;)else: print(f&quot;数字&#123;number&#125;为奇数。&quot;) 习题：7-1 汽车租赁：编写一个程序，询问用户要租赁什么样的汽车，并打印一条消息，如“Let me see if I can find you a Subaru” 123car=&#x27;What kind of car do you need?&#x27;kids=input(car)print(&#x27;let me see if can find you a &#x27;+kids) 1let me see if can find you a Benz 7-2 餐馆订位：编写一个程序，询问用户有多少人用餐。如果超过8人，就打印一条消息，指出没有空桌；否则指出有空桌 1234567inquiry=&#x27;How many people have dinner, please?&#x27;num=input(inquiry) # 3num=int(num)if num&gt;8: print(&#x27;There are no empty tables&#x27;)else: print(&#x27;There is a table available&#x27;) 1There is a table available 7-3 10的整数倍：让用户输入一个数字，并指出这个数字是否是10的整数倍 123456789num=&#x27;plese input one number:&#x27;nums=input(num) # 20nums=int(nums)if nums%10==0: nums=str(nums) print(nums+&#x27; is an integral multiple of ten&#x27;)else: nums = str(nums) print(nums+&#x27; is not inteqral multiple of ten&#x27;) 120 is an integral multiple of ten 9.1.2 程序的三大流程任务一：掌握程序开发的三大流程在程序开发中，一共有三种流程方式： 顺序：从上向下，顺序执行代码 分支：根据条件判断，决定执行代码的分支 循环：让 特定代码块重复 执行 9.1.3 确定循环：for循环任务一：回顾for循环for循环语法： 12for item in &lt;sequence&gt;:&lt;statements&gt; 知识点：回顾请看第4章 描述： for循环用于遍历序列或集合类型对象(列表、元组、字典、字符串等)，在循环体中实现对每个元素执行批量操作 在每次迭代中，循环临时变量item依次获取序列****中的元素 然后，循环体**针对每个item**执行一次 思考：for语句的循环次数是多少？ 任务二：for循环的不足需求分析：编写一个程序，计算用户输入的一系列数的平均值 平均值：数的和除以数的个数 为了让程序通用，它应该适用于任意数量的数 思路： 首先询问用户总共有几个数，通过input()输入一个总数量n 然后使用循环，通过input()接受用户输入的n个数，然后依次对它们进行累积total。 循环结束后对total除以n求平均 算法伪代码： 123456input()输入总共有n个数初始化 total = 0循环 n 次 input()输入数x total += x求均值 average = total / n 根据伪代码，直接转换为Python程序： 123456n = int(input(&quot;共有多个数？&quot;))total = 0.0for i in range(n): x = float(input(&quot;输入数字：&quot;)) total += xprint(&quot;均值为：&quot;, total / n) 缺陷分析： 上述的求平均值程序肯定是有效的，但是它的人机交互存在缺陷 它首先需要询问用户有多少个数字。数字较少时，用户可以数一数输入的数字规模。但如果有很多很多的数需要求平均值，那么把所有的数都数一遍是不太可行的 造成这现象的原因是for循环需要提前明确循环次数。换言之，for循环是有限的确定循环 9.2 不定循环：while循环9.2.1 while循环语法任务一：while循环的流程分析需求分析： 循环的作用就是让指定的代码在满足一定的条件下重复的执行 while 循环最常用的应用场景就是让执行的代码根据指定的条件来重复执行 需求：打印 5 遍 Hello Python 思考：如果要求打印 100 遍怎么办？ while循环的伪代码： 123456789初始条件设置 —— 通常是重复执行的 计数器while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 知识点： while 语句以及缩进部分是一个完整的代码块 while循环通过判断条件来决定循环是否执行，因此它适用于指定次数(for循环擅长做)和不指定次数(for循环不擅长做)的场景 任务二：while循环语法需求分析： for循环是一个有限的确定循环。即定义for循环时，必须确定迭代次数 在for循环求平均数程序中，如果不让用户提前输入总数量，那么程序就无法知道循环迭代次数。这导致程序设计陷入了困境 如何让程序拥有自动计数功能？ while循环语法： 12while &lt;condition&gt;: &lt;statements&gt; 知识点： Python提供了不定循环或条件循环机制——while循环 类似于if语句，while循环使用****布尔表达式来控制循环 只要条件为True，循环体**就会重复执行；当条件为false**时，循环终止 while循环不需明确循环次数，它通过**来控制循环的运行。因此，相对确定循环for语句，它被称为不定循环** 先测试的循环结构： 在while循环体执行之前****条件 如果循环**最初为False，则循环体**就根本不会被执行 该循环结构，循环次数**&gt;=0**次，最少为0次 使用while实现5、4、3、2、1倒计时打印 12345a = 5# a &gt; 0为循环条件while (a &gt; 0): print(a) a -= 1 任务三： while循环实现循环打印打印5遍 Hello Python 12345678910111213# 1. 定义重复次数计数器i = 1# 2. 使用 while 判断条件while i &lt;= 5: # 要重复执行的代码 print(&quot;Hello Python&quot;) # 处理计数器 i i = i + 1# print(&quot;循环结束后的 i = %d&quot; % i)print(&quot;循环结束后的 i = &#123;i&#125;&quot;) # f-string方式 注意：循环结束后，之前定义的计数器变量i是依旧存在的 任务四：赋值运算符知识点： 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的与算术运算符 对应的赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c* *=a 等效于 c=c**a 任务五：Python 中的计数方法常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从0开始计数 因此，在编写程序时，应养成习惯：除非需求的特殊要求，否则循环的计数都从0开始 9.2.2 实例：while循环计算求和任务一：循环实现累加求和需求分析：在程序开发中，通常会遇到利用循环，进行重复计算(比如求和)的需求 通常需要在 while循环之前先定义一个变量，用于存放累积的计算结果 然后，在循环体内部，根据计算结果对该变量进行更新 计算0~100之间所有数字的累计求和结果 123456789101112131415161718# 计算 0 ~ 100 之间所有数字的累计求和结果# 0. 定义最终结果的变量result = 0# 1. 定义一个整数的变量记录循环的次数i = 0# 2. 开始循环while i &lt;= 100: print(i) # 每一次循环，都让 result 这个变量和 i 这个计数器相加 result += i # 处理计数器 i += 1print(f&quot;0~100之间的数字求和结果 = &#123;result&#125;&quot;) 任务二：循环实现偶数累加求和计算0~100之间所有偶数的累计求和结果。在之前的程序基础上，添加奇偶判断 123456789101112131415161718# 0. 最终结果result = 0# 1. 计数器i = 0# 2. 开始循环while i &lt;= 100: # 判断偶数 if i % 2 == 0: print(i) result += i # 处理计数器 i += 1print(f&quot;0~100之间的数字求和结果 = &#123;result&#125;&quot;) 9.2.3 循环变量知识点(术语)：循环变量 while循环需要通过一个额外的循环变量来控制循环流程 通过循环变量来检验****是否满足 在循环体中，需要对循环变量进行更新 任务一：认识循环变量下面是一个简单的while循环，按步长为2，从1数到9 123456#循环变量为aa = 1while a &lt; 10: print(a) # 朝循环终止条件更新a a += 2 将a称为循环变量，用来控制循环 在第1行，将循环变量a设置为1，从而指定从1开始数 接下来的while循环被设置成这样：只要a &lt; 10，就执行循环体 循环体中打印print(a)的值，再更新循环变量a += 2(a = a + 2的简写) 只要满足条件a &lt; 10，就继续循环。下图对while循环每步运行进行可视化 上面while代码的输出与下面的for循环等价 12for a in range(1,10,2): print(a) 程序解析： while循环要求在循环之前负责初始化a，并在循环体的底部让a增加，不需要指定循环迭代次数 在for循环中，循环临时变量a是自动处理的，迭代次数由**range()**生成的序列来决定 知识点：循环变量可以是显式的定义变量，也可以是隐式的，例如列表的长度等 12345678910111213141516numbers = [12, 37, 5, 42, 8, 3]even = []odd = []# 将列表长度作为循环变量while len(numbers) &gt; 0: #通过pop()将numbers尾部元素弹出 # 本质上朝条件更新循环变量的 number = numbers.pop() # 奇偶判断 if (number%2==0): even.append(number) else: odd.append(number) print(even)print(odd) 9.2.4 无限循环任务一：while循环容易导致死循环知识点：由于程序员的原因，忘记在循环内部修改循环的判断条件，导致循环持续执行(无限循环)，程序无法终止！ 知识点：不恰当的使用循环变量容易导致无限循环 由于while循环的终止条件是通过来控制的，使得while循环功能强大，它可以处理非序列或集合类型的循环 while循环每次通过循环变量a来判断是否满足 在循环体中，如果不恰当或忘记更新循环变量a，将会造成程序无限循环，cell一直*In[]**状态 1234# 忘记更新a导致无限循环a = 1while a &lt; 10: print(a) 程序解析： 当Python到达while循环时，a是1，小于10，所以循环体执行，打印1 现在控制变量a返回到条件，a仍是1，所以循环体再次执行，打印1 现在控制返回到条件，a仍是0，所以循环体再次执行，打印1…… (死循环) 12345# 不恰当更新a导致无限循环a = 1while a &lt; 10: print(a) a -= 2 程序解析： 当Python到达while循环时，a是1，小于10，所以循环体执行，打印1 现在控制变量a返回到条件，a是-1，所以循环体再次执行，打印-1 现在控制返回到条件，a是-3，所以循环体再次执行，打印-3…… (死循环) 知识点： 作为初学者，很容易一不小心会写出无限循环程序，这是通往高手的必经之路 如果出现无限循环，要检查循环变量的更新是否是朝终止条件的 换言之，循环变量的更新是否收敛于循环控制条件 出现无限循环是，Jupyter通过Kernel–&gt;Interrupt进行重置 9.3 常见循环模式9.3.1 交互式循环任务一：交互式循环知识点： 不定循环while可以实现程序与用户的交互式循环 所谓的交互式循环，就是在while循环期间，程序通过不断询问用户，来决定是否继续循环 下面将通过数字平均值求解来分析交互式循环的机制 需求分析： 回忆，该程序之前需要强制用户提前输入一个需要参与运算数字的总数 为此，希望while循环能自动记录这个数。定义变量count来实现计数功能，初识从0开始，每次循环增加1 交互式循环：为了允许用户可以控制循环是否结束，在每次迭代过程中，程序都将交互式地询问用户是否还有数据要处理 交互式循环的通用算法流程描述如下，其中moredata为循环循环变量 12345设置 moredata 为 &quot;yes&quot;while (moredata 是否 &quot;yes&quot;) 获得 the next data item 处理 the item 询问用户是否有还有数据要处理，来控制moredata 将交互式循环与计数器count相结合，得到这个平均值程序算法的伪代码： 123456789初始 total to 0.0初始 count to 0设置 moredata to &quot;yes&quot;while moredata is &quot;yes&quot; input a number, x total +&#x3D; x count +&#x3D; 1 ask user if there is moredata输出 total &#x2F; count 根据上面的伪代码，转换为Python程序： 12345678910total = 0.0count = 0moredata = &quot;yes&quot;while moredata[0] == &quot;y&quot;: x = float(input(&quot;输入数字：&quot;)) total += x count += 1 moredata = input(&quot;是否有额外数字需要处理 (yes or no)? &quot;)print(&quot;\\n平均数为：&quot;, total / count) 程序解析： 使用total变量来累加求和；使用count变量来统计用户输入数据的数量 使用moredata来控制循环，while循环判断条件**moredata[0] == “y”为用户输入的字符串第一个字母是否为“y”。例如，“y”、”yes”、”yeah”等。对于非“y”**开始的字符串，则终止循环 缺陷：在这个版本中，虽然用户不必对数据量提前进行计数，但是人机交互不太友好，很繁琐，程序要不断地询问用户是否有输入 9.3.2 哨兵式循环（重要）需求分析： 上面程序虽然实现了while循环能自动提供计数功能，但它在每次迭代中询问用户是否有数据输入，人机交互非常繁琐 如果程序能根据输入的数据本身特点来控制循环是否继续，就可以避免显式地询问用户的步骤，这种模式称为哨兵式循环 任务一：哨兵式循环知识点： 哨兵式循环：循环体中，不断接收新数据，直到用户输入某些特殊值，表明迭代结束。例如，程序需要输入**&gt;=0的整数，根据数据特点，如果用户输入&lt;0**的数，就可以将它作为循环终止条件 哨兵(sentinel)：可以选择任何数据值作为哨兵，唯一的限制是能与实际数据值区分开来。例如，正常数据为**&gt;=0的整数，那么&lt;0**的数就可以作为哨兵。 哨兵式循环的通用算法流程描述如下 1234输入 the first itemwhile (item 是否为 哨兵) 处理 the item 输入 the next item 说明： 在循环开始之前要求用户输入第一项数据item，称为“启动输入” 如果第一项是哨兵，while循环将立即终止。否则，进入循环体，处理该项数据item，并读取下一项 在下次循环开始前，while的循环条件会判断上次输入的item是否为哨兵，来控制循环是否继续被执行。如果遇到哨兵，循环终止 启动输入和循环体内的输入是一样的，都是用于接受新数据 将哨兵式循环用于数字平均值计算问题。首先要选择哨兵，即循环终止条件。假设数据是来源于期末考试成绩，通常成绩都是**&gt;=0的。因此，可以选用&lt;0**作为哨兵。具体Python程序如下： 1234567891011total = 0.0count = 0x = float(input(&quot;输入数字(负数退出循环)：&quot;))# x&lt;0 作为哨兵while x &gt;= 0: total = total + x count = count + 1 x = float(input(&quot;输入数字(负数退出循环)：&quot;))print(&quot;平均值：&quot;, total / count) 程序解析： 相比于交互式循环，哨兵式循环的用户交互简单易用，省去了一直输入yes的麻烦 x = float(input(“输入数字(负数退出循环):”))：while循环体外的启动输入和循环体内的输入是一样的，都是用于接受新数据。哨兵式循环需要在while循环外，提前接受一项数据 while x &gt;= 0，此时哨兵为x&lt;0，即循环结束条件 缺陷：该程序不能用于对一组既包含负值又包含正值的数字求平均值 任务二：扩大哨兵范围需求分析： 为了使得问题能处理任何范围的数值输入，需要拥有一个真正独特的哨兵 首先可以将用户的输入作为字符串来获取，并定义一个特殊的非数字字符串(比如空字符串**””，“Q”或“q”**)，作为循环结束标识(哨兵) 其他的数值类型输入都将被转换为数字，用于计算 一个空字符串在Python中被表示为**””(不含空格)。如果用户输入空白行(只需输入)，Python将返回一个空字符串。可以使用“”**作为哨兵，来改进平均数计算程序。Python程序如下： 1234567891011total = 0.0count = 0xStr = input(&quot;输入数字(&lt;Enter&gt;退出循环)：&quot;)# 哨兵为 空字符串while xStr != &quot;&quot;: x = float(xStr) total = total + x count = count + 1 xStr = input(&quot;输入数字(&lt;Enter&gt;退出循环)：&quot;)print(&quot;平均值：&quot;, total / count) 这段代码检查并确保输入不是哨兵**””后，然后将输入转换成浮点数float**用于均值计算 9.3.3 使用Flag来控制循环（重要）任务一：掌握为何需要使用Flag需求分析： while循环的执行依赖于循环条件 之前，影响循环条件的都只有1个变量。然而，某些循环场景往往又会受到多个变量的同时影响，即有多个变量会影响循环的终止。例如，游戏程序中，游戏失败往往会有多个触发条件 如果while循环在一条语句中同时检测所有条件，将会导致程序变得非常复杂 本质上，就是有多个哨兵时，程序如何来控制循环条件 知识点：循环控制标志(Flag) 为了解决上述问题，可以定义一个bool类型的变量Flag作为循环控制标志，用于监测(判断)循环是否处于活跃状态 它充当了程序的信号灯作用，如果Flag为True，说明程序是活跃状态，可以继续执行循环；如果是False，那么有循环终止事件被触发了，它将终止循环 多个循环影响因素(哨兵)可以通过Flag间接的来控制循环的执行 在while循环条件中，只需要检查Flag是否为True。而触发Flag值为False的事件(哨兵)可以放在循环体的其他地方。从而使得程序整个逻辑变得更清晰 下面的程序，将上节的平均值计算程序添加一个Flag变量，来控制while循环 123456789101112131415161718192021222324total = 0.0count = 0Flag = True# 哨兵为 空字符串while Flag: xStr = input(&quot;输入数字(&lt;Enter&gt;退出循环)：&quot;) # 哨兵1：输入不为空 if (xStr == &#x27;&#x27;): Flag = False else: x = float(xStr) total += x count += 1 # 哨兵2：总数不超过9 if count &gt; 9: Flag = Falseif (count != 0): print(&quot;平均值：&quot;, total / count)else: print(&quot;没输入任何数！&quot;) 程序解析： 定义一个Flag变量，使用它来作为while循环的控制条件 Flag变量的初始值为True；并在循环体中，有2个哨兵 第1个哨兵xStr == ‘’来触发Flag为False；第2个哨兵count &gt; 9来触发Flag为False 任务二：Flag和哨兵的关系知识点：使用Flag来控制while循环，本质上，就是根据if语句来检测哨兵，然后触发Flag变量为False 下面这个程序为消息回音，即计算机会将用户输入的字符串，原封不动的输出。这里使用**’quit’**作为哨兵 12345678910prompt = &quot;输入&#x27;quit&#x27;结束程序&quot;Flag = Truewhile Flag: message = input(prompt) if message == &#x27;quit&#x27;: Flag = False else: print(message) 程序解析： 将变量Flag设置成了True，让程序最初处于活动状态 在while循环中，在用户输入后使用一条if语句来检查变量message的值 如果用户输入的是**’quit’，就将变量Flag设置为False，这将导致while**循环不再继续执行 如果用户输入的不是**’quit’**，就将输入作为一条消息打印出来 9.3.4 break和continue控制循环流程任务一：控制循环流程知识点：break 和 continue 是专门用于循环流程中断控制的关键字 break：退出循环，不再执行循环的后续代码 continue：不执行本次循环的后续代码，并执行下一轮循环 嵌套循环时，break 和 continue 只针对当前所在循环有效 任务二：break退出循环在循环过程中，如果某一个条件满足后，不再希望循环继续执行，可以使用 break退出循环。break 只针对当前所在循环有效 1234567891011121314i = 0while i &lt; 10: # break 某一条件满足时，退出循环，不再执行后续重复的代码 # i == 3 if i == 3: break print(i) i += 1print(&quot;over&quot;) 知识点： 在循环中，可以使用break语句强制彻底地退出循环，不管循环条件是否满足 如果使用break语句，即使while条件为True，也随时停止循环 break语句也适用于for循环，来退出遍历 下面程序让用户输入一系列去过的城市，并在输入**’quit’后使用break语句立即退出while**循环 12345678910prompt = &quot;输入喜欢的城市，并以&#x27;quit&#x27;结束程序&quot;# 设置条件为永Truewhile True: message = input(prompt) if message == &#x27;quit&#x27;: break else: print(&quot;I&#x27;d love to go to &quot; + city.title() + &quot;!&quot;) 程序解析： while条件设置为永真，即如果没有break语句，程序将会无止境的运行 循环体中，要求用户不断输入去过的城市名字，直到输入**’quit’**为止 当用户输入**’quit’后，将执行break**语句来退出循环 任务三：continue跳过该次循环在循环过程中，如果某一个条件满足后，不希望执行循环代码，但是又不希望退出循环，可以使用 continue 知识点：相对于break语句彻底退出循环，continue语句近跳过该次循环，不执行该语句之后的语句，重新返回到循环开头 123456789101112131415i = 0while i &lt; 10: # 当 i == 7 时，不希望执行需要重复执行的代码 if i == 7: # 在使用 continue 之前，同样应该修改计数器 # 否则会出现死循环 i += 1 continue # 重复执行的代码 print(i) i += 1 使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环 下面例子中，通过continue语句实现，在循环体中只打印从1到10的奇数 1234567current_number = 0while current_number &lt; 10: current_number += 1 if current_number % 2 == 0: continue print(current_number) 程序解析： 首先将current_number设置成了0，由于它小于10，Python进入while循环 进入循环后，我们以步长1的方式往上数，因此current_number为1 接下来，if语句检查current_number与2的求模运算结果 如果结果为0(意味着current_number可被2整除)，就执行continue语句，让Python忽略余下的代码，并返回到循环的开头。如果当前的数字不能被2整除，就执行循环中余下的代码，Python将这个数字打印出来 习题：7-4 比萨配料：编写一个循环，提示用户输入一系列的比萨配料，并在用户输入**’quit’**时结束循环。每当用户输入一种配料后，都打印一条消息，说我们会在比萨中添加这种配料 1234567shuru = &quot;请输入你需要添加的pizza配料：&quot;shuru +=&quot;\\n当你输入quit，将停止添加配料：&quot;pizzas = &quot;&quot;while pizzas != &#x27;quit&#x27;: pizzas = input(shuru) if pizzas != &#x27;quit&#x27;: print(&quot;你的比萨添加&quot;+pizzas+&quot;成功\\n&quot;) 12345你的比萨添加牛肉成功你的比萨添加羊肉成功你的比萨添加猪肉成功 7-5 电影票：有家电影院根据观众的年龄收取不同的票价：不到3岁的观众免费；3~12岁的观众为10美元；超过12岁的观众为15美元。请编写一个循环，在其中询问用户的年龄，并指出其票价 12345678while True: age = int(input(&quot;请输入用户年龄:&quot;)) # 5 if age &lt; 3: print(&quot;该用户免费&quot;) elif 3 &lt;= age &lt; 12: print(&quot;该年龄段用户收费的是10美元&quot;) else: print(&quot;该年龄段用户收费的是15美元&quot;) 1该年龄段用户收费的是10美元 7-6 三个出口：以另一种方式完成练习7-4或练习7-5，在程序中采取如下所有做法 在while循环中使用条件测试来结束循环 使用变量active来控制循环结束的时机 使用break语句在用户输入**’quit’**时退出循环 1234567891011active = input(&quot;请输入你的年龄:&quot;)while True: age = int(input(&quot;请输入用户年龄:&quot;)) if age &lt; 3: print(&quot;该用户免费&quot;) elif 3 &lt;= age &lt; 12: print(&quot;该年龄段用户收费的是10美元&quot;) else: print(&quot;该年龄段用户收费的是15美元&quot;) if active == &quot;quit&quot;: break 7-7 无限循环：编写一个没完没了的循环，并运行它，并Jupyter通过Kernel–&gt; Interrupt进行重置 1234a = 1while a &gt;0: a += 1 print(a) 9.4 嵌套循环9.4.1 while循环嵌套流程分析while 嵌套就是：while 里面还有 while 123456789101112131415while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 9.4.2 实例：九九乘法表任务一：打印小星星在控制台连续输出五行 *****，每一行星号的数量依次递增： 12345*************** 知识点： 字符串的乘法，表示复制字符串内容 例如，**”“ * 2*，表示复制字符`”*”**两次 使用字符串 ***** 打印 12345# 1. 定义一个计数器变量，从数字1开始，循环会比较方便row = 1while row &lt;= 5: print(&quot;*&quot; * row) row += 1 任务二：print 函数的end=””参数知识点(回顾)： 在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行 如果不希望末尾增加换行，可以通过print 函数的**end=””**关键字参数指定结束字符 end=”@”：print 函数输出的尾部添加**@**字符 end=”” ：print 函数输出的尾部不添加任何字符，也不再换行了。 语法格式如下： 1234# 向控制台输出内容结束之后，不会换行print(&quot;*&quot;, end=&quot;&quot;)# 单纯的换行print(&quot;&quot;) 任务三：使用循环嵌套打印小星星假设Python 没有提供字符串的 ***** 复制操作运算，需要通过嵌套while循环来实现该功能，来实现连续输出五行 *****，每一行星号的数量依次递增 12345*************** 思路分析： 完成 5 行内容的简单输出 分析每行内部的 ***** 应该如何处理？ 每行显示的星星和当前所在的行数是一致的 嵌套一个小的循环，专门处理每一行中列的星星显示 1234567891011row = 1while row &lt;= 5: # 假设 python 没有提供字符串 * 操作 # 在循环内部，再增加一个循环，实现每一行的 星星 打印 col = 1 while col &lt;= row: print(&quot;*&quot;, end=&quot;&quot;) col += 1 # 每一行星号输出完成后，再增加一个换行 print(&quot;&quot;) row += 1 任务四：嵌套打印九九乘法表输出九九乘法表，格式如下： 123451 * 1 = 11 * 2 = 22 * 2 = 41 * 3 = 32 * 3 = 63 * 3 = 91 * 4 = 42 * 4 = 83 * 4 = 12 4 * 4 = 16 ... 步骤一：打印 9 行小星星 123456789********************************************* 步骤二：将每一个 ***** 替换成对应的行与列相乘 12345678910111213141516171819# 定义起始行row = 1# 最大打印 9 行while row &lt;= 9: # 定义起始列 col = 1 # 最大打印 row 列 while col &lt;= row: # end = &quot;&quot;，表示输出结束后，不换行 # &quot;\\t&quot; 可以在控制台输出一个制表符，协助在输出文本时对齐 # print(&quot;%d * %d = %d&quot; % (col, row, row * col), end=&quot;\\t&quot;) # f-string方式，相对%输出更简洁 print(f&quot;&#123;col&#125; * &#123;row&#125; = &#123;row * col&#125;&quot;, end=&quot;\\t&quot;) # 列数 + 1 col += 1 # 一行打印完成的换行 print(&quot;&quot;) # 行数 + 1 row += 1 任务五：字符串中的转义字符(回顾)\\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐。制表符的功能是在不使用表格的情况下在垂直方向按列对齐文本 \\n 在控制台输出一个 换行符 转义字符 描述 \\ 反斜杠符号 &#39; 单引号 &quot; 双引号 \\n 换行 \\t 横向制表符 \\r 回车 9.4.3 实例：进阶平均数计算任务一：数据生成创建一个数据文件，共100行，每行为10~20个随机数，以数字之间**,**为间隔 1234567891011121314151617181920import random as rd# 例如：Data.txtname = input(&#x27;请输入文件名: &#x27;)f = open(name, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;)for i in range(100): # 每行元素个数为10~20个 s = rd.randint(10, 20) for j in range(s): # 随机生成[-10,10]区间的整数 num = rd.randint(-10, 10) # 将num转换为字符串，并用&#x27;,&#x27;拼接，写入文件中 # 最后一个元素(j=s-1)，添加换行符&#x27;\\n&#x27; if j &lt; s - 1: f.write(str(num) + &#x27;,&#x27;) else: f.write(str(num) + &#x27;\\n&#x27;)print(f&#x27;生成结束，请打开&#123;name&#125;查看结果&#x27;)f.close() 任务二：字符串拆分知识点： 语法：str.split(str=””) 描述：通过指定分隔符str对字符串进行切分 参数：str为分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等 返回：返回分割后的字符串列表 123str = &quot;Line1-abcdef \\nLine2-abc \\nLine4-abcd&quot;# 以空格为分隔符，包含 \\nprint(str.split()); 123txt = &quot;Google#Runoob#Taobao#Facebook&quot;#以#为分隔符print(txt.split(&quot;#&quot;)) 任务三：嵌套式循环求平均值算法分析： 外层循环使用哨兵式循环while循环，for循环会更简单 外层循环：在循环体中，通过readline()按行读取文件。以‘’作为while循环哨兵 内层循环：对每行的字符串使用split()方法进行拆分字符串，返回的是一个子列表，再嵌套for循环，对子列表元素进行计算 123456789101112131415161718# 输入之前生成数字的文件：Data.txtfileName = input(&quot;输入文件名: &quot;)infile = open(fileName,&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)total = 0.0count = 0# 从文件中先读一行line = infile.readline()# 将line为空作为哨兵，即读到文件末尾while line != &quot;&quot;: for num in line.split(&quot;,&quot;): total += float(num) count += 1 line = infile.readline()print(&quot;平均值为：&quot;, total / count) 嵌套循环的设计准则： 首先设计外层，不考虑内层的内容 然后设计内层，忽略外层循环 最后放在一起，注意保留嵌套循环变量间的耦合性。如果单个循环是正确的，则嵌套的结果就会正常工作，要相信这一点 通过一点练习，将轻松掌握双重甚至三重嵌套循环 9.5 使用while循环来处理列表和字典任务一：for循环和while循环的不同定位知识点： 只读模式：for循环的目的是通过遍历列表(序列或容器)的每个元素，对它们执行相同的批量化操作。循环体中，对临时变量进行修改，并不会影响原列表元素内容。因此，for循环是一种只读模式 可写模式：如果需要在迭代列表的同时，对元素进行修改，建议使用while循环 任务二：在列表间移动元素假设有一个列表，其中包含新注册但还未验证的网站用户；验证这些用户后，如何将他们移到另一个已验证用户列表中呢？ 使用while循环可以有效的满足上述的需求。在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中 1234567891011121314151617# 首先，创建一个待验证用户列表# 和一个用于存储已验证用户的空列表unconfirmed_users = [&#x27;alice&#x27;, &#x27;brian&#x27;, &#x27;candace&#x27;]confirmed_users = []# 验证每个用户，直到没有未验证用户为止# 将每个经过验证的列表都移到已验证用户列表中while unconfirmed_users: current_user = unconfirmed_users.pop() print(&quot;待验证用户: &quot; + current_user.title()) confirmed_users.append(current_user)# 显示所有已验证的用户print(&quot;已验证用户:&quot;)for confirmed_user in confirmed_users: print(confirmed_user.title()) 程序解析： 首先创建了一个未验证用户列表，其中包含用户Alice、Brian和Candace，还创建了一个空列表，用于存储已验证的用户 然后，while循环将不断地运行，直到列表unconfirmed_users变成空的。 在这个循环中，函数pop()以每次一个的方式从列表unconfirmed_users末尾删除未验证的用户 由于Candace位于列表unconfirmed_users末尾，因此其名字将首先被删除、存储到变量current_user中并加入到列表confirmed_users中。接下来是Brian，然后是Alice 为模拟用户验证过程，打印一条验证消息并将用户加入到已验证用户列表中。未验证用户列表会越来越短，而已验证用户列表越来越长。未验证用户列表为空后结束循环，最后打印已验证用户列表 任务三：删除包含特定值的所有列表元素remove()方法在删除列表特定值时，只能删除列表中，首次出现的元素值。那么如何删除列表中所有等于特定值的元素呢？ 假设有一个宠物列表，其中包含多个值为**’cat’的元素。要删除所有‘cat’元素，可以使用while循环，通过in表达式检测列表是否包含‘cat’**来作为循环条件 1234567pets = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;]print(pets)while &#x27;cat&#x27; in pets: pets.remove(&#x27;cat&#x27;)print(pets) 程序解析： 首先创建了一个列表，其中包含多个值为**’cat’**的元素 打印这个列表后，Python进入while循环，因为它发现**’cat’**在列表中至少出现了一次 进入这个循环后，Python删除第一个**’cat’并返回到while代码行，然后发现‘cat’**还包含在列表中，因此再次进入循环 它不断删除**’cat’**，直到这个值不再包含在列表中，然后退出循环并再次打印列表 任务四：接收用户输入来填充字典下面来创建一个调查程序，定义responses字典用于存相关问卷信息。核心程序使用带Flag标志变量的while循环。在循环体中，接收用户的问卷信息(用户名和问卷回答)，并保存到字典中responses[name] = response 12345678910111213141516171819202122responses = &#123;&#125;# 设置一个Flag标志，指出调查是否继续Flag = Truewhile Flag: # 提示输入被调查者的名字和回答 name = input(&quot;\\nWhat is your name? &quot;) response = input(&quot;Which mountain would you like to climb someday? &quot;) # 将答卷存储在字典中 responses[name] = response # repeat为循环的哨兵 repeat = input(&quot;Would you like to let another person respond? (yes/ no) &quot;) if repeat == &#x27;no&#x27;: Flag = False# 调查结束，显示结果print(&quot;\\n--- Poll Results ---&quot;)for name, response in responses.items(): print(name + &quot; would like to climb &quot; + response + &quot;.&quot;) 习题：7-8 熟食店：创建一个名为sandwich_orders的列表，在其中包含各种三明治的名字；再创建一个名为finished_sandwiches的空列表。遍历列表sandwich_orders，对于其中的每种三明治，都打印一条消息，如I made your tuna sandwich，并将其移到列表finished_sandwiches。所有三明治都制作好后，打印一条消息，将这些三明治列出来 123456789sandwich_orders=[&#x27;Tuna sandwich&#x27;,&#x27;Ham cheese sandwich&#x27;,&#x27;Chicken sandwich&#x27;]finished_sandwiches=[]while sandwich_orders: current_orders=sandwich_orders.pop() print(&quot;I made your &quot;+current_orders.title()+&quot;.&quot;) finished_sandwiches.append(current_orders)print(&quot;\\nAll the sandwiches have been finished.&quot;)for finished_sandwiche in finished_sandwiches: print(finished_sandwiche.title()) 12345678I made your Chicken Sandwich.I made your Ham Cheese Sandwich.I made your Tuna Sandwich.All the sandwiches have been finished.Chicken SandwichHam Cheese SandwichTuna Sandwich 7-9 五香烟熏牛肉（pastrami）卖完了：使用为完成练习7-8而创建的列表sandwich_orders，并确保**’pastrami’在其中至少出现了三次。在程序开头附近添加这样的代码：打印一条消息，指出熟食店的五香烟熏牛肉卖完了；再使用一个while循环将列表sandwich_orders中的‘pastrami’都删除。确认最终的列表finished_sandwiches中不包含‘pastrami’** 123456sandwich_orders = [&quot;a&quot;, &quot;b&quot;, &quot;pastrami&quot;, &quot;c&quot;, &quot;pastrami&quot;, &quot;d&quot;, &quot;pastrami&quot;]print(&quot;五香熏牛肉卖完啦&quot;)while &quot;pastrami&quot; in sandwich_orders: sandwich_orders.remove(&quot;pastrami&quot;)for i in sandwich_orders: print(i) 12345五香熏牛肉卖完啦abcd 9.6 习题 猜数字游戏： 系统随机生成一个1～100的数字； 用户共有6次机会猜； 如果用户猜测数字大于系统给出的数字，打印”big”。 如果用户猜测数字小于系统给出的数字，打印”small”。 如果用户猜测的数字等于系统给出的数字，打印”恭喜中奖”，并退出循环 123456789101112131415161718import randomx = random.randint(1,100)print(x)trycount = 0while trycount &lt; 6: tk = int(input(&#x27;请输入你猜测的数字:&#x27;)) if tk == x: print(&#x27;恭喜中奖&#x27;) break elif tk &lt; x: print(&#x27;too small&#x27;) trycount += 1 else: print(&#x27;too big&#x27;) trycount += 1else: print(&#x27;机会已经用完&#x27;) 制造星星，根据用户的输入星星行数，分奇数和偶数情况讨论。 对于偶数，比如输出10行内容，第1行一个星号，第2行2个星号，第5行5个星号和第6行5个星号，第7行4个星号，以此类推第10行1个星号。 对于奇数，比如输出9行内容，第1行一个星号，第2行2个星号，第5行5个星号，第6行4个星号，以此类推第9行1个星号 123456n = int(input(&#x27;num:&#x27;))for i in range(1,2*n,2): print((&#x27;*&#x27; * i).center(3 * n))s = range(1,2*(n-1),2)for i in s[::-1]: print((&#x27;*&#x27; * i).center(3 * n)) 计算从1到1000以内所有能同时被3，5和7整除的数的和并输出 123456list=[]for i in range(1,1001): if i%3==0 and i%5==0 and i%7==0: list.append(i) a=sum(list)print(a) 14725 计算从1到100临近两个整数的合并依次输出。比如第一次输出3(1+2)，第二次输出5(2+3)，最后一次输出199(99+100) 123456s=[]for i in range(1,101): if i&gt;=2: a=i-1+i s.append(a)print(s) 1[3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199] 一球从100米高度自由落下，每次落地后反跳回原高度的一半，再落下。求它在第n次落地时，共经过多少米？ 123456789101112n = input() # 5far = []high = 100for i in range(1, int(n)): if i == 1: far.append(high) else: far.append(high * 2) high = high / 2print(f&#x27;经过的总距离：far = &#123;sum(far)&#125;&#x27;)print(f&#x27;第n次反弹多高：high = &#123;high&#125;&#x27;) 12经过的总距离：far = 275.0第n次反弹多高：high = 6.25 输出所有的三位水仙花数，其各位数字立方和等于该数本身 123456for num in range(100, 1000): x = num // 100 y = num // 10 % 10 z = num % 10 if x ** 3 + y ** 3 + z ** 3 == num: print(str(num) + &quot;是水仙花&quot;) 1234153是水仙花370是水仙花371是水仙花407是水仙花 石头剪刀布，使用while死循环，用户不停输入“石头剪刀布”与计算机对弈，直到quit退出。 计算机随机生成石头剪刀布。提示，随机生成1~3的整数，来代替 石头：rock；剪刀：scissors；布：paper。 用户从外部输入对应的字符串，计算机判断，并给结果 12345678910111213141516import randomwhile True: print(&quot;---石头剪刀布游戏开始---&quot;) print(&quot;请按下面提示出拳：石头[1]剪刀[2]布[3]退出[4]&quot;) user=int(input(&quot;请输入你的选项：&quot;)) if user==4: print(&quot;游戏退出&quot;) break computer=random.randint(1,3) if ((computer==1 and user==3) or (computer==2 and user==1) or (computer==3 and user==2)): print(&quot;玩家出拳为&#123;&#125;，电脑出拳为&#123;&#125;，玩家胜利&quot;.format(user,computer)) elif computer==user: print(&quot;玩家出拳为&#123;&#125;，电脑出拳为&#123;&#125;，平局&quot;.format(user,computer)) else: print(&quot;玩家出拳为&#123;&#125;，电脑出拳为&#123;&#125;，电脑胜利&quot;.format(user,computer))print(&quot;游戏结束&quot;)","categories":[],"tags":[]},{"title":"Python学习笔记8","slug":"Python学习笔记8","date":"2021-06-16T16:33:41.000Z","updated":"2021-06-16T16:34:48.039Z","comments":true,"path":"2021/06/17/py8.html","link":"","permalink":"http://waxll.top/2021/06/17/py8.html","excerpt":"","text":"第八章 数据类型：dict字典8.1 初识字典8.1.1 为何需要字典？任务一：为何需要字典？知识点： 字典也是Python提供的一种常用的容器类型的数据结构，它用于存放一组具有映射关系的数据 例如，个人信息，姓名：小明，年龄：18，性别：男，身高：1.75 这组数据看上去像两个列表，但这两个列表的元素之间有一定的关联关系 如果单纯使用两个列表来保存这组数据，则无法记录两组数据之间的关联关系 为了保存具有映射关系的数据，Python提供了字典，字典相当于保存了两组数据，其中一组数据是关键数据，被称为 key；另一组数据可通过key来访问，被称为value 1234567# 希望将key和val成对绑定key = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;, &#x27;height&#x27;]val = [&quot;小明&quot;, 18, True, 1.75]print(key, val)# 无法直接绑定信息，只能通过索引隐式的绑定print(f&#x27;&#123;key[0]&#125;:&#123;val[0]&#125;&#x27;) 任务二：字典的定义知识点： 字典(dictionary)是 除列表以外， Python 之中 最灵活的数据类型 字典用来存储多个数据，是一种无序的可变容器模型，且可存储任意类型对象。字典可以存储用于描述某个物体 的额外信息 字典与列表区别： 列表是有序的对象集合 字典是无序的对象集合 知识点：定义字典 语法：d = {key1:value1, key2:value2} 字典使用**{}** 来定义和标识 字典使用键值对(key-value)存储数据，键值对之间使用 , 分隔 键 key 是索引，必须是唯一的 值 value 是数据，可以取任何数据类型 每个键值对中的键和值用冒号**:**分割 值可以取任何数据类型，但键 只能使用字符串、数字或 元组 dict为字典类型，避免使用dict作为变量名 任务三：解析字典数据结构12345678910# 创建个人信息字典info = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18, &quot;gender&quot;: True, &quot;height&quot;: 1.75&#125;print(type(info), info)# 可以使用key作为索引访问字典元素print(info[&#x27;height&#x27;]) 任务四：字典变量的适用场景知识点： 字典一般用于描述某个物体属性信息 字典的key通常为字符串，用于描述value 字典是无序的数据集合 8.1.2 字典的创建常用的有两种字典创建方式，一种是使用**{}创建字典；另外种是通过dict()**函数 任务一：使用{}创建字典知识点： d = {key1:value1, key2:value2}，将多个key-value对作为字典元素，放在**{}**中创建字典 **d = {}**为创建空字典 使用**{}方式创建字典，只能手动添加key-value**对 12345678vegetables = &#123;&#x27;celery&#x27;: 1.58, &#x27;brocoli&#x27;: 1.29, &#x27;lettuce&#x27;: 2.19&#125;print(vegetables)cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)empty_dict = &#123;&#125;print(empty_dict) 任务二：使用dict()创建字典知识点： 在使用dict()函数创建字典时，可以传入嵌套的列表或元组参数作为key-value对 每个列表的元素为由两个元素构成的子列表或元组，作为字典的一个key-value对 **dict()**函数可以从已有的数据(列表或元组)创建字典 1234# 创建包含3组key-value对的字典vegetables = [(&#x27;celery&#x27;, 1.58), (&#x27;brocoli&#x27;, 1.29), (&#x27;lettuce&#x27;, 2.19)]dict3 = dict(vegetables)print(dict3) 1234# 创建包含3组key-value对的字典cars = [[&#x27;BMW&#x27;, 8.5], [&#x27;BENS&#x27;, 8.3], [&#x27;AUDI&#x27;, 7.9]]dict4 = dict(cars)print(dict4) 知识点：如果不为**dict()**函数传入任何参数，则代表创建一个空的字典 123# 创建空的字典dict5 = dict()print(dict5) 知识点： 通过为dict()函数指定关键字参数创建字典，此时字典的key不允许使用表达式 dict()函数会关键字参数作为字典的key，不需要将它们写成字符串形式，dict()函数会自动将它们转化为字符串格式的key 123# 直接写spinach、cabbage而非字符串dict6 = dict(spinach = 1.39, cabbage = 2.59)print(dict6) 任务三：三种括号对应的数据类型知识点(总结)：三种括号对应的数据类型 列表list的标识为**[]；元组tuple的标识为()；字典dict的标识为{}** 相对于列表和元组用数字来索引元素，字典可以使用自定义有意义的key来索引元素 123456789# 空列表、元组、字典创建list_val = []print(type(list_val), list_val)tuple_val = ()print(type(tuple_val), tuple_val)dict_val = &#123;&#125;print(type(dict_val), dict_val) 12345678list_val = [1, 2, 3, 4]print(type(list_val), list_val)tuple_val = (1, 2, 3, 4)print(type(tuple_val), tuple_val)dict_val = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4&#125;print(type(dict_val), dict_val) 1234# 列表和元组用数字来索引元素# 字典使用key来索引元素print(list_val[0], tuple_val[0])print(dict_val[&#x27;a&#x27;]) 8.2 深入字典8.2.1 字典元素：键值对任务一：字典元素是key-value键值对知识点：d = {key1:value1, key2:value2} 字典的元素是键值对(key-value) 每个key-value用冒号**:分割，每对之间用逗号,分割，整个字典包括在大括号{}**中 每个key都有与之关联的value，可以通过key来访问(索引)相应的value。例如，value = d[key] 字典的key是唯一，value可以重复 知识点： 通过字典的key可以索引value，也可以对value进行修改 例如，访问元素val = d[key1]；修改元素d[key1] = new_value 列表、元组是有序的，它的索引是从0开始的序号；字典是无序的，它的索引是key 1234567cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;# 通过key来访问valueprint(cars[&#x27;BMW&#x27;])# 通过key修改value值cars[&#x27;BMW&#x27;] = 10.1print(cars) 任务二：字典特性(key是唯一的)知识点： 字典的key必须是唯一的，但value可以重复 如果字典中存在重复的key，那么后面一个key的value会覆盖前个key的value 字典的key是唯一的。例如，两组相同的key：’height’: 1.8和**’height’: 80。那么，‘height’的value**会被80覆盖 123# key是唯一的info = &#123;&#x27;height&#x27;: 1.8, &#x27;height&#x27;: 80, &#x27;age&#x27;: 20, &#x27;sex&#x27;: 0&#125;print(type(info), info) 不同的key可以使用相同的value。例如，**’height’: 1.8和‘weight’: 1.8**，它们相互不影响 123# value可以重复info = &#123;&#x27;height&#x27;: 1.8, &#x27;weight&#x27;: 1.8, &#x27;age&#x27;: 20, &#x27;sex&#x27;: 0&#125;print(type(info), info) 任务三：字典特性(key必须是不可变类型)知识点：key和value的类型要求 key：必须是不可变类型，包括数值类型、字符串和元组tuple value：可以是任意类型的对象 建议key使用有意义的字符串。key的目的是为了方便地索引字典元素 知识点(注意)： 元组是不可变类型，因此元组tuple可以作为字典的key 列表是可变类型，因此列表list不能作为字典的key，否则会引起TypeError 下面例子中，第1个元素的key为字符串，第2个为整形，第3个为浮点数，第4个元组 123# 不同类型的keyinfo = &#123;&#x27;height&#x27;: 1.8, 80: &#x27;weight&#x27;, 3.1: &#123;20, 11&#125;, (0, ): &#x27;sex&#x27;&#125;print(type(info), info) 123# 可变类型的列表不能作为keyinfo = &#123;&#x27;height&#x27;: 1.8, [1,1]: &#x27;weight&#x27;, 3.1: &#123;20, 11&#125;, (0, ): &#x27;sex&#x27;&#125;print(type(info), info) 8.2.2 字典元素操作任务一：字典基本使用12345678910111213141516171819xiaoming_dict = &#123;&quot;name&quot;: &quot;小明&quot;&#125;# 1. 取值print(xiaoming_dict[&quot;name&quot;])# 在取值的时候，如果指定的key不存在，程序会报错！# print(xiaoming_dict[&quot;name123&quot;])# 2. 增加/修改# 如果key不存在，会新增键值对xiaoming_dict[&quot;age&quot;] = 18# 如果key存在，会修改已经存在的键值对xiaoming_dict[&quot;name&quot;] = &quot;小小明&quot;# 3. 删除xiaoming_dict.pop(&quot;name&quot;)# 在删除指定键值对的时候，如果指定的key不存在，程序会报错！# xiaoming_dict.pop(&quot;name123&quot;)print(xiaoming_dict) 任务二：添加新元素知识点：为字典添加新的key-value，只需通过对不存在的key赋值即可 语法：d[key]=value 如果key存在，那么修改key对应的value 如果key不存在，那么对dict添加新的key-value元素 12345678910cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)# 不存在的key添加新元素cars[&#x27;Ford&#x27;] = 10.1print(cars)# 存在的key修改valuecars[&#x27;BMW&#x27;] = 9.1print(cars) 任务三：访问不存在的字典元素知识点：如果使用不存在的key来访问dict中元素，那么就会引发异常KeyError 1234cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)print(cars[&#x27;Ferraris&#x27;]) 任务四：删除字典元素和整个字典知识点：使用del可以删除整个字典或者是字典中的某个元素，永远消失 删除单个元素：del d[key] 删除整个字典：del d 在删除整个字典后，字典在内存中被销毁，如果再次使用该字典会引发异常NameError 1234567891011cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)# 删除&#x27;BENS&#x27;键值对del cars[&#x27;BENS&#x27;]print(cars)# 删除整个字典carsdel cars# 由于cars在内存中被删除，因此打印cars会出错# print(cars) 任务五：检查字典是否包含指定的key知识点：类似于列表，使用in或not in运算符来检查dict是否包含某个key 1234567cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;# 判断cars是否包含名为&#x27;AUDI&#x27;的keyprint(&#x27;AUDI&#x27; in cars)print(&#x27;PORSCHE&#x27; in cars)# 判断cars是否不包含名为&#x27;LAMBORGHINI&#x27;的keyprint(&#x27;LAMBORGHINI&#x27; not in cars) 8.2.3 字典和列表的比较任务一：字典的key和列表的索引比较知识点： key是字典的精髓，用于元素的索引 key类型可以是整数、浮点数、字符串和元组 字典通过key来实现对元素的访问、添加、删除等操作 知识点： 区别1：列表的索引必须是整数**(0,1,2,…)**，从0开始、连续逐渐增大；但字典的索引即便是整数类型，也不需要从0开始，而且也不需要按顺序 区别2：列表不允许对不存在的索引进行赋值，否则会触发异常IndexError；但字典则允许直接对不存在的key进行赋值，字典自动添加新元素 换句话说，列表和字典都支持用索引来访问任意值，但是字典的key可用的数据类型比列表的索引要多得多 123456# 列表整数索引list_age = [20,11,18,30]print(list_age[0])#对于不存在的索引赋值会出错list_age[5] = 1 123456#字典key索引dict_age = &#123;&#x27;zhang&#x27;:20, &#x27;li&#x27;:11, &#x27;wang&#x27;:18, &#x27;xu&#x27;:30&#125;print(dict_age[&#x27;zhang&#x27;])# 可以对不存在的key赋值，添加为新元素dict_age[&#x27;xi&#x27;] = 28 任务二：列表和字典的值可以放任意类型对象知识点(相同)：列表和字典的值都可以存放任何类型的对象 12345list_age = [&#x27;20&#x27;, 11, [18], &#123;&#x27;zhang&#x27;:20&#125;]print(list_age)dict_age = &#123;&#x27;zhang&#x27;:&#x27;20&#x27;, &#x27;li&#x27;:11, &#x27;wang&#x27;:[18], &#x27;xu&#x27;:30&#125;print(dict_age) 任务三：列表和字典的储存方式知识点(不同)： 列表的元素是有序储存的，Python使用这些连续的整数(位置信息)来访问元素 字典的元素是无序储存的，key并不需要与具体元素存储的位置相对应，因此字典key可以是任意的不可变类型 任务四：字典是一种映射方式知识点：字典提供了一种映射手段，可从一组任意对象映射到有关联的另一组任意对象。类似于现实世界中的字典、辞典和翻译书 下面给出了一段将颜色从英文转换为法文的定义： 12345678910111213141516print(&quot;--- 创建空字典&quot;)english_to_french = &#123;&#125; print(&quot;--- 存入3个单词&quot;)english_to_french[&#x27;red&#x27;] = &#x27;rouge&#x27; english_to_french[&#x27;blue&#x27;] = &#x27;bleu&#x27;english_to_french[&#x27;green&#x27;] = &#x27;vert&#x27;print(&quot;--- 获取“red”对应的值&quot;)print(&quot;red is&quot;, english_to_french[&#x27;red&#x27;])print(&#x27;--访问：列表和字典，访问元素时，该元素必须存在，否则会出错--&#x27;)print(&#x27;--赋值：列表赋值元素必须存在，字典赋值元素不一定存在--&#x27;)color = input(&#x27;input color:&#x27;)print(color + &quot; is&quot;, english_to_french[color])print(&#x27;&#123;&#125; is &#123;&#125;&#x27;.format(color, english_to_french[color])) 习题：6-1 人：使用一个字典来存储一个熟人的信息，包括名、姓、年龄和居住的城市。该字典应包含键first_name、last_name、age和city。将存储在该字典中的每项信息都打印出来 1234567dic = &#123;&#x27;first name&#x27;:&#x27;LeBron&#x27;, &#x27;last name&#x27;:&#x27;James&#x27;, &#x27;age&#x27;:&#x27;37&#x27;, &#x27;city&#x27;:&#x27;Cleveland&#x27;, &#125;for each in dic.items(): print(&#x27;His &#x27; + each[0] + &#x27; is &#x27; + each[1]) 1234His first name is LeBronHis last name is JamesHis age is 37His city is Cleveland 6-2 喜欢的数字：使用一个字典来存储一些人喜欢的数字。请想出5个人的名字，并将这些名字用作字典中的键；想出每个人喜欢的一个数字，并将这些数字作为值存储在字典中。打印每个人的名字和喜欢的数字。为让这个程序更有趣，通过询问朋友确保数据是真实的 12345678favorite_nums = &#123;&#x27;James&#x27;:1, &#x27;Kobe&#x27;:2, &#x27;Garnett&#x27;:3, &#x27;Duncan&#x27;:4, &#x27;Jordan&#x27;:5, &#125;for name,numb in favorite_nums.items(): print(name.title()+&quot;&#x27;s favorite number is &quot;+str(numb)) 12345James&#x27;s favorite number is 1Kobe&#x27;s favorite number is 2Garnett&#x27;s favorite number is 3Duncan&#x27;s favorite number is 4Jordan&#x27;s favorite number is 5 6-3 词汇表：Python字典可用于模拟现实生活中的字典，但为避免混淆，我们将后者称为词汇表。 想出你在前面学过的5个python关键字(转换为字符串)，将它们用作词汇表中的键，并将它们的含义作为值存储在词汇表中。 以整洁的方式打印每个词汇及其含义。为此，可以先打印词汇，在它后面加上一个冒号，再打印词汇的含义；也可在一行打印词汇，再使用换行符（\\n）插入一个空行，然后在下一行以缩进的方式打印词汇的含义 12345678910111213141516programming_vocabulary=&#123; &#x27;str()&#x27;:&#x27;将非字符串值表示为字符串&#x27;, &#x27;del&#x27;:&#x27;彻底删除一个元素&#x27;, &#x27;sort()&#x27;:&#x27;对列表进行永久性排序&#x27;, &#x27;sorted()&#x27;:&#x27;对列表进行临时排序&#x27;, &#x27;range()&#x27;:&#x27;生成一系列数字&#x27;, &#125;print(&#x27;\\nstr()&#x27;+&#x27;:\\n\\t&#x27;+programming_vocabulary[&#x27;str()&#x27;])print(&#x27;\\ndel&#x27;+&#x27;:\\n\\t&#x27;+programming_vocabulary[&#x27;del&#x27;])print(&#x27;\\nsort()&#x27;+&#x27;:\\n\\t&#x27;+programming_vocabulary[&#x27;sort()&#x27;])print(&#x27;\\nsorted()&#x27;+&#x27;:\\n\\t&#x27;+programming_vocabulary[&#x27;sorted()&#x27;])print(&#x27;\\nrange()&#x27;+&#x27;:\\n\\t&#x27;+programming_vocabulary[&#x27;range()&#x27;]) 1234567891011121314str(): 将非字符串值表示为字符串del: 彻底删除一个元素sort(): 对列表进行永久性排序sorted(): 对列表进行临时排序range(): 生成一系列数字 8.3 遍历字典8.3.1 概述字典的遍历任务一：初识字典的遍历知识点： 字典可能只包含几个key-value，也可能包含数百万个key-value。鉴于字典可能包含大量的数据，Python为字典提供了3种遍历方式： 遍历key-value：for key, val in dict.items() 遍历key：for key in dict.keys() 遍历value：for val in dict.value() 字典的遍历就是依次从字典中获取所有键值对 12345678xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18, &quot;gender&quot;: True, &quot;height&quot;: 1.75&#125;# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print(f&quot;&#123;k&#125;: &#123;xiaoming[k]&#125;&quot;) 注意：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 任务二：字典和列表综合遍历需求分析： 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用多个键值对，来存储描述某个 物体 的相关信息 —— 描述更复杂的数据信息 将多个物体(字典)放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理 1234567891011121314# 使用多个键值对，存储描述一个物体的相关信息# 来描述更复杂的数据信息。# 将多个字典放在一个列表中，再进行遍历。card_list = [ &#123;&quot;name&quot;: &quot;张三&quot;, &quot;qq&quot;: &quot;12345&quot;, &quot;phone&quot;: &quot;110&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;qq&quot;: &quot;54321&quot;, &quot;phone&quot;: &quot;10086&quot;&#125;]for card_info in card_list: print(card_info) 8.3.2 items()遍历字典key-value任务一：items()函数返回key-value数组知识点： 语法：dict.items() 描述： 为字典dict返回可遍历的(键, 值)元组数组 参数：无 返回：class ‘dict_items’数组类型(可迭代对象)，元素为key-value的元组 123cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;d_items = cars.items()print(type(d_items), d_items) 任务二：items()函数遍历字典的key-value知识点：遍历字典所有的key-value 语法： 12for k, v in dict.items(): &lt;缩进语句块&gt; 类似于enumerate()函数，每次迭代items()返回的是一个包含(key, value)的键值对元组 因此，这里需要使用两个临时变量k和v对遍历的元组(字典元素)进行解包 k变量：储存键值对的key。v变量：储存键值对的value 123cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;for k, v in cars.items(): print(f&#x27;&#123;k.title()&#125;:&#123;v&#125;&#x27;, end=&#x27; &#x27;) 将字典的key和value组成一个新的列表 123456789cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;result = []for k, v in cars.items(): result.append((k, v))print(result)# 列表推导式print([(k, v) for k, v in cars.items()]) 8.3.3 keys()遍历字典key任务一：keys()返回字典key数组知识点： 语法：dict.keys() 描述： 为字典dict返回可遍历的key数组 参数：无 返回：**’class dict_keys’数组类型(可迭代对象)，元素为key** 123cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;d_keys = cars.keys()print(type(d_keys), d_keys) 任务二：keys()函数遍历字典的key知识点：遍历字典所有的key 语法： 12for k in dict.keys(): &lt;缩进语句块&gt; 每次迭代keys()返回的是一个元素的key值，存储在临时变量k中 123cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;for k in cars.keys(): print(f&#x27;&#123;k.title()&#125;&#x27;, end=&#x27; &#x27;) 任务三：查询某个key是否在字典中知识点： 语法：if k in dict.keys(): 或 if k not in dict.keys(): 描述：查询变量k是否是字典dict的key 方法keys()并非只能用于遍历；实际上，它返回一个包含字典所有key的数组，然后，使用关键字in和not in来查询是否包括某个key 1234cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;if &#x27;Ford&#x27; not in cars.keys(): print(&quot;Ford not in cars&quot;) 任务四：使用sorted()对字典的key进行排序知识点： 由于字典储存key-value是无序的。因此，使用**keys()**获得元素也是无序的 如果希望对字典的key按升序或降序方式排序，可以使用**sorted(dict.keys())**方式 **sorted(dict.keys())**仅返回排序的拷贝，对字典本身无影响 123456cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;# 按升序排序for k in sorted(cars.keys(), reverse=False): #cars[k]为通过k返回对于的value print(f&#x27;&#123;k&#125;:&#123;cars[k]&#125; &#x27;, end=&#x27; &#x27;) 8.3.4 values()遍历字典value任务一：values()字典value数组知识点： 语法：dict.values() 描述： 为字典dict返回可遍历的value数组 参数：无 返回：**’class dict_values’数组类型(可迭代对象)，元素为value** 123cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;d_values = cars.values()print(type(d_values), d_values) 知识点：遍历字典所有的value 语法： 12for v in dict.value(): &lt;缩进语句块&gt; 每次迭代values()返回的是一个元素的value值，存储在临时变量v中 123456789languages = &#123; &#x27;jen&#x27;: &#x27;python&#x27;, &#x27;sarah&#x27;: &#x27;c&#x27;, &#x27;edward&#x27;: &#x27;ruby&#x27;, &#x27;phil&#x27;: &#x27;python&#x27;,&#125;for v in languages.values(): print(v.title()) 程序解析： 这条for语句提取字典中的每个值，并将它们依次存储到变量language中 通过打印这些值，就获得了一个列表，其中包含被调查者选择的各种语言 这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项 任务二：set()剔除重复值知识点： 为剔除重复项，可使用集合set类型 **class ‘set’**为容器类型(迭代对象)的数据结构 set对象，使用**{}**包含元素，每个元素是唯一的、不重复的 set()函数可以将某个序列转换为set类型 1234567891011121314languages = &#123; &#x27;jen&#x27;: &#x27;python&#x27;, &#x27;sarah&#x27;: &#x27;c&#x27;, &#x27;edward&#x27;: &#x27;ruby&#x27;, &#x27;phil&#x27;: &#x27;python&#x27;,&#125;print(&quot;--set数据结构：1.无序 2.不重复 3.&#123;&#125;包含元素--&quot;)set_languages = set(languages.values())print(type(set_languages), set_languages)# 遍历set元素for v in set_languages: print(v.title()) 习题：6-4 词汇表2：既然你知道了如何遍历字典，现在请整理你为完成练习6-3而编写的代码，将其中的一系列print语句替换为一个遍历字典中的键和值的循环。确定该循环正确无误后，再在词汇表中添加5个Python术语。当你再次运行这个程序时，这些新术语及其含义将自动包含在输出中 1234567891011121314151617181920programming_vocabulary=&#123; &#x27;str()&#x27;:&#x27;将非字符串值表示为字符串&#x27;, &#x27;del&#x27;:&#x27;彻底删除一个元素&#x27;, &#x27;sort()&#x27;:&#x27;对列表进行永久性排序&#x27;, &#x27;sorted()&#x27;:&#x27;对列表进行临时排序&#x27;, &#x27;range()&#x27;:&#x27;生成一系列数字&#x27;, &#125;programming_vocabulary[&#x27;title()&#x27;]=&#x27;首字母大写&#x27;programming_vocabulary[&#x27;lower()&#x27;]=&#x27;全部字母小写&#x27;programming_vocabulary[&#x27;upper()&#x27;]=&#x27;全部字母大写&#x27;programming_vocabulary[&#x27;append()&#x27;]=&#x27;在列表末尾添加元素&#x27;programming_vocabulary[&#x27;insert()&#x27;]=&#x27;在列表中插元素&#x27;for key, value in programming_vocabulary.items(): print(key+&#x27;:\\n\\t&#x27;+value+&#x27;.&#x27;) 1234567891011121314151617181920str(): 将非字符串值表示为字符串.del: 彻底删除一个元素.sort(): 对列表进行永久性排序.sorted(): 对列表进行临时排序.range(): 生成一系列数字.title(): 首字母大写.lower(): 全部字母小写.upper(): 全部字母大写.append(): 在列表末尾添加元素.insert(): 在列表中插元素. 6-5 河流：创建一个字典，在其中存储三条大河流及其流经的国家。其中一个键—值对可能是**’nile’: ‘egypt’** 使用循环为每条河流打印一条消息，如“The Nile runs through Egypt.” 使用循环将该字典中每条河流的名字都打印出来 使用循环将该字典包含的每个国家的名字都打印出来 12345678910dic = &#123;&#x27;Euphrates&#x27;:&#x27;Iraq&#x27;, &#x27;Nile&#x27;:&#x27;Egypt&#x27;, &#x27;Huanghe&#x27;:&#x27;China&#x27;, &#125;for key, value in dic.items(): print(&#x27;The &#x27; + key + &#x27; runs through &#x27; + value)for key in dic.keys(): print(key)for value in dic.values(): print(value) 123456789The Euphrates runs through IraqThe Nile runs through EgyptThe Huanghe runs through ChinaEuphratesNileHuangheIraqEgyptChina 8.3.5 list()获得key和value列表任务一：list()获得key和value列表知识点： items()、keys()和values()获得的数据类型不是列表类型，不能对它们实施列表相关操作，比如元素修改、添加或删除、排序等。否则会引起异常TypeError 为此，可以通过**list()**函数将它们转换为列表 123456cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;d_items = cars.items()print(type(d_items), d_items)#不能对items()返回结果进行操作，TypeErrord_items[1] = (&#x27;BMW&#x27;, 10.5) 12345# 将items()转换为列表# 或l_items = list(cars.items())l_items = list(d_items)print(type(l_items), l_items)l_items[1] = (&#x27;BMW&#x27;, 10.5) 8.4 字典内置函数和方法任务一：查看字典常用操作知识点： 在python中，字典类型是dict类 可以通过**dir(dict)**函数查看字典对象里里所包含的属性和方法 暂时忽略**__下划线的属性和方法。dict类为字典操作提供：‘clear()’, ‘copy()’, ‘fromkeys()’, ‘get()’, ‘items()’, ‘keys()’, ‘pop()’, ‘popitem()’, ‘setdefault()’, ‘update()’, ‘values()’**方法 1print(dir(dict), end=&#x27; &#x27;) 根据Jupyter智能联想功能，查看字典的函数。步骤如下： 定义一个字典，例如：xiaoming = {} 输入 xiaoming. 再按下TAB键(装有智能联想插件后，不需要按TAB键)，Jupyter会提示智能联想字典的所有函数 1234xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 1234567891011121314151617xiaoming_dict = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 1. 统计键值对数量print(len(xiaoming_dict))# 2. 合并字典temp_dict = &#123;&quot;height&quot;: 1.75, &quot;age&quot;: 20&#125;# 注意：如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对xiaoming_dict.update(temp_dict)# 3. 清空字典xiaoming_dict.clear()print(xiaoming_dict) 任务二：len(dict)函数返回字典元素个数知识点：**len(dict)**返回字典元素(key-value)的个数 12cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(len(cars)) 任务三：clear()方法清空字典知识点： 语法：dict.clear() 描述：用于清空字典dict中所有的key-value。对一个字典执行clear()方法之后，该字典就会变成一个空字典 参数和返回：无 和del dict区别：del dict将字典从内存中销毁，而dict.clear()只是清空字典，字典dict在内存中依然存在 123456cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)# 清空cars所有key-valuecars.clear()print(cars) 1234# 在内存中销毁字典cars对象, 之后的语句cars不存在del cars# print会出错print(cars) 任务四：get()方法获取字典元素知识点： 语法：dict.get(key) 描述：根据key来获取value，它相当于方括号语法**dict[key]**的增强版 dict[key]：访问并不存在的key时，字典会引发KeyError错误 dict.get(key)：访问并不存在的key时，会简单地返回None，不会导致错误 参数：要查询的key，不管元素是否存在 12345cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;# 获取&#x27;BMW&#x27;对应的valueprint(cars.get(&#x27;BMW&#x27;)) # 8.5print(cars.get(&#x27;PORSCHE&#x27;)) # Noneprint(cars[&#x27;PORSCHE&#x27;]) # KeyError 任务五：setdefault()方法查询字典元素知识点： 语法：dict.setdefault(key, default=None) 描述：类似于get()方法, 根据key来获取对应value的值。是增强版的**get()**方法 和get()方法的相同：如果key存在，则直接返回key对应的value 和get()方法的区别：如果key不存在，先将默认值default作为value和key一起添加到字典，然后再返回对应的value； 参数：要查询的key。default为key不存在时的默认值value 返回：key对应的value或default 12345678910cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)# 设置默认值，该key在dict中不存在，新增key-value对print(cars.setdefault(&#x27;PORSCHE&#x27;, 9.2)) # 9.2print(cars)# 设置默认值，该key在dict中存在，不会修改dict内容print(cars.setdefault(&#x27;BMW&#x27;, 3.4)) # 8.5print(cars) 任务六：update()方法更新字典元素知识点： 语法：dict.update(sub_dict) 描述：使用一个字典sub_dict中所包含的key-value来更新字典dict 如果被更新的字典dict中己包含对应的key-value，那么原value会被覆盖 如果被更新的字典dict中不包含对应的key-value，则添加该key-value 参数：字典sub_dict，元素包含需要添加的key-value 返回：无 123456cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)# &#x27;BMW&#x27;被更新，&#x27;PORSCHE&#x27;被添加cars.update(&#123;&#x27;BMW&#x27;:4.5, &#x27;PORSCHE&#x27;: 9.3&#125;)print(cars) 任务七：pop()方法弹出字典元素知识点： 语法：dict.pop(key) 描述：获取指定key对应的value，并把这个key-value从字典dict中删除 参数：输入字典dict需要弹出元素的key 返回：key对应的value 12345cars = &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3, &#x27;AUDI&#x27;: 7.9&#125;print(cars)print(cars.pop(&#x27;AUDI&#x27;)) # 7.9print(cars) # &#123;&#x27;BMW&#x27;: 8.5, &#x27;BENS&#x27;: 8.3&#125; 习题：6-7 人：在为完成练习6-1而编写的程序中，再创建两个表示人的字典，然后将这三个字典都存储在一个名为people的列表中。遍历这个列表，将其中每个人的所有信息都打印出来 12345678910111213141516171819dic1 = &#123;&#x27;first_name&#x27;:&#x27;jiajia&#x27;, &#x27;last_name&#x27;:&#x27;amy&#x27;, &#x27;age&#x27;:&#x27;18&#x27;, &#x27;city&#x27;:&#x27;shantou&#x27;, &#125;dic2 = &#123;&#x27;first_name&#x27;:&#x27;yinyin&#x27;, &#x27;last_name&#x27;:&#x27;mike&#x27;, &#x27;age&#x27;:&#x27;28&#x27;, &#x27;city&#x27;:&#x27;NewYork&#x27;, &#125;dic3 = &#123;&#x27;first_name&#x27;:&#x27;bai&#x27;, &#x27;last_name&#x27;:&#x27;LI&#x27;, &#x27;age&#x27;:&#x27;38&#x27;, &#x27;city&#x27;:&#x27;shanghai&#x27;, &#125;dic_ls = [dic1, dic2, dic3]for index, each in enumerate(dic_ls): for key, value in each.items(): print(str(index) + &#x27;\\&#x27;s &#x27; + key + &#x27; is &#x27; + value) 1234567891011120&#x27;s first_name is jiajia0&#x27;s last_name is amy0&#x27;s age is 180&#x27;s city is shantou1&#x27;s first_name is yinyin1&#x27;s last_name is mike1&#x27;s age is 281&#x27;s city is NewYork2&#x27;s first_name is bai2&#x27;s last_name is LI2&#x27;s age is 382&#x27;s city is shanghai 6-8 宠物：创建多个字典，对于每个字典，都使用一个宠物的名称来给它命名；在每个字典中，包含宠物的类型及其主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，并将宠物的所有信息都打印出来 1234567891011121314151617181920212223242526272829303132pets = []pet = &#123; &#x27;animal type&#x27;: &#x27;python&#x27;, &#x27;name&#x27;: &#x27;john&#x27;, &#x27;owner&#x27;: &#x27;guido&#x27;, &#x27;weight&#x27;: 43, &#x27;eats&#x27;: &#x27;bugs&#x27;,&#125;pets.append(pet)pet = &#123; &#x27;animal type&#x27;: &#x27;chicken&#x27;, &#x27;name&#x27;: &#x27;clarence&#x27;, &#x27;owner&#x27;: &#x27;tiffany&#x27;, &#x27;weight&#x27;: 2, &#x27;eats&#x27;: &#x27;seeds&#x27;,&#125;pets.append(pet)pet = &#123; &#x27;animal type&#x27;: &#x27;dog&#x27;, &#x27;name&#x27;: &#x27;peso&#x27;, &#x27;owner&#x27;: &#x27;eric&#x27;, &#x27;weight&#x27;: 37, &#x27;eats&#x27;: &#x27;shoes&#x27;,&#125;pets.append(pet)for pet in pets: print(&quot;\\nHere&#x27;s what I know about &quot; + pet[&#x27;name&#x27;].title() + &quot;:&quot;) for key, value in pet.items(): print(&quot;\\t&quot; + key + &quot;: &quot; + str(value)) 1234567891011121314151617181920Here&#x27;s what I know about John: animal type: python name: john owner: guido weight: 43 eats: bugsHere&#x27;s what I know about Clarence: animal type: chicken name: clarence owner: tiffany weight: 2 eats: seedsHere&#x27;s what I know about Peso: animal type: dog name: peso owner: eric weight: 37 eats: shoes 6-9 喜欢的地方：创建一个名为favorite_places的字典。在这个字典中，将三个人的名字用作键；对于其中的每个人，都存储他喜欢的1~3个地方。为让这个练习更有趣些，可让一些朋友指出他们喜欢的几个地方。遍历这个字典，并将其中每个人的名字及其喜欢的地方打印出来 12345678910favorite_places=&#123; &#x27;James&#x27;:[&#x27;hangzhou&#x27;,&#x27;wuhan&#x27;,&#x27;changsha&#x27;], &#x27;Kobe&#x27;: [&#x27;hawaii&#x27;, &#x27;iceland&#x27;], &#x27;Jordan&#x27;: [&#x27;verstovia&#x27;, &#x27;the playground&#x27;, &#x27;south carolina&#x27;]&#125;for name,places in favorite_places.items(): print(name.title()+&quot; likes &quot;) for place in places: print(&quot;- &quot; + place.title()) 1234567891011James likes - Hangzhou- Wuhan- ChangshaKobe likes - Hawaii- IcelandJordan likes - Verstovia- The Playground- South Carolina 6-10 喜欢的数字：修改为完成练习6-2而编写的程序，让每个人都可以有多个喜欢的数字，然后将每个人的名字及其喜欢的数字打印出来 1234567favorite_numbers = &#123; &#x27;James&#x27;: [23,6], &#x27;Kobe&#x27;: [24,8], &#x27;Jordan&#x27;: [45,23,0], &#125;for people,number in favorite_numbers.items(): print(people+&#x27; like &#x27;+str(number)) 123James like [23, 6]Kobe like [24, 8]Jordan like [45, 23, 0] 6-11 城市：创建一个名为cities的字典，其中将三个城市名用作键；对于每座城市，都创建一个字典，并在其中包含该城市所属的国家、人口约数以及一个有关该城市的事实。在表示每座城市的字典中，应包含country、population和fact等键。将每座城市的名字以及有关它们的信息都打印出来 12345678910111213141516171819202122232425cities=&#123; &#x27;武汉&#x27;:&#123; &#x27;country&#x27;:&#x27;China&#x27;, &#x27;population&#x27;:&#x27;1121.20W&#x27;, &#x27;fact&#x27;:&#x27;Gui&#x27;, &#125;, &#x27;杭州&#x27;:&#123; &#x27;country&#x27;:&#x27;China&#x27;, &#x27;population&#x27;:&#x27;1036W&#x27;, &#x27;fact&#x27;:&#x27;Tian Mu&#x27;, &#125;, &#x27;kathmandu&#x27;: &#123; &#x27;country&#x27;: &#x27;nepal&#x27;, &#x27;population&#x27;: 1003285, &#x27;fact&#x27;: &#x27;himilaya&#x27;, &#125;,&#125;for city, city_info in cities.items(): country = city_info[&#x27;country&#x27;].title() population = city_info[&#x27;population&#x27;] mountain = city_info[&#x27;fact&#x27;].title() print(&quot;\\n&quot; + city.title() + &quot; is in &quot; + country + &quot;.&quot;) print(&quot; It has a population of about &quot; + str(population) + &quot;.&quot;) print(&quot; The &quot; + mountain + &quot; mountain is nearby.&quot;) 1234567891011武汉 is in China. It has a population of about 1121.20W. The Gui mountain is nearby.杭州 is in China. It has a population of about 1036W. The Tian Mu mountain is nearby.Kathmandu is in Nepal. It has a population of about 1003285. The Himilaya mountain is nearby. 8.5 实例：词频统计编写一个用于分析文档并计算每个单词在文档中出现的次数的程序。这种文档分析常被用于检测两个文档内容的相似度，也被用于自动索引和归档程序（如互联网搜索引擎） 需求分析： 从程序角度上，只需遍历文档，对每个出现的单词进行累加计数 这里将使用本章学习到的字典，为每个单词建立一个计数器 任务一：构建词频统计字典建立维护单词计数器的字典counts，其中key是代表文档中的单词的字符串，value是计算单词出现次数的整数。要更新特定单词w的计数，只需要一行代码，当遍历到单词w，那么就将它的计数+1 12# w为单词字符串counts[w] = counts[w] + 1 任务二：更新词频统计对词频字典counts更新词频的统计。在这里使用字典会遇到一个Bug。第一次遇到一个单词时，由于字典counts中还没有该单词，如果对它进行访问counts[w]会引起KeyError异常。为了防范这种情况，需要在算法中做出判断： 如果字典counts中已经存在单词w那么就对它进行+1 如果单词w不存在，那么就向字典添加新元素 方法一：为检测某个key是否在字典中存在，可以使用in运算符： 1234if w in counts: counts[w] = counts[w] + 1else: counts[w] = 1 方法二：更优雅的方法是使用setdefault()方法，如果w不在字典中，将返回0，结果是w的条目设置为1： 12# 如果不存在，则添加新元素，初始值为0counts[w] = counts.setdefault(w,0) + 1 任务三：文件输入和预处理在分析文件词频前，需要对文本文档拆分成一系列的单词。但在拆分之前，需要做如下两个操作： 将所有文本单词统一转换为小写(这样出现“Foo”将匹配“foo”) 消除标点符号（这样“foo,”匹配“foo”） 12345678910111213141516# 输入文件名比如 &#x27;hello.txt&#x27;fname = input(&quot;File to analyze: &quot;)# 将整个文件读取为一个长字符串# open(fname,&quot;r&quot;)为&#x27;r&#x27;只读模式打开文件，然后再调用read()读文件# encoding = &#x27;UTF-8&#x27;指定文件编码类型&#x27;UTF-8&#x27;text = open(fname,&#x27;r&#x27;, encoding = &#x27;UTF-8&#x27;).read()# 所有字符转换为小写text = text.lower()# 删除标点，将文本的标点符号统一替换为空格&#x27; &#x27;for ch in &#x27;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_‘&#123;|&#125;~&#x27;: text = text.replace(ch, &quot; &quot;)# 字符串的split()方法将字符串按空格拆分为words列表words = text.split() 任务四：更新字典词频遍历单词列表words，构建字典counts 123counts = &#123;&#125;for w in words: counts[w] = counts.get(w, 0) + 1 任务五：对词频进行排序按词频的降序排序，总结counts的内容 方法一：打印所有单词。按字母顺序打印出单词列表及其关联的计数 123456789# 获得所有单词，即字典的keyuniqueWords = list(counts.keys())# 对单词列表进行排序uniqueWords.sort()# 再打印排序结果for w in uniqueWords: print(w, counts[w]) 方法二：打印前n个单词。然而，对于一个大文件，很多单词仅出现少数几次。更好的方式是打印文档中前n个最常见单词的计数。为此，需要创建一个按计数排序的列表c_words，然后从列表中选择前n项 首先用字典的items()方法，获取键值对的列表，这里的c_words是一个字典的key-value元组列表 12# 将items()返回结果转换为list类型c_words = list(counts.items()) 然后，对列表c_words进行排序 如果直接使用列表排序**c_words.sort()**，Python会按默认的排序方法 然而，当Python比较元组时，它会按部分从左到右排序。由于key-value元组的第一个部分是单词，所以c_words.sort()将会按照字母顺序排列此列表 为了能让列表排序按词频(key-value元组的第二个部分)，可以自定义**sort()的排序规则。注意，元组像列表一样从0开始索引，所以pair[1]**将元组的词频部分返回 123#自定义排序规则，pair为列表元素(元组)，按词频pair[1]排序def byFreq(pair): return pair[1] 将排序规则通过key参数传给**c_words.sort()**函数： 12# 设定排序规则函数c_words.sort(key=byFreq) 双重排序：希望对的列表主要按词频排序，但在词频相同时按字母顺序排列。如何处理这种双重排序呢？ 解决方法：如果在按词频排序之前，所有单词按照字母顺序排列，那么具有相同词频的单词仍将按照字母顺序排列。为此，只需要对列表进行两次排序，先按单词排序，再按频率排序： 12c_words.sort() #先按单词字母升序排序c_words.sort(key=byFreq, reverse=True) #后按词频降序排序 任务六：输出结果按照从最频繁到最不频繁的顺序排列，打印前 n 个最常见的单词的报告。通过格式化字符串形式遍历列表c_words前n个元素： 1234for i in range(n): #列表元素是元组，解包元组 word, count = c_words[i] print(&quot;&#123;0:&lt;15&#125;&#123;1:&gt;5&#125;&quot;.format(word, count)) 索引i用于从列表c_words中获取c_words[i]元素(元组)，并将该元组解包到word和count中。 然后通过**.format()**函数格式化输出字符串，单词格式15个空格左对齐，词频5个空格右对齐 任务七：最终程序123456789101112131415161718192021222324252627282930def byFreq(pair): return pair[1]print(&quot;此程序对文件单词(英语)进行词频分析&quot;)print(&quot;并输出前n个词频最高的单词.\\n&quot;)# 输入文件：Python_Data.txtfname = input(&quot;File to analyze: &quot;)text = open(fname,&#x27;r&#x27;, encoding = &#x27;UTF-8&#x27;).read()text = text.lower()for ch in ’!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_‘&#123;|&#125;~’: text = text.replace(ch, ’ ’) words = text.split()# 构建词频统计字典counts = &#123;&#125;for w in words: counts[w] = counts.setdefault(w,0) + 1# 排序前n项词频统计n = eval(input(&quot;Output analysis of how many words? &quot;))c_words = list(counts.items())c_words.sort()c_words.sort(key=byFreq, reverse=True)# 格式化输出结果for i in range(n): word, count = c_words[i] print(&quot;&#123;0:&lt;15&#125;&#123;1:&gt;5&#125;&quot;.format(word, count)) 8.6 (总结) 四大容器类型公共方法8.6.1 内置函数对于容器类型，Python包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key比较 知识点：比较运算符 直接使用比较运算符来对有序类型数据作比较 **cmp(item1, item2)**函数在Python3中已被淘汰 知识点： 字符串的比较规则按Unicode码顺序 数字字符**&lt;大写字母&lt;**小写字母。即 “0” &lt; “A” &lt; “a” 知识点：Unicode码扩展自ASCII码 ASCII使用8位宽(1字节)来对字符进行编码 Unicode使用16位宽(2字节) 这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号 前127个的Unicode码与ASCII码一样 8.6.2 切片知识点： 切片适合字符串、列表、元组数据类型 切片使用索引值来限定范围，提取子序列 字符串的切片操作：从一个大的字符串中切出小的字符串。例如：**”0123456789”[::-2]**，切片结果为 “97531” 列表和元组的切片操作：它们都是有序的集合，都能够通过索引值获取到对应的数据。因此，也支持切片操作 字典 是一个无序的集合，是使用键值对保存数据。不能使用切片操作 8.6.3 运算符 运算符 表达式 结果 描述 支持的数据类 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 知识点：in 和 not in 被称为成员运算符 成员运算符用于测试序列中是否包含指定的成员 in运算符： 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in运算符： 如果在指定的序列中找不到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对字典操作时，判断的是字典的key 8.6.4 完整的for-else循环语法在 Python 中完整 for 循环 的语法是带有else语句块的 1234for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 需求：当迭代遍历嵌套的数据类型时，要判断某个字典中是否存在指定的值 如果存在，提示并且退出循环 如果不存在，在循环整体结束后，希望得到一个统一的提示 123456789101112131415161718192021222324252627282930students = [ &#123;&quot;name&quot;: &quot;阿土&quot;, &quot;age&quot;: 20, &quot;gender&quot;: True, &quot;height&quot;: 1.7, &quot;weight&quot;: 75.0&#125;, &#123;&quot;name&quot;: &quot;小美&quot;, &quot;age&quot;: 19, &quot;gender&quot;: False, &quot;height&quot;: 1.6, &quot;weight&quot;: 45.0&#125;,]find_name = &quot;阿土&quot;for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[&quot;name&quot;] == find_name: print(&quot;找到了&quot;) # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print(&quot;没有找到&quot;)print(&quot;循环结束&quot;)","categories":[],"tags":[]},{"title":"Python学习笔记7","slug":"Python学习笔记7","date":"2021-06-16T16:29:51.000Z","updated":"2021-06-16T16:33:29.701Z","comments":true,"path":"2021/06/17/py7.html","link":"","permalink":"http://waxll.top/2021/06/17/py7.html","excerpt":"","text":"第七章 if条件判断7.1 初识if语句知识点：控制结构 到目前为止，Python程序都是按顺序流程，逐条语句执行。然而，顺序流程并不能解决所有问题。因此，需要改变程序的逻辑运行结构，来适应特定场景的需求 在现实中，很多场合都需要有选择的执行程序。例如，电梯需要根据用户的选择楼层来运行；空调需要根据设定模式来运行制冷或制热 Python提供了控制结构来实现上述功能。通过if条件判断语句，使程序可以根据条件来有选择地执行语句 7.1.1 判断的背景介绍任务一：判断的定义知识点： 如果 条件满足，才能做某件事情 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化 判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支 7.1.2 if判断语句基本语法任务一：BMI健康指数计算程序知识点(背景介绍)：BMI健康指数 BMI健康指数(BMI，Body Mass Index)是国际上常用的衡量人体肥胖程度和是否健康的重要标准。肥胖程度的判断不能采用体重的绝对值，它天然与身高有关。因此，BMI 通过人体体重和身高两个数值获得相对客观的参数，并用这个参数所处范围衡量身体质量 BMI=体重/身高的平方，单位：kg/㎡ 目前，BMI健康指数的正常范围是18.5至24.9之间，这范围是比较健康的标准体重 BMI计算程序：根据的输入身高(m)和体重(kg)来计算BMI健康指数 123456789101112# 定义BMI健康计算函数def BMI_calc(weight, height): BMI = weight / height**2 return BMI# 输入身高和体重，要转换为浮点数weight = float(input(&#x27;输入体重(kg)：&#x27;))height = float(input(&#x27;输入身高(m)：&#x27;))# 调用BMI计算函数BMI = BMI_calc(weight, height)print(&quot;BMI:&#123;&#125;, 体重:&#123;&#125;, 身高:&#123;&#125;&quot;.format(BMI, weight, height)) 接下来，让程序变的聪明些，根据BMI值做出些判断。为实现上述功能，Python提供了if判断控制语句 任务二：if条件判断语句在 Python 中，if 语句 就是用来进行判断的，格式如下： 12if &lt;condition&gt;: &lt;statement&gt; 知识点：if语句由if :头部和缩进部分的****组成，具体如下： if为判断的关键字。**:**为语句块标识符 ：判断条件，是一个值为True或False的表达式 如果为True，执行紧跟在if语句后面的****语句块 如果为False，就**跳过**语句块 注意，if的语句块是否执行取决于条件是否满足 ****：条件成立时，要做的事情 知识点：缩进的重要性 和for循环类似，if语句块也使用缩进来标识语句块 一般缩进为一个 Tab 键，或者 4 个空格 建议，在**:之后敲回车，它之后的语句Jupyte**r会自动缩进 在 Python 开发中，Tab和空格不要混用 任务三：判断年龄需求分析： 定义一个整数变量记录年龄 判断是否满 18 岁 （**&gt;=**） 如果满 18 岁，允许进网吧嗨皮 12345678910# 1. 定义年龄变量age = 18# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的代码块if age &gt;= 18: print(&quot;可以进网吧嗨皮……&quot;)# 3. 思考！- 无论条件是否满足都会执行print(&quot;这句代码什么时候执行?&quot;) 知识点： if 语句以及缩进部分是一个 完整的代码块 使用Jupyter代码折叠插件(左边的下三角)，可以查看if语句的具体语句块范围 任务四：判断BMI健康程度123456789101112# 输入身高和体重，要转换为浮点数weight = float(input(&#x27;输入体重(kg)：&#x27;))height = float(input(&#x27;输入身高(m)：&#x27;))# 调用BMI计算函数BMI = BMI_calc(weight, height)print(&quot;BMI:&#123;&#125;, 体重:&#123;&#125;, 身高:&#123;&#125;&quot;.format(BMI, weight, height))if BMI &lt; 18.5: print(&#x27;太苗条了！去吃顿大餐！&#x27;)if BMI &gt; 24.9: print(&#x27;太重了！去操场思过吧！&#x27;) 任务五：保留字True和False知识点： True和False，为布尔类型``，是Python的保留字，代表逻辑真和假 true和false为自定义的变量名，是“普通老百姓” Python敏感于大小写。首字母大写的是保留字 为避免歧义，请尽量避免使用与关键字相似的词来命名变量 123456a = Trueprint(type(a), a)#a是布尔类型，可以作为if判断条件if a: print(&#x27;执行if&#x27;) 1234567# 小写的true是变量true = Falseprint(type(true), true)# 由于true变量是False，if不执行if true: print(&#x27;执行if&#x27;) 任务六：空列表、空字符串和数字零作为判断条件知识点： 对于空列表**[]、空字符串“”或‘’、数字0作为判断条件时，都判断为False** 但是字符串**’0’判断为True** 1234567891011121314#Falsecondition = []if condition: print(&#x27;True&#x27;)#Falsecondition = 0if condition: print(&#x27;True&#x27;)#Truecondition = &#x27;0&#x27;if condition: print(&#x27;True&#x27;) 7.1.3 if-else语句任务一：掌握if-else语句思考：在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢 答案：使用else处理条件不满足的情况，格式如下 1234if &lt;condition&gt;: &lt;if statement&gt;else: &lt;else statement&gt; 知识点：if-else语句实现2路分支 描述：当**判断条件为True，执行分支；不满足时，执行分支** 在if-else结构中，总是会执行两个操作中的一个 任务二：判断年龄的改进需求分析： 输入用户年龄 判断是否满 18 岁 （**&gt;=**） 如果满 18 岁，提示你成年了 如果未满 18 岁，提示你还是小屁孩 1234567891011121314# 1. 输入用户年龄age = int(input(&quot;今年多大了？&quot;))# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的语法块if age &gt;= 18: print(&quot;你成年了&quot;) print(&quot;:)&quot;)else: print(&quot;你还是小屁孩&quot;) print(&quot;:(&quot;)# 3. 思考！- 无论条件是否满足都会执行print(&quot;这句代码什么时候执行?&quot;) 程序解析： 如果age &gt;= 18条件为True，就执行if的语句块 如果为False，就执行else的语句块 由于age=17小于18，条件判断为False，因此执行else的语句块 知识点： if 和 else 语句以及各自的缩进部分是一个完整的if-else结构 习题：题目要求： 输入一个年份，判断当前是否是闰年，如果是则输出闰年，否则输出非闰年。(闰年条件：1. 能被4整除。2. 遇到100年，则需要被400整除) 代码如下： 12345year =eval(input(&quot;输入年份:&quot;)) # 2021if(year % 4==0 and year % 100!=0) or year % 400==0: print(&quot;闰年&quot;)else: print(&quot;非闰年&quot;) 运行结果： 1非闰年 7.2 判断条件：布尔表达式7.2.1 初识布尔表达式任务一：初识布尔表达式(条件判断)知识点(术语)：判断条件或布尔表达式 布尔表达式语法：** ** 描述：通过比较**两个表达式的值，返回结果是布尔值True或False** 是表达式的缩写。这里表达式可以是变量、运算结果、函数返回等 是关系运算符的缩写 复杂的判断条件，可以通过逻辑运算符(and、or、not等)进行符合 Python 数学 含义 &lt; &lt; 小于 &lt;= ≤ 小于等于 == = 等于 &gt;= ≥ 大于等于 &gt; &gt; 大于 != ≠ 不等于 与数学里不一样，Python使用**==表示逻辑相等，而=**表示赋值语句 知识点：布尔表达式 判断条件实际上是一种特殊的表达式，称为布尔表达式，为纪念乔治·布尔，一位19世纪英国数学家 对一个布尔表达式求值，会产生值True(条件成立)或False(不成立) 某些语言(C++)就用整数1和0来表示这些值。Java和Python有布尔表达式的专用数据类型bool 在Python中，布尔表达式类型为bool，布尔值由字面量True和False表示 123456# 输出布尔表达式的结果print(3 &lt; 4)print((3 * 4) &lt; (3 + 4))print(&quot;hello&quot; == &quot;hello&quot;)print(&quot;hello&quot; &lt; &quot;hello&quot;)print(&quot;Hello&quot; &lt; &quot;hello&quot;) 7.2.2 深入布尔表达式任务一：==相等逻辑判断知识点： 使用**==**来检查逻辑是否相等 对于int、float、bool、str数值和字符串类型，可以用**==**来判断两个变量的值是否相同 对于list、tuple等类型的变量(对象)，并不能通过**==**来判断变量值是否相同 知识点(易错)： =是赋值。将变量设置为=右边的值。例如：a=1 ==是逻辑相等的判断，结果为True或False的布尔值。判断**==两边的变量是否相等。例如，a==b** 可以使用**=**赋值，将逻辑结果赋值给变量 12345678910111213141516#对a和b进行赋值，然后使用a==b判断是否相等a = &#x27;LiLei&#x27;b = &#x27;LiLei&#x27;print(&#x27;&#123;&#125;==&#123;&#125;: &#123;&#125;&#x27;.format(a,b,a==b))# 将a==b的结果赋值给resres = a==b# 建议加括号，避免出错res = (a==b)print(type(res), res)a = &#x27;LiLei&#x27;b = &#x27;LiLei&#x27;# 将逻辑判断用于if判断if a==b: print(&#x27;相等&#x27;) 知识点：如果字符串的大小写无关紧要，而只想检查变量的值，可将字符串统一转换为小写，再比较 1234a = &#x27;LiLei&#x27;b = &#x27;liLei&#x27;res = (a.lower() == b.lower())print(res) 统一大小写后，再作逻辑判断功能很实用 例如，网站可能使用类似的测试来确保用户名是独一无二的，使用上述的==逻辑判断并不能满足这一需求。因此，需要对用户注册的新用户名，首先将把它转换为小写，然后再与数据库中的名字进行比较。如果数据库中存在**’liLei’名字(不管大小写如何)时，则用户名‘LiLei’**系统会提示已经被注册 任务二：!=不等逻辑判断知识点：要判断两个值是否不等，使用**!=(惊叹号和等号)，其中的惊叹号表示不** 1234a = &#x27;LiLei&#x27;# 将!=逻辑判断用于if判断if a!=&#x27;liLei&#x27;: print(&#x27;不相等&#x27;) 代码解析： a!=’liLei’将a的值与字符串**’liLei’**进行比较 如果不相等，将返回True，并执行if语句块 如果这两个值相等，将返回False，不执行if语句块 由于a的值不是**’liLei’，因此执行if语句块print()，输出：不相等** 习题：题目要求： 1、外部输入一个字符串，然后使用if检测当前字符串是否与预设的字符串相等 代码如下： 12345a = &#x27;LiLei&#x27;b = input(&quot;输入字符串:&quot;)res = (a.lower() == b.lower())print(res)#a=4 运行结果： 1false 题目要求： 2、外部输入一个数字，然后，检测当前的数字与预设的数字大小关系 代码如下： 1234a = &#x27;1&#x27;b = input(&quot;输入数字:&quot;)print(&#x27;&#123;&#125;==&#123;&#125;: &#123;&#125;&#x27;.format(a,b,a==b))#b=4 运行结果: 11&#x3D;&#x3D;4: False 题目要求： 3、比较数字的1和字符串的“1”是否相等 123a = &#x27;1&#x27;b = &#x27;&quot;1&quot;&#x27;print(&#x27;&#123;&#125;==&#123;&#125;: &#123;&#125;&#x27;.format(a,b,a==b)) 运行结果： 11&#x3D;&#x3D;&quot;1&quot;: False 任务三：字符串比较大小知识点：字符串比较规则 按双字节Unicode码(类似于ASCII)的排序进行比较，大写字母都在小写字母之前。例如B排在a之前 从左到右的顺序，依次比较字符串中的字符，当出现相同字符时，就比较下个字符，直到结束 12345# 大写排小写之前print(&#x27;Lilei&#x27;&gt;&#x27;lilei&#x27;)# 第1个字符串比第2个多了字符1print(&#x27;Lilei1&#x27;&gt;&#x27;Lilei&#x27;) 知识点：数字和字符串不能比较，出现TypeError 12345678print(&#x27;Lilei1&#x27; &gt; 1)# -----------------------------------------------------------# TypeError Traceback (most recent call last)# &lt;ipython-input-85-bcc8908c4afd&gt; in &lt;module&gt;# ----&gt; 1 print(&#x27;Lilei1&#x27; &gt; 1)# TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; 1234567num = int(input(&#x27;输入数字&#x27;))if (1 &lt;= num) and (num&lt;=100): print(&#x27;哈哈，输入范围正确！&#x27;) print(&#x27;-----在python中，可以作连续比较1 &lt;= num &lt;=100 ----&#x27;)if (1 &lt;= num &lt;=100): print(&#x27;哈哈，输入范围正确！&#x27;) 7.2.3 逻辑运算符任务一：逻辑运算符知识点：使用逻辑运算符来复合多个表达式 在程序开发中，通常在判断条件时，会需要同时判断多个条件 在Python中，逻辑运算符and、or和not可以把多个简单的条件(布尔表达式)按照特定逻辑规则进行连接(组合)，复合成更复杂的判断条件 知识点： and：逻辑与。只有所有布尔表达式都为True，结果才为True or：逻辑或。只要有一个布尔表达式为True，结果就为True not：逻辑非。如果是True，那么结果是False。反之亦然 为改善可读性，建议将每个布尔表达式分别放在**括号()**内 输入一个数字，判断当前数字是否在给定的范围**[1 100]区间之内** 123num = int(input(&#x27;输入数字：&#x27;))if (1 &lt;= num) and (num &lt;= 100): print(&#x27;输入范围正确！&#x27;) 知识点：为了避免复合表达式过于复杂，影响程序的阅读性，建议将复合表达式的结果赋值给临时变量 12345num = int(input(&#x27;输入数字：&#x27;))res = (1 &lt;= num) and (num &lt;= 100)# 程序会变的简洁if res: print(&#x27;输入范围正确！&#x27;) 知识点： Python专属，可以对数值类型的值作连续比较，省去and逻辑运算符 例如，判断数是否在**[1 100]，可以使用1 &lt;= num &lt;=100** 123num = int(input(&#x27;输入数字：&#x27;))if (1 &lt;= num &lt;= 100): print(&#x27;输入范围正确！&#x27;) 输入一个数字，判断当前数字是否在给定的范围**[1 100]区间之外** 123num = int(input(&#x27;输入数字：&#x27;))if (1 &gt; num) or (num &gt; 100): print(&#x27;输入范围正确！&#x27;) 习题：题目要求： 1、定义一个整数变量 age，编写代码判断年龄是否正确。要求人的年龄在 0-120 之间 12345age = 100if age &gt;= 0 and age &lt;= 120: print(&quot;年龄正确&quot;)else: print(&quot;年龄不正确&quot;) 运行结果： 1年龄正确 题目要求： 2、定义两个整数变量 python_score、c_score，编写代码判断成绩。要求只要有一门成绩 &gt; 60 分就算合格 123456python_score = 50c_score = 50if python_score &gt; 60 or c_score &gt; 60: print(&quot;合格&quot;)else: print(&quot;不合格&quot;) 运行结果： 1不合格 题目要求： 3、定义一个布尔型变量 is_employee，编写代码判断是否是本公司员工。如果不是提示不允许入内。提示：使用not运算符 123is_employee = Falseif not is_employee: print(&quot;不允许入内&quot;) 运行结果： 1不允许入内 7.2.4 (重要) in关键字任务一：in检查是否包含某个值知识点：a in b a为变量，b为序列或集合类型的对象 Python提供了关键字in，用于遍历a是否在包含在b中。返回的是True或False 关键字in适用于任何的序列和集合类型的数据，比如str、list、tuple等 1234567891011121314151617# 列表nums = [2, 4, -14, 32, 1]# res 为布尔值res = (2 in nums)print(res) # Trueres = (3 in nums)print(res) # False# 字符串name = &#x27;LiLei&#x27;res = (&#x27;L&#x27; in name)print(res) # True# range()对象res = (1 in range(10))print(res) # True 知识点：a not in b 使用not in来检查a是否不包含在b中 not关键字表示非 1234nums = [2, 4, -14, 32, 1]# res 为布尔值res = (0 not in nums)print(res) # True 任务二：in用于if判断条件知识点：if a in b: a为变量，b为序列或集合类型的对象 in返回的是布尔值，因此可以用于if的判断条件 当a存在于b之中时，a in b这个表达式的值为True，否则为假 12345678#接收外部输入，判断是否在列表中nums = [2, 4, -14, 32, 1]val = int(input(&#x27;输入整数：&#x27;))if val in nums: print(&#x27;&#123;&#125;是列表元素！&#x27;.format(val))# 输入是2，输出是2是列表元素！ 知识点： if a not in b，判断a是否不被b包含 12345678#用户发言前，检查某用户是否在不黑名单中banned_users = [&#x27;zhang san&#x27;, &#x27;li si&#x27;, &#x27;wang wu&#x27;]user = &#x27;Lilei&#x27;if user not in banned_users: print(user.title() + &quot;可以发言.&quot;)# Lilei可以发言. 程序解析：if user not in banned_users: 如果user的值未包含在列表banned_users中，Python将返回True，并执行语句块 用户**’Lilei’未包含在列表banned_users中，因此输出消息：Lilei可以发言.** 任务三：in用于for循环遍历元素知识点：for a in b: 其中a为临时变量，b为序列或集合类型的对象(可迭代对象) 将in用于for循环，表示从b中逐个取元素，放到a临时变量中 当b中的元素取完，循环结束 注意：Python中没有for a not in b 1234nums = [2, 4, -14, 32, 1]for val in nums: print(val, end=&#x27; &#x27;)# 2 4 -14 32 1 习题：题目要求： 5-2 更多的条件测试： 编写布尔表达式(if判断条件)，然后对其结果进行True和False的测试。 检查两个字符串相等和不等 使用函数**lower()**的测试 检查两个数字相等、不等、大于、小于、大于等于和小于等于 使用关键字and和or的测试 测试特定的值是否包含在列表中 测试特定的值是否未包含在列表中 代码如下： 123456789a=1print(&quot;Is a=1? Ture&quot;)print(a==1)b=&quot;A&quot;print(b.lower()==&quot;a&quot;)print(b.lower()==&quot;a&quot; and a==1)print(b.lower()==&quot;a&quot; or a==2) 运行结果： 12345Is a&#x3D;1? TureTrueTrueTrueTrue 7.3 进阶if语句7.3.1 实例：二次方程求解任务一：二次方程求解123456789101112131415161718# 为了求开方，需要导入math数学模块import math# 一元二次方程求解函数def solver(a, b, c): print(&quot;求解一元二次方程的根(实数)\\n&quot;) # 对着公式理解程序 discRoot = math.sqrt(b * b - 4 * a * c) root1 = (-b + discRoot) / (2 * a) root2 = (-b - discRoot) / (2 * a) print(&quot;根为:&quot;, root1, root2)a = float(input(&quot;输入 a: &quot;))b = float(input(&quot;输入 b: &quot;))c = float(input(&quot;输入 c: &quot;))solver(a, b, c) 程序解析： 输入a=1,b=2,c=-3，此时二次方程有实根，程序输出的解 输入a=1,b=2,c=3，此时二次方程无实根，程序奔溃，触发ValueError: math domain error 程序奔溃的原因是当b²-4ac&lt;0时，程序试图对负数进行开方，所以math模块报告错误 任务二：使用if-else语句解决程序奔溃问题为解决上述问题，需要使用if语句来对b²-4ac是否大于0进行判断 123456789101112131415161718# 一元二次方程求解函数def solver(a, b, c): print(&quot;求解一元二次方程的根(实数)\\n&quot;) discrim = b * b - 4 * a * c if discrim &lt; 0: print(&quot;无实根&quot;) else: discRoot = math.sqrt(discrim) root1 = (-b + discRoot) / (2 * a) root2 = (-b - discRoot) / (2 * a) print(&quot;根为:&quot;, root1, root2)a = float(input(&quot;输入 a: &quot;))b = float(input(&quot;输入 b: &quot;))c = float(input(&quot;输入 c: &quot;))solver(a, b, c) 程序解析： 这个版本首先计算判别式的值，再if语句检查并确保它不是负数 如果discrim为负数，该程序永远不会尝试调用**math.sqrt()**进而避免了程序奔溃 该版本的二次方程求解程序解决了因为平方根为负导致程序奔溃问题，然而输入a=1,b=2,c=1时，程序输出为根为: -1.0 -1.0。相同的根，重复输出 任务三：嵌套if-else语句实现多路分支为解决上述相同的根，重复输出问题，可以使用嵌套if-else语句来实现多路分支 12345678910111213141516171819202122# 一元二次方程求解函数def solver(a, b, c): print(&quot;求解一元二次方程的根(实数)\\n&quot;) discrim = b * b - 4 * a * c if discrim &lt; 0: print(&quot;无实根&quot;) else: if discrim == 0: root= -b / (2 * a) print(&quot;单个根为:&quot;, root) else: discRoot = math.sqrt(discrim) root1 = (-b + discRoot) / (2 * a) root2 = (-b - discRoot) / (2 * a) print(&quot;两个根为:&quot;, root1, root2)a = float(input(&quot;输入 a: &quot;))b = float(input(&quot;输入 b: &quot;))c = float(input(&quot;输入 c: &quot;))solver(a, b, c) 程序解析： 使用了两个嵌套的if-else语句，根据discrim实现了3路分支，巧妙的满足了二次方程的无根、重根、和两个根的需求 然而，如果程序需要5路分支，那要嵌套多少个if-else语句？结果肯定是非常繁琐。在下节，将介绍Python的if-elif-else语句来解决此问题 7.3.2 if-elif-else语句任务一：掌握if-elif-else语句需求分析： 在开发中，使用 if 可以处理判断条件成立的情况 使用 else 可以处理条件不成立的情况 如果希望程序处理更复杂的情况，需要增加一些额外的条件，而不同的条件会执行不同的代码块，Python提供了 elif语句 为解决多路分支的判断，Python提供了if-elif-else语句，语法如下： 123456789if &lt;condition1&gt;: &lt;case1 statement&gt;elif &lt;condition2&gt;: &lt;case2 statement&gt;elif &lt;condition3&gt;: &lt;case3 statement&gt;...else: &lt;default statement&gt; 知识点：if-elif-else语句实现n路分支 if和elif分支：按顺序依次检查，执行首次满足条件的，执行完后直接结束整个if-elif-else语句，后续语句不会被执行 else分支：如果没有一个为True，则执行else的else分支是可选的。如果省略else分支，那么当不满足任何条件时，程序会跳出if语句 知识点： if-elif-else语句只执行首次条件为True的，剩余的条件语句块都不被执行。即使下面某个分支条件也为True，它的语句块也不会被执行 elif 和 else 都必须和 if 联合使用，而不能单独使用 可以将 if、elif 和 else 以及各自缩进的代码，看成一个 完整的代码块 任务二：对比逻辑运算符知识点： 逻辑运算符，对多个条件按特定逻辑进行复合为更复杂的条件 相对于if-elif-else语句，逻辑运算符的复合条件会共享同一个代码块 123if 条件1 and 条件2: 条件1满足 并且 条件2满足 执行的代码 …… 任务三：输入数字实现多路判断123456789a = int(input(&#x27;输入数字：&#x27;))if a &gt; 5: print(&#x27;a &gt; 5: &#x27;, a)elif a &gt; 3: print(&#x27;a &gt; 3: &#x27;, a)else: print(&#x27;else:&#x27;, a)print(&#x27;if语句之外&#x27;) 程序解析：if-elif-else控制结构 当输入a=10，程序首先检查if a &gt; 5，满足条件，则执行该条件下的语句，输出a &gt; 5: 10，并跳出剩余的语句块。虽然elif a &gt; 3也满足，程序不执行该条件下的语句 当输入a=4，程序首先检查if a &gt; 5，不满足条件；依次再检查elif a &gt; 3，满足条件，则执行该条件下的语句，输出a &gt; 3: 4，并跳出剩余的语句块 当输入a=1，程序首先检查if a &gt; 5，不满足条件；依次再检查elif a &gt; 3，不满足条件；此时所有条件都不满足，则程序执行else的语句块 对于a=10，同时满足两个条件，虽然程序只执行了第一个条件，但是该程序设计的逻辑上出现了歧义，因此在实际程序设计中，避免条件有交集情况 知识点： 建议每个都是互斥的，即它们的交集为空 如果条件不互斥，容易出现逻辑上的歧义 7.3.3 elif演练任务一：女友的节日需求分析： 如果是 情人节 应该 买玫瑰／看电影 如果是 平安夜 应该 买苹果／吃大餐 如果是 生日 应该 买蛋糕 其他的日子每天都是节日啊…… 定义 holiday_name 字符串变量记录节日名称 123456789101112holiday_name = &quot;平安夜&quot;if holiday_name == &quot;情人节&quot;: print(&quot;买玫瑰&quot;) print(&quot;看电影&quot;)elif holiday_name == &quot;平安夜&quot;: print(&quot;买苹果&quot;) print(&quot;吃大餐&quot;)elif holiday_name == &quot;生日&quot;: print(&quot;买蛋糕&quot;)else: print(&quot;每天都是节日啊……&quot;) 任务二：游乐场门票在现实世界中，很多情况下需要考虑的情形都超过两个。例如，来看一个根据年龄段收费的游乐场： 4岁以下免费 4~18岁收费5元 18~65岁收费10元 65岁(含)收费5元 下面的代码确定一个人所属的年龄段，并打印一条包含门票价格的消息： 123456789101112# 门票票价age = int(input(&quot;输入年龄：&quot;))if 0 &lt;= age &lt; 4: price = 0elif 4 &lt;= age &lt; 18: price = 5elif 18 &lt;= age &lt; 65: price = 10else: price = 5print(&quot;票价为：&#123;&#125; 元！&quot;.format(price)) 知识点： Python并不要求if-elif结构后面必须有else代码块 else是一条包罗万象的语句，只要不满足if-elif条件的任意情况，就会执行else分支的代码，这容易导致有些程序逻辑流程变的不可控。所以在使用else分支时，一定要仔细检查该分支的各种情况 建议初学者if-elif-else语句，检查执行每个分支所需要满足的条件 123456789101112# 门票票价age = int(input(&quot;输入年龄：&quot;))if 0 &lt;= age &lt; 4: price = 0elif 4 &lt;= age &lt; 18: price = 5elif 18 &lt;= age &lt; 65: price = 10 elif 65 &lt;= age: #将else改为elif逻辑更清晰 price = 5print(&quot;票价为：&#123;&#125; 元！&quot;.format(price)) 任务三：二次方程的求解之前使用了两个嵌套的if-else语句，实现了3路分支，巧妙的满足了二次方程的无根、重根、和两个根的需求。在本节，将使用if-elif-else语句来实现3路分支。相对于嵌套if-else语句，if-elif-else语句逻辑结构简明和清晰，不易出错 12345678910111213141516171819202122# 一元二次方程求解函数def solver(a, b, c): print(&quot;求解一元二次方程的根(实数)\\n&quot;) discrim = b * b - 4 * a * c # 3路分支，相对嵌套if-else逻辑更清晰 if discrim &lt; 0: print(&quot;无实根&quot;) elif discrim == 0: root = -b / (2 * a) print(&quot;单个根为:&quot;, root) else: discRoot = math.sqrt(discrim) root1 = (-b + discRoot) / (2 * a) root2 = (-b - discRoot) / (2 * a) print(&quot;两个根为:&quot;, root1, root2)a = float(input(&quot;输入 a: &quot;))b = float(input(&quot;输入 b: &quot;))c = float(input(&quot;输入 c: &quot;))solver(a, b, c) 7.3.4 深入if嵌套任务一：elif和if嵌套的应用场景知识点： elif语句：并联结构。同时判断多个条件，所有的条件是平级的 if嵌套语句：串联结构。在上个条件满足的前提下，再增加额外if判断 知识点： 在开发中，使用 if 进行条件判断，如果希望在条件成立的执行语句中再增加条件判断，就可以使用if嵌套语句 if嵌套的语法格式，除了在前一级的if代码块中缩进之外和if语句没有区别 if嵌套的语法格式如下： 12345678910111213141516if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理else: 条件1 不满足时，执行的代码 …… 任务二：火车站安检需求分析：**(仔细看需求后，再思考程序结构)** 1、定义布尔型变量 has_ticket 表示是否有车票 2、定义整型变量 knife_length 表示刀的长度，单位：厘米 3、首先检查是否有车票，如果有，才允许进行 安检 4、安检时，需要检查刀的长度，判断是否超过 20 厘米 如果超过 20 厘米，提示刀的长度，不允许上车 如果不超过 20 厘米，安检通过 5、如果没有车票，不允许进门 注意：if嵌套语句块的层级缩进 1234567891011121314151617181920# 定义布尔型变量 has_ticket 表示是否有车票has_ticket = True# 定义整数型变量 knife_length 表示刀的长度，单位：厘米knife_length = 20# 首先检查是否有车票，如果有，才允许进行 安检if has_ticket: print(&quot;有车票，可以开始安检...&quot;) # 安检时，需要检查刀的长度，判断是否超过 20 厘米 # 如果超过 20 厘米，提示刀的长度，不允许上车 if knife_length &gt;= 20: print(&quot;不允许携带 %d 厘米长的刀上车&quot; % knife_length) # 如果不超过 20 厘米，安检通过 else: print(&quot;安检通过，祝您旅途愉快……&quot;)# 如果没有车票，不允许进门else: print(&quot;大哥，您要先买票啊&quot;) 7.3.5 一个还是多个if语句?任务一：何时使用一个或多个if语句知识点： 这里，将整个if-elif-else控制结构称为一个if语句 如果多个条件只需要满足一个，请使用一个if语句 if-elif-else结构功能强大，一系列的条件只需要一个满足的场景 即当满足任意一个条件后，Python就跳过剩余的条件 多个条件相互独立，需要每个都被测试，请使用多个独立的if语句 如果每个条件都需要被检查是否满足，那么一个if-elif-else语句就不能满足这个需求了 这时就需要用使用多个if语句，来分别检查每个条件是否满足 任务二：多个if语句检测多个条件下面再来看前面比萨店示例。如果顾客点了两种配料，就需要确保在比萨中包含这些配料： 123456789101112requested_toppings = [&#x27;mushrooms&#x27;, &#x27;cheese&#x27;]if &#x27;mushrooms&#x27; not in requested_toppings: print(&quot;Adding mushrooms.&quot;) if &#x27;pepperoni&#x27; in requested_toppings: print(&quot;Adding pepperoni.&quot;) if &#x27;extra cheese&#x27; in requested_toppings: print(&quot;Adding extra cheese.&quot;)print(&quot;\\nFinished making your pizza!&quot;) 程序解析： 首先创建了一个列表requested_toppings，其中包含顾客点的配料 if &#39;mushrooms&#39; not in requested_toppings:语句检查是否点了配料蘑菇&#39;mushrooms&#39;，如果点了，就打印一条确认消息 if &#39;pepperoni&#39; in requested_toppings:语句检查配料是否加了辣香肠&#39;pepperoni&#39;，这里使用一个简单的if语句，而不是elif或else语句；因此不管前一个测试是否通过，都将进行执行这个判断条件 if &#39;extra cheese&#39; in requested_toppings:语句检查是否要求多加芝士&#39;extra cheese&#39;；这里也不管前面两个if语句的结果，都会执行这个if语句代码 在这个例子中，程序会独立地检查每个判断条件 任务三：一个if语句不能检测多个条件如果像下面这样转而使用if-elif-else结构，代码将不能正确地运行，因为有一个测试通过后，就会跳过余下的测试： 12345678910requested_toppings = [&#x27;mushrooms&#x27;, &#x27;extra cheese&#x27;]if &#x27;mushrooms&#x27; in requested_toppings: print(&quot;Adding mushrooms.&quot;)elif &#x27;pepperoni&#x27; in requested_toppings: print(&quot;Adding pepperoni.&quot;)elif &#x27;extra cheese&#x27; in requested_toppings: print(&quot;Adding extra cheese.&quot;)print(&quot;\\nFinished making your pizza!&quot;) 程序解析： 第一个条件**if ‘mushrooms’ in requested_toppings:，检查列表中是否包含‘mushrooms’**，它通过了，因此将在比萨中添加蘑菇 此时，Python会跳过if-elif-else结构的剩余条件，不再检查列表中是否包含**’extra cheese’和‘pepperoni’** 其结果是，只添加了顾客点的第一种配料，但不会添加其他的配料 总之，如果你只想执行一个代码块，就使用if-elif-else结构；如果要运行多个代码块，就使用一系列独立的if语句 习题：题目要求： 5-3 外星人颜色#1：假设在游戏中刚射杀了一个外星人，请创建一个名为alien_color的变量，并将其设置为**’green’、‘yellow’或‘red’** 编写一条if语句，检查外星人是否是绿色的；如果是，就打印一条消息，指出玩家获得了5个点 编写这个程序的两个版本，在一个版本中上述测试通过了，而在另一个版本中未通过（未通过测试时没有输出） 代码如下： 123alien_color = [&#x27;green&#x27;]if &#x27;green&#x27;in alien_color: print(&quot;The player get 5 points&quot;) 123alien_color = [ &#x27;yellow&#x27;, ]if &#x27;green&#x27; in alien_color: print(&quot;The player get 5 points&quot;) 运行结果： 1The player get 5 points 1234567891011121314151617181920&#96;&#96;&#96;题目要求：**5-4 外星人颜色#2**：像练习5-3那样设置外星人的颜色，并编写一个**if-else**结构如果外星人是绿色的，就打印一条消息，指出玩家因射杀该外星人获得了5个点如果外星人不是绿色的，就打印一条消息，指出玩家获得了10个点编写这个程序的两个版本，在一个版本中执行**if**代码块，而在另一个版本中执行**else**代码块。代码如下：&#96;&#96;&#96;pythonalien_color &#x3D; [&#39;green&#39;]if &#39;green&#39; in alien_color: print(&quot;The player get 5 points&quot;)else: print(&quot;The player get 10 points&quot;) 12345alien_color = [&#x27;green&#x27;]if &#x27;red&#x27; in alien_color: print(&quot;The player get 5 points&quot;)else: print(&quot;The player get 10 points&quot;) 运行结果： 1The player get 5 points 1The player get 10 points 题目要求： 5-5 外星人颜色#3：将练习5-4中的if-else结构改为if-elif-else结构 如果外星人是绿色的，就打印一条消息，指出玩家获得了5个点 如果外星人是黄色的，就打印一条消息，指出玩家获得了10个点 如果外星人是红色的，就打印一条消息，指出玩家获得了15个点 编写这个程序的三个版本，它们分别在外星人为绿色、黄色和红色时打印一条消息 代码如下： 1234567alien_color = [&#x27;green&#x27;]if &#x27;green&#x27; in alien_color: print(&quot;The player get 5 points&quot;)elif &#x27;yellow&#x27; in alien_color: print(&quot;The player get 10 points&quot;)else: print(&quot;The player get 15 points&quot;) 运行结果： 1The player get 5 points 题目要求： 5-6 人生的不同阶段：设置变量age的值，再编写一个if-elif-else结构，根据age的值判断处于人生的哪个阶段 如果一个人的年龄小于2岁，就打印一条消息，指出他是婴儿 如果一个人的年龄为2（含）～4岁，就打印一条消息，指出他正蹒跚学步 如果一个人的年龄为4（含）～13岁，就打印一条消息，指出他是儿童 如果一个人的年龄为13（含）～20岁，就打印一条消息，指出他是青少年 如果一个人的年龄为20（含）～65岁，就打印一条消息，指出他是成年人 如果一个人的年龄超过65（含）岁，就打印一条消息，指出他是老年人 代码如下： 123456789101112131415age = 18if age &lt; 2 : string = &#x27;baby&#x27;if 2&lt; age &lt; 4 : string = &#x27;toddler&#x27;if 4 &lt;= age &lt; 13 : string = &#x27;children&#x27;if 13 &lt;= age &lt;20 : string = &#x27;teenager&#x27;if 20 &lt;= age &lt; 65 : string = &#x27;adult&#x27;if 65&lt;= age : string = &#x27;older&#x27;print(&quot;He is a &quot; + str(string) +&quot;.&quot;) 运行结果： 1He is a teenager. 题目要求： 5-7 喜欢的水果：创建一个列表，其中包含你喜欢的水果，再编写一系列独立的if语句，检查列表中是否包含特定的水果 将该列表命名为favorite_fruits，并在其中包含三种水果 编写5条if语句，每条都检查某种水果是否包含在列表中，如果包含在列表中，就打印一条消息，如“You really like bananas!” 代码如下： 1234567891011favorite_fruits = [&#x27;banbana&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;grape&#x27;, &#x27;tomato&#x27;]if &#x27;banana&#x27; in favorite_fruits: print(&quot;You really like bananas!&quot;)if &#x27;apple&#x27; in favorite_fruits: print(&quot;You really like apple!&quot;)if &#x27;watermelon&#x27; in favorite_fruits: print(&quot;You really like watermelon!&quot;)if &#x27;grape&#x27; in favorite_fruits: print(&quot;You really like grape!&quot;)if &#x27;pineapple&#x27;in favorite_fruits: print(&quot;You really like pineapple!&quot;) 运行结果： 12You really like apple!You really like grape! 7.4 综合实例：石头剪刀布学习目标： 强化 多个条件 的 逻辑运算 体会 import 导入模块（“工具包”）的使用 需求分析： 1、从控制台输入要出的拳：石头(1)/剪刀(2)/布(3) 2、电脑随机出拳 ：先假定电脑只会出石头，完成整体代码功能。 3、比较胜负 序号 规则 1 石头 胜 剪刀 2 剪刀 胜 布 3 布 胜 石头 任务一：基础代码实现先假定电脑就只会出石头，完成整体代码功能。注意，可以使用**.format()或f-string方式来代替字符串的%**格式化输出 1234567891011121314151617181920212223# 从控制台输入要出的拳 —— 石头(1)/剪刀(2)/布(3)player = int(input(&quot;请出拳 石头(1)/剪刀(2)/布(3)：&quot;))# 电脑 随机 出拳 - 假定电脑永远出石头computer = 1# format方式print(&#x27;玩家:&#123;&#125;，电脑：&#123;&#125;&#x27;.format(player,computer))# f-string方式print(f&#x27;玩家:&#123;player&#125;，电脑：&#123;computer&#125;&#x27;)# 比较胜负# 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号# 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(&quot;噢耶！！！电脑弱爆了！！！&quot;)elif player == computer: print(&quot;心有灵犀，再来一盘！&quot;)else: print(&quot;不行，我要和你决战到天亮！&quot;) 任务二：随机出拳在 Python 中，要使用随机数，首先需要导入随机数的random模块 1import random 导入模块后，可以直接在模块名称后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数。random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 b。例如： 123random.randint(12, 20) # 生成的随机数n: 12 &lt;= n &lt;= 20 random.randint(20, 20) # 结果永远是 20 random.randint(20, 10) # 该语句是错误的，下限必须小于上限 7.5 初识异常处理机制7.5.1 if和try异常处理机制任务一：通过if语句来解决程序异常在二次方程求解程序的例子中，在调用sqrt函数前，使用了if判断结构，避免了负数平方根而引起的程序奔溃。通过设置判断条件，来避免特定的程序错误 123456# 这程序是之前程序的片段，不需要运行discRt = otherSqrt(b*b -4*a*c)if discRt &lt; 0: print(&quot;No real roots.&quot;)else: do something 知识点： 在开发过程中，如果程序发生了错误，开发者可以通过Traceback来追踪错误的发生地和错误的原因 然而，当程序发布给用户之后，如果程序运行发生了错误，程序将会崩溃，而用户是无法通过修改程序来恢复程序正常使用的 另如果为程序的每个环节都设置if判断语句，那么程序将会变的非常复杂 任务二：try异常处理机制为了提高程序的稳定性和健壮性，Python提供了try异常处理机制，帮助解决此类设计问题。异常处理机制允许开发者通过编写一些代码，来捕获和处理程序运行时出现的错误 知识点：try是一个异常处理机制 1234567try: &lt;body&gt;except &lt;ErrorType1&gt;: &lt;handler1&gt;...except: &lt;default handle&gt; 程序在执行中，当遇到try语句时，它尝试执行语句 如果语句发生错误，Python会查找与错误类型相匹配的except错误处理分支 如果找到与之匹配的except :分支，那么就执行错误处理代码块 如果try语句中的语句块没有发生错误，则不会执行任何except错误处理分支 ：Traceback中的错误类型。最常见的except类型是IndexError(索引错误)、ValueError(值错误)、KeyError(键错误)、TypeError类型不匹配等 注意：try-except语句与if-elsif-else语句结构类似 7.5.2 常见的ErrorType任务一：TypeErrorTypeError 通常是由类型不匹配引起的 123456# 会发生TypeErrora = &#x27;hello&#x27;b = a + 1#当发生错误后，该错误之后的语句是不能被执行的print(&#x27;something&#x27;) 123456789# 如果用户输入数字则会触发异常错误a = 1try: b = &#x27;hello&#x27; + aexcept TypeError: print(&#x27;TypeError: &#x27;, TypeError) #当发生错误后，try之后的语句依然能被执行print(&#x27;something&#x27;) 任务二：as关键字提取错误信息知识点： **except TypeError:**只能捕获到错误，但不知道具体的错误。 except TypeError as e:通过as关键字，可以将详细的错误信息提取到变量e中 123456# 如果用户输入数字则会触发异常错误a = 1try: b = &#x27;hello&#x27; + aexcept TypeError as e: print(&#x27;TypeError: &#x27;, repr(e)) 任务三：ValueErrorValueError通常是数值的非法计算，比如对负数开方等 1234import matha = -1math.sqrt(a) 123456a = -1try: math.sqrt(a)except ValueError as e: print(repr(e)) 任务四：ZeroDivisionErrorZeroDivisionError通常是除数为0时发生的错误 1234try: a = 1/0except ZeroDivisionError as e: print(repr(e)) 任务五：IndexErrorIndexError通常是列表或序列类型的索引越界引起的错误 12345li = [1,2,3]try: a = li[4]except IndexError as e: print(repr(e)) 7.5.3 使用异常机制的二次方程任务一：二次方程的异常处理由于二次方程需要调用math.sqrt()，负数的平方根会引起程序异常。之前的程序通过if语句，让程序避免了错误的发生。这里，将使用try机制来实现程序的异常处理 1234567891011121314151617181920212223# 一元二次方程求解函数def solver(a, b, c): print(&quot;求解一元二次方程的根(实数)\\n&quot;) discrim = b * b - 4 * a * c try: if discrim == 0: root = -b / (2 * a) print(&quot;单个根为:&quot;, root) else: # try可以捕获discrim的异常到ValueError discRoot = math.sqrt(discrim) root1 = (-b + discRoot) / (2 * a) root2 = (-b - discRoot) / (2 * a) print(&quot;两个根为:&quot;, root1, root2) except ValueError: print(&quot;无实根&quot;)a = float(input(&quot;输入 a: &quot;))b = float(input(&quot;输入 b: &quot;))c = float(input(&quot;输入 c: &quot;))solver(a, b, c) 7.6 习题题目要求： 1、当每周超出40小时以上的工作时间支付150%的工资。编写程序输入工作小时数和小时工资，并计算一周的总工资 代码如下： 1234567891011121314151617181920class Person(): def __init__(self, wages, hours): self.wages = wages self.hours = hours def get_wages(self): if self.hours &gt; 40: pay = ((40 * self.wages) + (1.5 * self.wages * (self.hours - 40))) print(&quot;Gross pay for week is : $%s&quot; % pay) else: pay = self.wages * self.hours print(&quot;weeks total pay: $%.2f&quot; % pay)wages = float(input(&quot;Enter hourly wage: &quot;))hours = int(input(&quot;Enter numbers of hours worked: &quot;))p = Person(wages, hours)p.get_wages() #wages=5 #hours=5 运行结果： 1weeks total pay: $25.00 题目要求： 2、某位CS教授给出了5分的小测验，评分等级为5-A，4-B，3-C，2-D，1-E，0-F。编写一个程序，接受测验得分作为输入，并使用判断结构来计算相应的等级 代码如下： 1234a=int(input())ls1=&#123;5:&#x27;A&#x27;,4:&#x27;B&#x27;,3:&#x27;C&#x27;,2:&#x27;D&#x27;,1:&#x27;E&#x27;,0:&#x27;F&#x27;&#125;print(ls1[a])#5 运行结果： 1A 题目要求： 3、某位CS教授给出了100分的考试，分级为90～100：A，80～89：B，70～79：C，60～69：D，&lt;60：F。编写一个程序，将考试分数作为输入，并使用判断结构来计算相应的等级 代码如下： 1234567891011def gradeconvert(): gradeLevel = &quot;FDCBA&quot; grade = float(input(&quot;Enter the grade: &quot;)) # 80 gradeLev = int(grade/10 - 5) if gradeLev &lt; 0: print(&quot;The converted grade level is: F&quot;) elif gradeLev == len(gradeLevel): print(&quot;The converted grade level is: A&quot;) else: print(&quot;The converted grade level is: &quot;, gradeLevel[gradeLev])gradeconvert() 运行结果： 1The converted grade level is: B 题目要求： 4、某所大学根据学生拿到的学分对学生分年级。小于7学分的学生是大一新生。至少有7个学分才是大二，16分以上是大三，26分以上是大四。编写一个程序，根据获得的学分数计算年级 代码如下： 12345678910111213credit = eval(input(&quot;请输入学分：&quot;))if credit &lt; 7 : string = &#x27;大一新生&#x27;if 7 &lt;= credit &lt; 16 : string = &#x27;大二学生&#x27;if 16 &lt;= credit &lt;26 : string = &#x27;大三学生&#x27;if credit &gt;= 26 : string = &#x27;大四学生&#x27;print(&quot;这是一名&quot; + str(string) +&quot;。&quot;)#5 运行结果： 12这是一名大一新生。 题目要求： 5、身体质量指数（BMI）的计算公式是人的体重（以磅计）乘以720，再除以人的身高（以英寸计）的平方。BMI在19～25范围内（包括边界值）被认为是健康的。编写一个程序，计算人的BMI，并打印一条消息，告诉他们是在健康范围之上、之中还是之下 代码如下： 123456789101112height = eval((input(&quot;请输入你的身高(m)：&quot;)))weight =eval((input(&quot;请输入你的体重(kg)：&quot;)))BMI = weight / pow(height,2)if BMI &lt; 19: print(&quot;健康范围之下&quot;)elif (BMI &gt;= 19 and BMI &lt;= 25): print(&quot;健康范围之中&quot;)elif BMI &gt; 25: print(&quot;健康范围之上&quot;) #1.76 #65 运行结果： 1健康范围之中 题目要求： 6、超速罚单政策：300元加上超速部分每mph（一英里每小时）40元，如果超过90mph再追加罚款500元。编写一个程序，接受速度限制和计时速度，并打印一条消息，表明速度合法，或者在速度非法时，打印罚款 123456789101112131415161718192021222324def ask_limit(): limit = float(input (&quot;What was the speed limit? &quot;)) return limitdef ask_speed(): speed = float(input (&quot;What was your clocked speed? &quot;)) return speeddef findfine(speed, limit): if speed &gt; 90: bigfine = ((speed - limit) * 5 + 500) print(&quot;your fine is&quot;, bigfine) elif speed &lt;= limit: print(&quot;you were traveling a legal speed&quot;) else: fine = ((speed - limit) * 40 + 300) print(&quot;your fine is&quot;, fine)def main(): limit = ask_limit() speed = ask_speed() findfine(speed, limit)main()#100#80 运行结果： 1you were traveling a legal speed 题目要求： 7、计算1982～2048年的复活节的计算公式如下：令a = year%19, b = year%4, c = year%7, d = (19a + 24)%30, e = (2b +4c +6d + 5)%7。复活节的日期是3月22日+ d + e（可能在4月）。写一个程序，输入年份，验证它在适当的范围，然后打印出那一年复活节的日期 代码如下： 1234567891011year=int(input())a=year%19b=year%4c=year%7d=(19a + 24)%30e= (2b +4c +6d + 5)%7sum=22+d+e if sum&lt;=31: print(f&#x27;3月&#123;sum&#125;日&#x27;)else print(f&#x27;4月&#123;sum-31&#125;日&#x27;)","categories":[],"tags":[]},{"title":"Python学习笔记6","slug":"Python学习笔记6","date":"2021-06-16T16:28:21.000Z","updated":"2021-06-16T16:29:38.989Z","comments":true,"path":"2021/06/17/py 6.html","link":"","permalink":"http://waxll.top/2021/06/17/py%206.html","excerpt":"","text":"第六章 列表：推导式与切片6.1 (重要) 列表推导式6.1.1 为何要用列表推导式?任务一：生成列表元素为创建一个元素为整数平方项的列表squares，可使用如下方式 12345678#声明空列表squares = []for x in range(10): val = x**2 squares.append(val)print(squares)# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 代码解析： 在for循环中，通过对序列的临时变量x，进行x****2**运算来创建列表的新元素 然后将新元素**append()**到列表中，直到循环结束 上述列表squares创建方式包含至少3行以上的代码 下面介绍的列表推导式只需一行代码就能生成相同的列表 任务二：初识列表推导式知识点：列表推导式的语法 语法：newlist = [expression for expr1 in sequence1 if condition1] expression：生成列表新元素的表达式 for expr1 in sequence1：遍历序列sequence1。必须包含至少一个for语句 if condition1：可选，筛选满足条件的元素 列表推导式中的for语句末尾没有冒号 描述：根据序列sequence1，筛选满足条件的元素，并根据表达式expression，生成新列表 返回：一个新列表。不管原序列是什么类型，返回的是列表list类型 123squares = [x**2 for x in range(10)]print(squares)# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 程序解析(列表推导式规则的角度)： 列表推导式，由一个有**[]**括号所包含的表达式组成，用于定义列表元素生成规则 遍历原序列：for x in range(10) 遍历range(10)序列，并赋值给临时变量x 定义新元素生成的表达式：根据表达式 (x2)，对x实现运算操作来生成新列表元素 自动添加元素：将新元素添加到列表中 squares类型为list对象 任务三：列表推导式的等价形式知识点：列表推导式和普通代码的逻辑等价 列表推导式：newlist = [expression for expr1 in sequence1 if condition1] 等价的普通代码： 12345newlist = []for expr1 in sequence1: if condition1: val = expression newlist.append(val) 列表推导式为从序列中生成新元素来创建列表提供了一个优雅且简明的方法。代码简洁，可读性强，是Python程序开发时应用最多的技术之一 任务四：函数映射角度来理解列表推导式知识点：函数映射角度来理解列表推导式： 定义域：序列sequence1 函数映射：特定的表达式规则**(expression)** 值域：新的列表newlist 123squares = [x**2 for x in range(10)]print(squares)# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 程序解析(函数映射的角度)： 定义域：序列range(10) 函数映射：表达式x**2 值域：新列表squares 6.1.2 深入列表推导式用法任务一：再识列表推导式知识点：列表推导式(list comprehension) 语法：newlist = [expression for expr1 in sequence1 if condition1] 又称列表解析式，它对序列或可迭代对象进行遍历(for)、过滤(if)或计算(expression)，来生成新列表 简单地说：列表推导式将for循环和创建新元素的规则合并成一行，并自动实现元素的添加 任务二：使用带if条件的列表推导式生成一个aList列表，它的元素是nums列表中，元素值大于3的元素平方项。 通过if从nums列表中选择符合条件的元素来组成新的列表 12345678910# 普通版本nums = [10, -2, 13, 4, 25]aList = []for x in nums: if x &gt; 3: aList.append(x * x)print(aList)# [100, 169, 16, 625] 12345# 推导式版本nums = [10, -2, 13, 4, 25]aList = [x * x for x in nums if x &gt; 3]print(aList)# [100, 169, 16, 625] 任务三：二重循环的列表推导式知识点：嵌套的列表推导式理解 列表推导式包含一个由中括号**[]**组成的表达式。 表达式之后紧跟一个 for循环，之后可以嵌套有零或多个 for或 if语句。 嵌套的多个for或if语句，按从左到右的顺序(外层语句块到内层语句块)来解读代码 生成一个aList列表，它的元素是二维列表nums中，元素值大于0的元素 123456789101112# 普通版本nums = [[1,-2,3],[4,5,-6],[7,-8,9]]aList = []# 二维数组，先遍历行，后遍历列for row in nums: for col in row: # 选择&gt;0的元素 if col &gt; 0: aList.append(col)print(aList)# [1, 3, 4, 5, 7, 9] 1234nums = [[1, -2, 3], [4, 5, -6], [7, -8, 9]]aList = [col for row in nums for col in row if col &gt; 0]print(aList)# [1, 3, 4, 5, 7, 9] 知识点： 注意列表推导式中的for和if语句的顺序 列表推导式中，省略了**:**冒号 任务四：多个列表同时遍历的列表推导式两个列表num1和num2，生成的新列表元素为num1和num2中元素值不同的成对元素组合 12345678910# 普通版本(外层与内层语句块注意缩进)aList = []num1 = [1, 2, 3, 5]num2 = [3, 1, 4, 3]for x in num1: for y in num2: if x != y: aList.append((x, y))print(aList)# [(1, 3), (1, 4), (1, 3), (2, 3), (2, 1), (2, 4), (2, 3), (3, 1), (3, 4), (5, 3), (5, 1), (5, 4), (5, 3)] (x,y)为元组，它是不可变列表，后面章节会学到 12345num1 = [1, 2, 3, 5]num2 = [3, 1, 4, 3]aList = [(x, y) for x in num1 for y in num2 if x != y]print(aList)# [(1, 3), (1, 4), (1, 3), (2, 3), (2, 1), (2, 4), (2, 3), (3, 1), (3, 4), (5, 3), (5, 1), (5, 4), (5, 3)] 任务五：调用函数的列表推导式列表推导式中可以调用函数 定义函数f：若v能被2整除，则返回v的平方，不能被2整除，返回v+1。具体的函数定义会在后续章节详细讲解 123456def f(v): if v % 2 == 0: # 被2整除 v = v**2 else: v = v + 1 return v 先运行**f(v)**函数的cell 1234567891011# 普通版本nums = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]aList = []# 二维数组，先遍历行，后遍历列for row in nums: for col in row: #调用函数，需要先运行前面的cell aList.append(f(col))print(aList)# [2, 4, 4, 16, 6, 36, 8, 64, 10] 1234nums = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]aList = [f(col) for row in nums for col in row]print(aList)# [2, 4, 4, 16, 6, 36, 8, 64, 10] 任务六：列表推导式的嵌套12345nums = [1, 2, 3]# [x**2 for x in nums]为内层推导式aList = [x + 1 for x in [x**2 for x in nums]]print(aList)# [2, 5, 10] 123456nums = [1, 2, 3]# 将嵌套的推导式进行等价分解tempList = [x**2 for x in nums]aList = [x + 1 for x in tempList]print(aList)# [2, 5, 10] 习题：1、用列表推导式的方法，把列表**[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]**中的每个元素都加100，生成一个新列表 1234list =[]for i in range(0,10): list.append(i+100)print(list) 1[100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 2、用列表推导式生成1-20000之间所有能被3整除不能被5整除的数 12numbers = [x for x in range(1,20001) if x%3==0 and x%5!=0]print(numbers) 3、用列表推导式生成列表：**[[0,0,0,0,0],[0,1,2,3,4],[0,2,4,6,8],[0,3,6,9,12]]** 12345list = [[0,0,0,0,0]]list.append([x for x in range(0,5) if x%1==0])list.append([x for x in range(0,9) if x%2==0])list.append([x for x in range(0,13) if x%3==0])print(list) 1[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8], [0, 3, 6, 9, 12]] 4、3的倍数：创建一个列表，其中包含3~30内能被3整除的数字；再使用一个for循环将这个列表中的数字都打印出来 123numbers = list(range(3, 31, 3))for number in numbers: print(number) 1234567891036912151821242730 5、立方：将同一个数字乘三次称为立方。例如，在Python中，2的立方用2**3表示。请创建一个列表，其中包含前10个整数（即1~10）的立方，再使用一个for循环将这些立方数都打印出来 12345numbers = []for value in range(1, 11): numbers.append(value ** 3)for number in numbers: print(number) 123456789101827641252163435127291000 6、立方解析：使用列表解析生成一个列表，其中包含前10个整数的立方 12numbers = [value ** 3 for value in range(1,11)]print(numbers) 1[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] 6.2 切片：列表索引6.2.1 切片的定义任务一：初识切片知识点：切片(slide)用于获取列表片段 之前学习了如何使用通过索引来访问列表的单个元素。比如：x[0] 在实际应用中，经常需要访问列表的片段或子集 为此，Python专门设计了切片技术来实现列表元素的一次性批量访问 str字符串、list列表、tupple元组、ndarray多维数组等都支持切片操作 知识点：切片语法 语法：x[start:stop:step] 描述：从列表x中获得子列表，索引范围为**[start stop)左闭右开区间，步长为step** 参数：3个参数必须是整数(包括负整数) start为起始索引，默认值为0 stop为终止索引，默认值为len(x) step为步长，默认值为1。不能为0，否则会出错 返回：子列表。从start开始到stop，但不包括stop元素 123456x = [1, 4, 2, 5, -1, 4, 9, 10]# 从索引0开始，到索引3为止，步长为1x_sub = x[0:4:1]print(&#x27;x[0:4:1]：&#x27;, x_sub)# x[0:4:1]： [1, 4, 2, 5] 任务二：切片不包含stop元素知识点：常见的逻辑错误(坑) 切片返回的子列表，不包括stop索引元素 例如：x[0:3:1]，返回的子列表元素为x[0]，x[1]，x[2]，但不包括x[3] 12345678x = [1, 4, 2, 5, -1, 4, 9, 10]# 切片不包括stop=4的索引元素x_sub = x[0:4:1]print(&#x27;x[0:4:1]：&#x27;, x_sub)print(&#x27;x[4]：&#x27;, x[4])# x[0:4:1]： [1, 4, 2, 5]# x[4]： -1 6.2.2 (重要) 深入切片任务一：掌握切片常见用法知识点：切片的理解 切片的用法与**range(start:stop:step)**类似，3个参数的意义也类似 可以这么理解切片：首先使用range(start:stop:step)生成一组列表元素的索引。然后，再应用于列表x，来获得索引范围为**[start, stop)**的子列表 切片使用较灵活，具体包括如下几种情况： 情况1： 三个参数x[start:stop:step]，包含两个: 这是完整的切片表达式 两个:用于分隔三个参数(start、stop、step) 12345x = [1, 4, 2, 5, -1, 4, 9, 10]# 3个参数，2个：x_sub = x[0:4:2]print(&#x27;x[0:4:2]：&#x27;, x_sub)# x[0:4:2]： [1, 2] 情况2：两个参数x[start:stop]，包含一个: 默认值步长step=1 等价于x[start:stop:1] 1234567891011x = [1, 4, 2, 5, -1, 4, 9, 10]# 2个参数，1个：x_sub = x[0:4]print(&#x27;x[0:4]&#x27;, x_sub)# x[0:4] [1, 4, 2, 5]# 等价于step=1的3参数x_sub = x[0:4:1]print(&#x27;x[0:4:1]&#x27;, x_sub)# x[0:4:1] [1, 4, 2, 5] 情况3.1：一个参数x[start:]，包含一个: 此时，默认值stop=len(x)，表示切片的终止于列表末尾。默认值步长step=1 等价于x[start:len(x):1] 12345678910x = [1, 4, 2, 5, -1, 4, 9, 10]# 1个参数，1个：x_sub = x[3:]print(&#x27;x[3:]&#x27;, x_sub)# x[3:] [5, -1, 4, 9, 10]# 等价于stop=start+1，step=1的3参数x_sub = x[3:len(x):1]print(&#x27;x[3:len(x):1]&#x27;, x_sub)# x[3:len(x):1] [5, -1, 4, 9, 10] 情况3.2****：一个参数x[:stop]，包含一个: 此时，默认值start=0，表示切片的起始为0。默认值步长step=1 等价于x[0:stop:1] 12345678910x = [1, 4, 2, 5, -1, 4, 9, 10]# 1个参数，1个：x_sub = x[:3]print(&#x27;x[:3]&#x27;, x_sub)# x[:3] [1, 4, 2]# 等价于start=0，step=1的3参数x_sub = x[0:3:1]print(&#x27;x[0:3:1]&#x27;, x_sub)# x[0:3:1] [1, 4, 2] 情况4：一个参数x[start]，没有: 退化为单索引 此时，stop=start+1，表示切取start指定的那个元素。默认值步长step=1 等价于x[start:start+1:1] 12345678910x = [1, 4, 2, 5, -1, 4, 9, 10]# 1个参数，没有：x_sub = x[3]print(&#x27;x[3]&#x27;, x_sub)# x[3] 5# 等价于stop=start+1=4，step=1的3参数x_sub = x[3:4:1]print(&#x27;x[3:4:1]&#x27;, x_sub)# x[3:4:1] [5] 情况5：没有参数，x[::]或x[:] 如果以上3个参数都未指定，那么它们会被设置默认值：start=0、stop=len(x)和 step=1 此时，为返回的子列表为x本身 等价于x[start=0:len(x):1] 功能：复制列表x 123456789101112131415x = [1, 4, 2, 5, -1, 4, 9, 10]# 0个参数，1个：x_sub = x[:]print(&#x27;x[:]&#x27;, x_sub)# x[:] [1, 4, 2, 5, -1, 4, 9, 10]# 0个参数，2个：x_sub = x[::]print(&#x27;x[::]&#x27;, x_sub)# x[::] [1, 4, 2, 5, -1, 4, 9, 10]# 等价于x[start=0:len(x):1]x_sub = x[0:len(x):1]print(&#x27;x[0:len(x):1]&#x27;, x_sub)# x[0:len(x):1] [1, 4, 2, 5, -1, 4, 9, 10] 6.2.3 参数缺省的切片任务一：掌握参数缺省的切片使用知识点： 当step&gt;0时为正序，索引可以从正数的0开始从左向右(正序) 当step&lt;0时为逆序，从负数的-1开始从右向左(逆序) 知识点(总结)：参数缺省的切片 x[start:stop]：缺省step=1 x[start:]：缺省stop=len(x)，step=1 x[:stop]：缺省start=0，step=1 **x[:stop:step]**： 当step&gt;0正序，缺省start=0 当step&lt;0逆序，缺省start=len(x) **x[start::step]**： 当step&gt;1正序，缺省stop=len(x) 当step&lt;1逆序，缺省stop=-len(x)-1 了解：逆序最后个元素为**-len(x)(即列表第1个元素)，由于切片返回的子列表不包括stop元素。因此，为了获得逆序最后个元素，需要设置stop=-len(x)-1** x[:]和x[::]：缺省start=0，stop=len(x)，step=1。相当于复制列表x 1234567x = [1, 4, 2, 5, -1, 4, 9, 10]print(&#x27;x[1:4]：&#x27;, x[1:4])# x[1:4]： [4, 2, 5]# x[start:stop]：缺省step=1。print(&#x27;x[1:4:1]：&#x27;, x[1:4:1])# x[1:4:1]： [4, 2, 5] 1234567x = [1, 4, 2, 5, -1, 4, 9, 10]print(&#x27;x[1:]：&#x27;, x[1:])# x[1:]： [4, 2, 5, -1, 4, 9, 10]# x[start:]：缺省stop=len(x)，step=1。print(&#x27;x[1:len(x):1]：&#x27;, x[1:len(x):1])# x[1:len(x):1]： [4, 2, 5, -1, 4, 9, 10] 1234567x = [1, 4, 2, 5, -1, 4, 9, 10]#x[:stop]：缺省start=0，step=1。print(&#x27;x[:4]：&#x27;, x[:4])# x[:4]： [1, 4, 2, 5]print(&#x27;x[0:4:1]：&#x27;, x[0:4:1])# x[0:4:1]： [1, 4, 2, 5] 123456789101112x = [1, 4, 2, 5, -1, 4, 9, 10]#x[:stop:step]：当step&gt;1正序，缺省start=0；print(&#x27;x[:4:2]&#x27;, x[:4:2])print(&#x27;x[0:4:2]&#x27;, x[0:4:2])# x[:4:2] [1, 2]# x[0:4:2] [1, 2]#x[:stop:step]：当step&lt;1逆序，缺省start=len(x)；print(&#x27;x[:4:-2]&#x27;, x[:4:-2])print(&#x27;x[len(x):4:-2]&#x27;, x[len(x):4:-2])# x[:4:-2] [10, 4]# x[len(x):4:-2] [10, 4] 12345678910111213x = [1, 4, 2, 5, -1, 4, 9, 10]#x[start::step]：当step&gt;1正序，缺省stop=len(x)；print(&#x27;x[1::2]&#x27;, x[1::2])print(&#x27;x[1:len(x):2]&#x27;, x[1:len(x):2])# x[1::2] [4, 5, 4, 10]# x[1:len(x):2] [4, 5, 4, 10]#x[start::step]：当step&lt;1逆序，缺省stop=-len(x)-1。# 具体解释看知识点print(&#x27;x[4::-2]&#x27;, x[4::-2])print(&#x27;x[4:-len(x)-1:-2]&#x27;, x[4:-len(x)-1:-2]) # x[4::-2] [-1, 2, 1]# x[4:-len(x)-1:-2] [-1, 2, 1] 6.2.4 列表元素的两种拷贝方式任务一：列表元素的赋值拷贝知识点：列表拷贝的误区(赋值y=x实现了浅拷贝) 误区：两个列表的拷贝，直接通过赋值语句 list_copy = list_org，通过赋值**=将list_org复制给list_copy** 赋值拷贝：赋值=并不能实现真正的拷贝，只拷贝了变量的地址，而非数据的本身内容。细节请回顾3.2 变量内涵 可以通过**id()**函数查看变量的内存地址 通过a is b逻辑判断变量a和b是否指向同一个数据 赋值拷贝存在的问题：它们的修改会相互影响。即修改其中的一个列表对象，会影响另外个列表 1234567891011121314151617181920212223# 赋值拷贝x = [1, 4, 2, 5, -1, 4, 9, 10]# 复制成功了？y = xprint(&#x27;y：&#x27;, y)# y： [1, 4, 2, 5, -1, 4, 9, 10]#观察x和y是同个内存地址print(&#x27;id(x):&#123;&#125;, id(y):&#123;&#125;&#x27;.format(id(x), id(y)))# id(x):3057506266632, id(y):3057506266632#观察x和y是同个内存地址print(&#x27;x is y? &#123;&#125;&#x27;.format(x is y))# x is y? True# 修改y，观察是否会影响x# 发现x[1]和y[1]同时改变# y = x 并不能实现拷贝y[1] = -100print(&#x27;修改后的x：&#x27;, x)print(&#x27;修改后的y：&#x27;, y)# 修改后的x： [1, -100, 2, 5, -1, 4, 9, 10]# 修改后的y： [1, -100, 2, 5, -1, 4, 9, 10] 分析： 通过上面的例子看到了通过赋值y=x方式拷贝列表，并不能实现真正的列表元素拷贝 即对x和y列表的改变，会相互影响。真正的拷贝是希望两个列表是独立的，它们的修改互不干扰 通过id()和x is y发现它们本质上是同一个列表对象 任务二：列表元素的切片元素拷贝知识点：**y = x[:]**实现了列表元素的拷贝 切片元素拷贝：y拷贝的是x的所有元素，而非简单的地址 理解：在内存空间中开辟一个与x同样大小的空间，然后，将x的所有元素依次拷贝，最后将新空间地址赋值给y 1234567891011121314151617181920212223# 切片元素拷贝x = [1, 4, 2, 5, -1, 4, 9, 10]# 复制成功了？y = x[:]print(&#x27;y：&#x27;, y)# y： [1, 4, 2, 5, -1, 4, 9, 10]#观察x和y是同个内存地址print(&#x27;id(x):&#123;&#125;, id(y):&#123;&#125;&#x27;.format(id(x), id(y)))# id(x):3057506814600, id(y):3057506786504#观察x和y是同个内存地址print(&#x27;x is y? &#123;&#125;&#x27;.format(x is y))# x is y? False# 修改y，观察是否会影响x# 发现x[1]和y[1]同时改变# y = x 并不能实现拷贝y[1] = -100print(&#x27;修改后的x：&#x27;, x)print(&#x27;修改后的y：&#x27;, y)# 修改后的x： [1, 4, 2, 5, -1, 4, 9, 10]# 修改后的y： [1, -100, 2, 5, -1, 4, 9, 10] 6.2.5 切片的逻辑位置转换公式任务一：掌握参数为负的切片知识点： 如果step为负，那么返回的子列表为原列表的逆序 这里先假设start和stop都为正号 子列表正序还是逆序，只与step符号有关，与start和stop无关 正序step&gt;0要求start要位于stop的逻辑左边(start&lt;stop)。否则，返回空列表[] 逆序step&lt;0要求start要位于stop的逻辑右边(start)。否则，返回空列表[] 逆序时，不能缺省step参数。因为，缺省的step=1为正序 123456789101112131415161718192021x = [1, 4, 2, 5, -1, 4, 9, 10]# 逆序 start&gt;stopx_sub = x[4:1:-1]print(&#x27;x[4:1:-1]：&#x27;, x_sub)# x[4:1:-1]： [-1, 5, 2]# 逆序 start&lt;stop，则为空列表x_sub = x[1:4:-1]print(&#x27;x[1:4:-1]：&#x27;, x_sub)# x[1:4:-1]： []# 这里使用.format()格式输出的3个参数，第1个为start，# 第2个为stop，第3个为逆序条件start&gt;stop?print(&#x27;逆序条件 start=&#123;&#125; &gt; stop=&#123;&#125;? &#123;&#125;&#x27;.format(1, 4, 1 &gt; 4))# 逆序条件 start=1 &gt; stop=4? False# 缺省的step=1x_sub = x[1:4]print(&#x27;x[1:4]缺省step=1，为正序：&#x27;, x_sub)# x[1:4]缺省step=1，为正序： [4, 2, 5] 1234567891011121314x = [1, 4, 2, 5, -1, 4, 9, 10]# 正序 start&lt;stopx_sub = x[1:4:2]print(&#x27;x[1:4:2]：&#x27;, x_sub)# x[1:4:2]： [4, 5]# 正序 start&gt;stop，则为空列表x_sub = x[4:1:2]print(&#x27;x[4:1:2]：&#x27;, x_sub)# x[4:1:2]： []print(&#x27;正序条件 start=&#123;&#125; &lt; stop=&#123;&#125;? &#123;&#125;&#x27;.format(4, 1, 4 &lt; 1))# 正序条件 start=4 &lt; stop=1? False 任务二：掌握逻辑位置转换公式知识点：start和stop的逻辑位置转换公式 负索引与正索引逻辑位置转换公式：负索引**-n等价于正索引len(x)-n，其中n**为正整数 例如，负索引**-1等价于正索引len(x)-1** 切片的start和stop和可以正负号混用(不建议)，但是一定要注意： 正序step&gt;0，要求start要位于stop的逻辑左边。所谓的逻辑左边，可以对负索引先用逻辑位置公式转换为对应的正索引，然后再判断是否满足`start 逆序step&lt;0**，要求**start**要位于**stop**的**逻辑右边**。所谓的**逻辑右边**，可以对负索引先用逻辑位置公式转换为对应的正索引，然后再判断是否满足**start&gt;stop 遇到切片中有负索引，建议先用逻辑位置公式转换为正索引 123456789101112x = [1, 4, 2, 5, -1, 4, 9, 10]# 正序，start和stop为负值print(&#x27;x[-4:-1]：&#x27;, x[-4:-1])# x[-4:-1]： [-1, 4, 9]# 使用逻辑位置转换公式len(x)-n# 将负索引转换为正索引start = len(x) - 4stop = len(x) - 1print(&#x27;[len(x)-4 : len(x)-1]：&#x27;, x[start:stop])# [len(x)-4 : len(x)-1]： [-1, 4, 9] 123456789101112x = [1, 4, 2, 5, -1, 4, 9, 10]# 正负索引混用print(&#x27;x[1:-3:2]：&#x27;, x[1:-3:2])# x[1:-3:2]： [4, 5]# 使用逻辑位置转换公式len(x)-n# 将负索引转换为正索引stop = len(x) - 3print(&#x27;x[1:len(x)-3:2]：&#x27;, x[1:stop:2])# x[1:len(x)-3:2]： [4, 5]print(&#x27;正序条件 start=&#123;&#125; &lt; stop=&#123;&#125;? &#123;&#125;&#x27;.format(1, stop, 1 &lt; stop))# 正序条件 start=1 &lt; stop=5? True 6.2.6 遍历切片任务一：使用for遍历列表元素知识点： 切片的类型为列表list，也是可迭代对象，因此可以使用for来遍历它的元素 如果要遍历列表的部分元素，可在for循环中使用切片 123456x = [1, 4, 2, 5, -1, 4, 9, 10]# 遍历切片x[:3]的元素for val in x[:3]: print(val, end=&#x27; &#x27;)# 1 4 2 12345x = [1, 4, 2, 5, -1, 4, 9, 10]# 遍历切片x[-1:4:-2]的元素for val in x[-1:4:-2]: print(val, end=&#x27; &#x27;)# 10 4 6.3 元组：不可变列表6.3.1 元组的定义任务一：为何需要元组？知识点：不可变数据集合的需求 列表适用于储存运行期间可以动态增、减、修改的数据集合 Python为列表提供了强大数据处理技术：元素添加和删除、排序、列表遍历、切片、列表推导式等 然而，有些场合需要提供不可变的数据集合，即其中的元素不能被增、减、修改等操作 在现实世界中，很多物体的属性也都是不可被修改 比如课桌的长宽高，出厂之后是不变的 如果在程序运行中，对它们的属性进行修改，这是非法操作 为满足上述需求，Python专门设计了不可变的数据集合类型——元组(tuple)。相对于列表来说，元组是更简单和高效的数据结构。如果需要存储在整个程序生命周期内都不变的一组值，建议使用元组 任务二：元组的定义知识点： Python的元组与列表功能类似，但是元组在创建之后，就永远不能被修改了 标识：元组使用小括号**()，列表使用方括号[]** 元组创建：在小括号中添加元素，并使用逗号隔开，小括号可以被省略。例如：nums=(1,2,3)和nums=1,2,3 元组类型：使用type()函数查看，类型为tuple 12345678910111213# 使用()的元组创建info_tuple = (&quot;zhangsan&quot;, 18, 1.75)print(type(info_tuple), info_tuple)# &lt;class &#x27;tuple&#x27;&gt; (&#x27;zhangsan&#x27;, 18, 1.75)nums = (1, 2, 3, 4)print(type(nums), nums)# &lt;class &#x27;tuple&#x27;&gt; (1, 2, 3, 4)# 不使用()的元组创建nums = 1, 2, 3, 4print(type(nums), nums)# &lt;class &#x27;tuple&#x27;&gt; (1, 2, 3, 4) 任务三：创建空元组知识点： 不包含任何元素的元组为空元组，用**()**表示 info_tuple = () 任务四：只含一个元素的元组创建知识点： 对于只有一个元素的元组，为降低内存消耗，Python使用该元素原类型来代替元组。例如，**data = (123)**为数值类型。 要创建只含有一个元素的元组，在值后面跟必须一个逗号**,。例如，data = (123, )**为元组类型。 适用于带**()和不带()**的元组创建 1234567891011121314# 虽带()，但是此时data并非元组data = (123)print(type(data), data)# &lt;class &#x27;int&#x27;&gt; 123# 需要在元素后跟`,`data = (123, )print(type(data), data)# &lt;class &#x27;tuple&#x27;&gt; (123,)# 不带()，也需要在元素后跟`,`data = 123,print(type(data), data)# &lt;class &#x27;tuple&#x27;&gt; (123,) 6.3.2 元组的基本操作与遍历任务：使用[]访问元组元素知识点： 与列表一样，元组使用带[]的索引来访问元素 第1个元素对应0索引 注意：虽然元组使用**()来标识，但是元组访问依然使用[]而不是()** 在Python中，**()主要用于函数调用，传递参数。位于()之前的一般都是函数名。例如print(‘hello’)** 知识点： 类似列表，元组的索引从0开始 索引就是数据在元组中的位置编号 12345678# 元组支持不同类型的元素data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)print(type(data), data)# 类似列表通过[]来索引元素，而非()。print(&#x27;data[0]: &#x27;, data[0])print(&#x27;data[2]: &#x27;, data[2])print(&#x27;使用data(2)来访问元组元素会出错！&#x27;) 任务二：元组的元素统计与索引获取知识点： 定义元组info = (“zhangsan”, 18, 1.75) len(元组变量)：返回元组长度，值为最大索引n + 1 元组变量.count(值)：返回某个元素在元组中出现的次数 元组变量[索引]：根据索引从元组中，获得元素 元组变量.index(值)：返回某个值第一次出现在元组的索引 知识点：在Jupyter中，使用Tab智能联想元组类型提供的方法 1234567891011info_tuple = (&quot;zhangsan&quot;, 18, 1.75, &quot;zhangsan&quot;)# 1. 取值和取索引print(info_tuple[0])# 已经知道数据的内容，希望知道该数据在元组中的索引print(info_tuple.index(&quot;zhangsan&quot;))# 2. 统计计数print(info_tuple.count(&quot;zhangsan&quot;))# 统计元组中包含元素的个数print(len(info_tuple)) 任务三：遍历元组元素知识点：与列表一样，使用for-in循环来遍历元组的元素 12345678info_tuple = (&quot;zhangsan&quot;, 18, 1.75)# 使用迭代遍历元组for my_info in info_tuple: # 使用格式字符串拼接 my_info 这个变量不方便！ # 因为元组中通常保存的数据类型是不同的！ print(my_info, end=&#x27; &#x27;) 6.3.3 元组的应用场景任务一：元组的主要应用场景元组的3个主要的应用场景： 函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据。有关函数的参数和返回值，会在后续函数章节详细讲解 格式字符串，格式化字符串后面的**()**本质上就是一个元组 让列表不可以被修改，以保护数据安全 任务二：%字符串格式化知识点： 字符串的格式化方法在开发中非常实用 使用**%操作符，可将元组中的内容，依次**填入到字符串占位符处 后续字符串章节会专门讲解关于字符串的格式化高阶用法 123456789info_tuple = (&quot;小明&quot;, 21, 1.85)# 格式化字符串后面的 `()` 本质上就是元组print(&quot;%s 年龄是 %d 身高是 %.2f&quot; % info_tuple)# 小明 年龄是 21 身高是 1.85info_str = &quot;%s 年龄是 %d 身高是 %.2f&quot; % info_tupleprint(info_str)# 小明 年龄是 21 身高是 1.85 6.3.4 (重要) 元组的不可变性质任务一：元组的元素值不可被修改知识点： 元组的元素值不能被修改，即不能进行增、减、删除等操作 语法错误：TypeError: ‘tuple’ object does not support item xxx。tuple对象不支持xxx操作 友情提醒：当出现语法错误，查看错误类型，尝试着自己根据错误提示来排除错误 12345678910111213141516171819202122data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)# 不能修改元组的元素值data[0] = 100# ----------------------------------------------------------------# TypeError Traceback (most recent call last)# &lt;ipython-input-69-6bf349ffbb80&gt; in &lt;module&gt;# 1 data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)# 2 # 不能修改元组的元素值# ----&gt; 3 data[0] = 100# TypeError: &#x27;tuple&#x27; object does not support item assignmentdata = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)# 不能删除元组的元素值del data[0]# ----------------------------------------------------------# TypeError raceback (most recent call last)# &lt;ipython-input-73-916a07140e78&gt; in &lt;module&gt;# 1 data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)# 2 # 不能删除元组的元素值# ----&gt; 3 del data[0]# TypeError: &#x27;tuple&#x27; object doesn&#x27;t support item deletion 任务二：元组变量允许被重新赋值元组的元素值不能被修改，但是指向元组的变量可以被重新赋值 知识点： 变量存的是指向具体元组数据的地址，而非存元组数据本身。回顾请看变量的内涵 变量的重新赋值仅仅只是更换了一个地址，指向了新的数据空间，而并未对原元素数据做任何修改 可以通过**id()**来查看变量赋值前后的所指向的地址是否发生变化 元组元素不可修改指的是元组的数据空间的元素值不能被修改 因此，如果一定要修改元组的元素，可重新覆盖定义整个元组 12345678data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)print(&#x27;赋值前：&#x27;, id(data), data)# 赋值前： 3057506924248 (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)# 对data进行重新赋值data = (1, 2, 3)print(&#x27;赋值后：&#x27;, id(data), data)# 赋值后： 3057505683640 (1, 2, 3) 任务三：元组和列表之间的转换知识点： **list(元组)**：使用 list 函数可以把元组转换成列表 **tuple(列表)**：使用 tuple 函数可以把列表转换成元组 6.3.5 (重要) 元组的解包和多个返回值函数任务一：元组的解包知识点： 通过解包可以对元组的元素进行拆分，并刻赋值给多个变量 左边被赋值的变量个数必须和元组元素个数相同，否则出现解包错误。ValueError: too many values to unpack 通过**len()**查看元组元素个数 1234567data = (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)print(data)# (1, &#x27;2&#x27;, &#x27;python&#x27;, 4.12)x1, x2, x3, x4 = dataprint(&#x27;元组解包：&#x27;, x1, x2, x3, x4)# 元组解包： 1 2 python 4.12 123456789101112131415# 元组元素个数必须等于赋值变量个数print(&#x27;len(data)：&#x27;, len(data))# len(data)： 4x1, x2 = dataprint(&#x27;元组解包：&#x27;, x1, x2)# ----------------------------------------------------------# ValueError Traceback (most recent call last)# &lt;ipython-input-75-d5e254368fc9&gt; in &lt;module&gt;# 2 print(&#x27;len(data)：&#x27;, len(data))# 3# ----&gt; 4 x1, x2 = data# 5 print(&#x27;元组解包：&#x27;, x1, x2)# ValueError: too many values to unpack (expected 2) 任务二：使用元组的解包接受多个函数返回值知识点(补充知识)： 函数传递多个返回值 在C++中，函数允许最多传回一个返回值，否则会出错 在Python中，通过元组可以实现传递函数的多个返回值功能。对函数的多个返回值使用元组进行打包，然后在函数调用之处进行解包赋值 123456789#观察divmod()函数# 返回值：商和余数，被打包在一个元组print(divmod(15, 2))# (7, 1)# 通过元组解包，接受函数的多个返回值x, y = divmod(15, 2)print(&#x27;divmod(15, 2)，商：&#123;&#125;，余数：&#123;&#125;&#x27;.format(x, y))# divmod(15, 2)，商：7，余数：1 任务三：定义拥有多个返回值的函数知识点：定义拥有多个返回值的函数 元组可以包含多个数据，因此可以使用元组让函数一次返回多个值 类似于元组的创建，函数的返回值如果是元组，那么小括号**()**可以省略 函数的用法后续章节会详细讲解，这里仅为了深入地讲解元组的封包和解包功能 函数定义语法：def 函数名(用逗号,隔开的形参): 冒号**:**不要忘记，后面紧跟着的是被缩进的语句块 def为函数定义的关键字 12345678910# 定义函数, 有多个返回值(返回元组)def measure(): print(&quot;测量开始...&quot;) # 两个值的输入可以使用input() hight = 1.8 weight = 60 # return (hight, weight) # 小括号可以省略 return hight, weight 任务四：函数的多个返回值处理知识点：函数的多个返回值处理： 方式1：使用一个变量直接接受函数返回的元组，然后再通过索引方式来访问元组元素 方式2：使用多个变量直接对函数返回值进行解包 1234567# 方式1：用一个变量接受函数返回的元组result = measure()print(result) # (1.8, 60)# 需要单独的处理身高或体重 - 不方便print(result[0]) # 1.8print(result[1]) # 60 123456# 方式2：可使用多个变量，一次接收函数的返回结果# 使用多个变量接收时，变量个数必须和函数返回的个数保持一致res_height, res_weight = measure()print(res_height) # 1.8print(res_weight) # 60 6.3.6 实例：利用元组实现变量值的交换任务一：两个变量值的交换变量值的相互交换在设计排序算法中，非常重要。下面介绍3种值交换方式，前面两种适用于任何语言，最后种为Python独有 方式1：引入额外的其他变量 123456789x = 6y = 100print(&#x27;交换前&#x27;, x, y) # 交换前 6 100# 方式1：使用其他变量z = xx = yy = zprint(&#x27;交换后&#x27;, x, y) # 交换后 100 6 方式2：使用算术运算，仅适用于数值类型的变量 1234567x = 6y = 100print(&#x27;交换前&#x27;, x, y) # 交换前 6 100x = x + yy = x - yx = x - yprint(&#x27;交换后&#x27;, x, y) # 交换后 100 6 方式3：使用元组的封包和解包操作(Python独有)。可以省略等号创建元组可以省略**()** 123456789x = 6y = 100print(&#x27;交换前&#x27;, x, y) # 交换前 6 100y, x = (x, y)print(&#x27;交换后&#x27;, x, y) # 交换后 100 6# 等号右边是一个元组，可以直接省略()y, x = x, yprint(&#x27;再次交换后&#x27;, x, y) # 再次交换后 6 100","categories":[],"tags":[]},{"title":"Python学习笔记5","slug":"Python学习笔记5","date":"2021-06-16T16:26:28.000Z","updated":"2021-06-16T16:28:01.993Z","comments":true,"path":"2021/06/17/py5.html","link":"","permalink":"http://waxll.top/2021/06/17/py5.html","excerpt":"","text":"第五章 列表：遍历遍历整个列表为何需要循环任务：为何需要循环？假设有一个班级名单(列表)，需要将其中每个同学名字都打印出来，并对他/她说一句问候语。按之前学到的Python知识，可以分别地(依次)获取名单中的每个名字，但这种做法会导致多个问题： 如果名单很长，为每个人写问候语，将包含大量重复的代码。 列表可以动态增减，每当名单的长度发生变化时，都必须对代码进行增减，不易维护。 重复性的工作。 为解决上述问题，需要使用循环技术。 循环让我们可以对列表的每个元素都采取一系列相同(重复性)的操作，从而高效地处理任何长度的列表，包括包含数千乃至数百万个元素的列表。 任务：掌握for循环语法 知识点： 遍历就是从头到尾依次从列表中获取数据(元素)，然后在循环体内部对每个元素执行相同操作。 为实现遍历，Python引入for循环(for-each)机制。 为了提高列表的遍历效率，Python专门提供了迭代器iteration来实现遍历功能。关于迭代器后续会讲解，这里仅作了解。 知识点：for循环语法。 描述： for循环用于迭代/遍历序列对象（即列表，元组，字典或字符串）。通过使用for循环，可以对序列中的每个元素执行一系列重复的语句/操作。 语法： 12345for item in sequence: statements(item) for 临时变量 in 序列对象(比如列表): 循环体语句块(必须相同的缩进) 知识点(术语)：何谓迭代？ 迭代：每运行一次循环体statements，称迭代一次。 迭代次数：循环共运行了几次。 迭代条件：满足循环的条件。 任务：列表的应用场合分析 知识点： 尽管 Python 列表中可以存储不同类型的数据。 但是在开发中，更多的应用场景是 列表存储相同类型的数据。 通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作。 深入列表for循环任务：for循环的注意事项 for循环注意事项： 在循环体语句块中，执行重复代码。 C++或Java使用&#123; &#125;来管理语句块，所以他们对缩进不敏感。 Python敏感于代码缩进。它通过代码缩进，来管理和识别语句块。 同个语句块代码需要采用相同的缩进量，如果不恰当的使用缩进，将会报错。 请善用代码排版插件小锤子。 这种遍历适用于任何序列对象(不局限于列表)。 任务：循环通过缩进标识循环体在程序设计中，循环是一项非常重要的技术，因为它可以让计算机自动完成重复工作。 知识点： 循环意义：在每次迭代过程中，依次从列表numbers中取出元素，并赋值给临时变量(局部)val，然后再对每个val执行相应的操作。 Python循环语法：循环体通过缩进被Python解释器识别。 循环体的前后，多敲一个回车空行。 通过循环体内与循环体外的相对缩进，来标识循环语句块。 1234567891011121314print(&#x27;----求解列表元素之和----&#x27;)numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]sum = 0# 循环前后多敲空格for val in numbers: sum = sum + val# 循环体之外语句不缩进print(&quot;The sum is&quot;, sum)#----求解列表元素之和----#The sum is 48 任务：for循环的临时变量为局部变量 知识点： 在循环体中，对循环体内的局部变量进行修改，不会影响原列表的元素值。 例如，for val in numbers:对val进行修改，不影响numbers的值。 val是局部变量，作用域只限制于循环体。 1234567891011numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]print(&#x27;循环前:&#x27;, numbers)#val为局部变量for val in numbers: val = val + 1print(&#x27;循环后:&#x27;, numbers)#循环前: [6, 5, 3, 8, 4, 2, 5, 4, 11]#循环后: [6, 5, 3, 8, 4, 2, 5, 4, 11] 任务：通过临时变量实现批量运算 知识点： 循环的目的是对一组数据实现批量重复性操作。 在循环体内，通过对局部变量进行运算和操作，对列表元素实现批量地重复性操作。 123456789101112names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]# 通过临时变量name实现对列表元素批量操作for name in names: print(&#x27;Hello, &#x27; + name.title() + &#x27;!&#x27;)print(&#x27;打印结束！&#x27;)#Hello, Alice!#Hello, David!#Hello, Carolina!#打印结束！ 代码解析： 首先，定义了一个列表。 接下来，定义一个for循环；这行代码让Python从列表names中取出一个名字，并将其存储在变量name中。 最后，让Python打印前面存储到变量name中的名字。这样，对于列表中的每个名字，Python都将重复执行循环体代码。 习题第一题题目要求： 创建字符串”hello, python”，遍历打印每个字符。 代码如下： 123massage=&quot;hello,python&quot;for val in massage: print(val,end=&#x27; &#x27;) 运行结果： 1h e l l o , p y t h o n 第二题题目要求： 输入一个水果的列表，遍历打印每种水果。 代码如下： 123FruitsList=[&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;]for val in FruitsList: print(val) 运行结果： 123applebananapear for循环体包含多条语句任务：for循环体使用多条语句之前的循环体都是一行代码，在本节将循环体扩展为多行。在for循环中，可对每个元素执行任何操作。 知识点： Python解释器使用缩进来判断循环体语句块的范围。 从for的声明之后到遇到第一个与for同级别缩进的语句。 例如，在for name in names后面，每个缩进的代码行都是循环体部分，这部分的代码将针对列表中的元素都执行一次。 1234567891011121314151617181920212223242526names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for name in names: # print()在输入末尾默认插入换行符。 print(name.upper() + &quot;, that was a great trick!&quot;) print(name.lower() + &quot;, that was a great trick!&quot;) # 换行符\\n在每次迭代结束后都额外插入一个空行。 print(&quot;Thanks for your show, &quot; + name.title() + &quot;.\\n&quot;)print(&#x27;循环之外&#x27;) #与for同级别的缩进，循环之外的语句。#-------输出--------# ALICE, that was a great trick!# alice, that was a great trick!# Thanks for your show, Alice.# DAVID, that was a great trick!# david, that was a great trick!# Thanks for your show, David.# CAROLINA, that was a great trick!# carolina, that was a great trick!# Thanks for your show, Carolina.# 循环之外 for循环结束的标志（易错）任务：for循环结束标志for循环结束后再怎么做呢？通常，需要提供总结性输出或接着执行程序必须完成的其他任务。 知识点：与for同级别缩进的代码不属于循环体代码，它们只执行一次，而不会重复执行。 例子：首先在循环体为每个成员打印2条消息；然后，在循环结束之后，输出1条总结性的消息，需要将相应的代码放在与for同级别缩进处： 123456789101112131415161718192021names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for name in names: # 两条print语句针对列表中每位成员重复执行 print(name.title() + &quot;, that was a great trick!&quot;) print(&quot;Thanks for your show, &quot; + name.title() + &quot;.\\n&quot;)# 第三条print语句没有缩进，因此只执行一次print(&quot;Thank you, everyone. That was a great show!&quot;)# ---- 输出 ----# Alice, that was a great trick!# Thanks for your show, Alice.# David, that was a great trick!# Thanks for your show, David.# Carolina, that was a great trick!# Thanks for your show, Carolina.# Thank you, everyone. That was a great show! 任务：循环体通过缩进进行标识 知识点：多重循环，用缩进来识别每重for的循环体语句块范围。 1234567numbers = [1,2,3,4]sum = 0for val1 in numbers: #外层循环 for val2 in numbers: #内层循环 print(val1*val2, end = &#x27; &#x27;) #内循环语句 print(&#x27;&#x27;) #外循环语句 代码解析： 两个嵌套的for循环。过程类似于C语言。 外层循环体包括：整个内层循环+print(&#39;&#39;)。 程序步骤如下： 首先，在外层循环取列表numbers第一个元素1赋值给val1。 然后，进入内层循环，依次取列表numbers赋值给val2。并执行内层循环体print(val1*val2, end = &#39; &#39;)。 内层循环结束后，返回到外层循环，执行print(&#39;&#39;)。 此时，外层循环被完整地执行一次。Python再次检测外循环是否遍历完所有元素，如果否则再次执行循环。 print()中的end参数：在输出的结尾加入一个end字符，默认为换行符。end = &#39; &#39;表示print()函数最后输出加``空格符。各位可以参数修改end参数，观察结果。 print(&#39;&#39;)：输出换行。因为end参数的默认值是换行符。输出空字符，则代表对当前输出进行换行。 习题第三题题目要求： 想出至少三种你喜欢的比萨，将其名称存储在一个列表中，再使用for循环将每种比萨的名称都打印出来。 修改这个for循环，使其打印包含比萨名称的句子，而不仅仅是比萨的名称。对于每种比萨，都显示一行输出，如“I like pepperoni pizza”。 在程序的循环结束后，添加一行代码，输出总结性的语句，如“I really love pizza!”。 代码如下： 12345678PizzaList=[&quot;pepperoni&quot;,&quot;Chicago-Style&quot;,&quot;California-style&quot;,&quot;Bar&quot;]for val in PizzaList: print(val)for val in PizzaList: print(&quot;I like &quot;+val+&quot; pizza&quot;)print(&quot;I really love pizza!&quot;) 运行结果： 123456789pepperoniChicago-StyleCalifornia-styleBarI like pepperoni pizzaI like Chicago-Style pizzaI like California-style pizzaI like Bar pizzaI really love pizza! 第四题题目要求： 想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for循环将每种动物的名称都打印出来。 修改这个程序，使其针对每种动物都打印一个句子，如“A dog would make a great pet”。 在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如“Any of these animals would make a great pet!”这样的句子。 代码如下： 1234567AnimalList=[&quot;dog&quot;,&quot;cat&quot;,&quot;bird&quot;]for val in AnimalList: print(val)for val in AnimalList: print(&#x27;A &#x27;+val+&#x27; would make g great&#x27;)print(&quot;Any of these animals would make a great pet!&quot;) 运行结果： 1234567dogcatbirdA dog would make g greatA cat would make g greatA bird would make g greatAny of these animals would make a great pet! 常见的缩进错误知识点： Python根据缩进来判断代码行与前一个代码行的关系。 比如for循环用缩进来识别语句块范围。 同样适用于后的while循环、if判断、def函数和class类的定义等。 正确的使用Python的缩进技术，非常重要。 Python通过使用缩进让代码更易读；简单地说，它要求你使用缩进让代码整洁而结构清晰。 通过代码不同程度的缩进，可以快速的掌握程序的组织结构。 任务：忘记缩进(错误) 知识点： 对于位于for语句:之后循环体代码，一定要缩进。 如果忘记缩进，Python解释器将会提示错误。 123456789names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]print(&#x27;------for循环语句块必须要至少一行代码------&#x27;)for name in names:print(name)# File &quot;&lt;ipython-input-3-bec157200367&gt;&quot;, line 4# print(name)# ^# IndentationError: expected an indented block 任务：忘记缩进额外的代码行(错误) 知识点： 解释器只检测for语句头之后的第一句是否缩进。 非第一句的循环体语句，Python无法检测，这将会发生逻辑错误：代码可以运行，结果出乎意料。 12345678910names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for name in names: print(name.title() + &quot;, that was a great trick!&quot;)# 不检测for第一句之后的语句是否缩进print(&quot;Thanks for your show, &quot; + name.title() + &quot;.\\n&quot;)# Alice, that was a great trick!# David, that was a great trick!# Carolina, that was a great trick!# Thanks for your show, Carolina. 程序解析： 第二条print语句原本需要缩进，但Python发现for语句后面有一行代码是缩进的，因此它没有报告错误。 程序结果是，对于列表中的成员，都执行了第一条print语句，因为它缩进了；而第二条print语句没有缩进，因此它只在循环结束后执行一次。 由于变量name的终值为&#39;carolina&#39;，因此只有她收到了消息“Thanks for your show, Carolina.”。 任务：非语句块的不必要缩进(错误) 知识点： 非循环体(代码块)的代码不要缩进，否则将会发生语法或逻辑错误。 代码块标志是什么？ 在冒号:之后，需要用缩进来标识代码块范围。 代码块范围：冒号:之后代码 到 第一行与for同级别缩进的代码。 为优雅的区分代码块代码，请在代码块结束后多加一个换行。 12345678message = &quot;Hello Python world!&quot;print(&#x27;------------不在代码块中的代码不允许缩进--------&#x27;) print(message) # 非语句块的缩进，将会发生错误# File &quot;&lt;ipython-input-5-7b2c6f3f0548&gt;&quot;, line 3# print(message)# ^# IndentationError: unexpected indent 任务：同一级别的代码必须使用统一缩进 知识点：同一级别代码的缩进规则。 允许：同一级别的代码必须要采用统一的缩进，不管缩进多少个空格。 不允许：但Python不允许它们采用不同统一缩进。 建议第一级别的代码顶格写，之后凡是遇到语句块再依次缩进。 比如二重循环，第二层循环语句块需要缩进两个级别。 123456 print(&quot;允许同一级别的代码都采用统一的缩进&quot;) print(&quot;允许同一级别的代码都采用统一的缩进&quot;)--------------------------------------------允许同一级别的代码都采用统一的缩进允许同一级别的代码都采用统一的缩进 12345678 print(&quot;不允许同一级别的代码采用不同统一的缩进&quot;) print(&quot;不允许同一级别的代码采用不同统一的缩进&quot;)--------------------------------------------- File &quot;&lt;ipython-input-27-d5097ab6b28d&gt;&quot;, line 2 print(&quot;允许同一级别的代码都采用统一的缩进&quot;) ^IndentationError: unexpected indent 第一个代码块，代码虽然不顶格，但是同一级别采用相同缩进方式，所以代码可以正常运行；第二代码块，将会触发缩进错误。 任务：语句块之后不必要的缩进(错误) 知识点： 循环体语句块之后的代码，如果不恰当的使用了缩进，Python将会视它为语句块代码，将会发生语法错误或逻辑错误。 有些缩进问题是语法错误，Python解释器会报错误，可通过报错代码，找到出错原因。 但是很多缩进问题是逻辑错误，Python不会报逻辑错误，程序一般都能正常运行。因此，排查逻辑错误，通常需要花更多的时间。 Python的语句块缩进很容易造成初学者逻辑错误，因此一定要小心使用。 例子：不小心缩进了应在循环结束后执行的代码，这些代码将针对每个列表元素重复执行。 123456names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for name in names: print(name.title() + &quot;, that was a great trick!&quot;) print(&quot;我是语句块代码，请缩进包括我吧！\\n&quot;) print(&quot;我不是语句块代码，请不要缩进包括我，否则将会发生逻辑错误！&quot;) 任务：遗漏冒号 知识点： 代码块的标志是什么？在冒号:之后，需要用缩进来标识代码块范围。 如果遗漏了:，Python将无法判断哪里是语句块的开始，那么将会报错。 这个错误是语法错误，相信Python肯定会报的。 12345678names = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for name in names print(name)# File &quot;&lt;ipython-input-6-2a56c4e8eee2&gt;&quot;, line 2# for name in names# ^# SyntaxError: invalid syntax 数值数列任务：序列类型或容器类型 知识点：什么叫序列类型？ 序列是Python中最基本的数据结构，它是容器类型的数据类型。 序列中的每个元素都分配了一个称为索引的整数(用于指明元素位置)。 例如，第一个索引是0，第二个索引是1，依此类推。 Python有6个序列的内置类型，但最常见的是列表、元组和字符串。 很多应用都会涉及到处理和储存一组数值类型的数据。例如，在游戏中，需要跟踪每个角色的位置信息，还可能需要对玩家进行积分排行。 知识点： 类似于C语言中的数组，在Python中，可使用列表list来管理一组数值类型的数据。 列表是一种Python序列类型(容器类型)，它提供了很多便捷的方法来处理和维护数据(列表元素)。 即使列表包含数百万个元素，也可以很高效的处理。 使用函数range()生成数值序列任务：range()数值序列生成函数 知识点： 语法：range(stop)或range(start, stop[, step]) 描述：range()函数生成一个从start开始到stop(但不包括)按step步长的整形序列(非列表)。Python内置函数，一般用在for循环中。 参数： start: 从start开始。默认值为0。例如range(5)等价于range(0,5)。 stop: 到stop结束，但不包括stop。例如：range(0,5)是[0, 1, 2, 3, 4]不包括5。 step：步长，默认值为1。例如：range(0,5)等价于range(0,5,1)。 返回：一个range对象。而不是列表类型，所以调用print()时，不会直接打印序列元素。 限制：只能生成整数序列。 12345num = range(1, 5, 1)# print不会显示具体元素值print(num, type(num))#range(1, 5) &lt;class &#x27;range&#x27;&gt; 任务：print()的end参数使用 知识点： print()函数的参数end =&#39;字符&#39;指定print结束之处添加的’字符’。 end参数的默认值为换行符\\n。 1234567for value in range(1, 5, 1): print(value) #默认值为`\\n`换行# 1# 2# 3# 4 1234for value in range(1, 5, 1): print(value, end=&#x27; &#x27;) #修改end参数为空格# 1 2 3 4 注意，range()只生成了1~4，并非想象中的1~5。 函数range()让Python从start到stop-1范围创建整数序列，不包括stop值。 使用range()时，如果输出结果不符合预期，请尝试将对参数值进行加1或减1尝试。 任务：range()函数参数不能为空 知识点： range()的3个参数只能为整形，不能为浮点数。 否则就会出错。 12345678910# 任意一个参数为浮点数会报错num = range(1,1.5,5)# ---------------------------------------------------------------------------# TypeError Traceback (most recent call last)# &lt;ipython-input-9-1d19c399ee0c&gt; in &lt;module&gt;# 1 # 任意一个参数为浮点数会报错# ----&gt; 2 num = range(1,1.5,5)# TypeError: &#x27;float&#x27; object cannot be interpreted as an integer 任务：range()函数的等价形式 知识点：range(n) 等价于 range(0,n,1)。 12345678910for value in range(6): print(value, end=&#x27; &#x27;)print(&#x27;&#x27;) # 换行for value in range(0, 6,1): print(value, end=&#x27; &#x27;)# 0 1 2 3 4 5# 0 1 2 3 4 5 知识点： 为生成浮点数序列，可将range()生成的整数序列。 然后，除以特定的数，得到等间隔的小数序列。 1234for value in range(1, 10, 2): print(value/10, end=&#x27; &#x27;)# 0.1 0.3 0.5 0.7 0.9 任务：通过遍历或索引获取range()序列元素 知识点：深入解析range()函数。 range()被创建时，在内存中不直接生成所有的序列元素。 元素只有在使用时，比如遍历或索引访问时，才会在内存中被生成。 这种方式可以大大的降低程序对内存的使用。 通过索引或循环来遍历来访问range()序列元素。 123456789101112num = range(1,10, 2)# 索引访问num[1]，range(1,10, 2)生成相应的元素# 其他元素由于没使用，所以不被生成print(num[1])# 使用循环遍历元素for i in num: print(i, end=&#x27; &#x27;)# 3# 1 3 5 7 9 任务：使用list()将range对象转换为列表 知识点： 通过list()函数可以将range()对象的所有元素转换为列表。 返回数值类型的列表。 习题第六题题目要求： 计算1到100的整数之和，奇数之和，偶数之和。 代码如下： 1234567891011121314151617ListNum=range(1,101,1)Integer_Sum=0for val in ListNum: Integer_Sum=Integer_Sum+val ListNum=range(1,101,2)OddNumber_Sum=0for val in ListNum: OddNumber_Sum=OddNumber_Sum+val ListNum=range(0,101,2)EvenNumber_Sum=0for val in ListNum: EvenNumber_Sum=EvenNumber_Sum+valprint(Integer_Sum,OddNumber_Sum,EvenNumber_Sum) 运行结果： 15050 2500 2550 第七题题目要求： 输入两个整数a和b，计算区间[a b]整数之和。 代码如下： 123456789a=int(input())b=int(input())ListNum=range(a,b+1,1)s=0for val in ListNum: s=s+valprint(s)#a=1;b=9 运行结果： 12500 第八题题目要求： 输入两个数，求最大公约数和最小公倍数。提示：使用for循环，和range() 代码如下： 12345678910num1 = int(input(&#x27;Num1:&#x27;))num2 = int(input(&#x27;Num2:&#x27;))min_num = min(num1,num2)for i in range(1,min_num + 1): if num1 % i == 0 and num2 % i == 0: gys = igbs = int((num1 * num2) / gys)print(&#x27;%s和%s的最大公约数为:%s&#x27; %(num1,num2,gys))print(&#x27;%s和%s的最小公倍数为:%s&#x27; %(num1,num2,gbs))#num1=3;num2=27 运行结果： 123和27的最大公约数为:33和27的最小公倍数为:27 第九题题目要求： 生成一个列表，列表元素分别为[12,22,32…n2]。 代码如下： 123456n=int(input(&#x27;项数&#x27;))n=n+1ListNum=range(12,10*n+2,10)for val in ListNum: print(val)#n=4 运行结果： 123412223242 第十题题目要求： 找出1～10之间所有偶数，返回一个列表，包含以这个偶数为半径的圆的面积。 代码如下： 1234pi=3.14for r in range(2,11,2): print(r,end=&#x27; &#x27;) print(pi*r*r) 运行结果： 123452 12.564 50.246 113.039999999999998 200.9610 314.0 使用range()输出乘法表任务：使用range()输出乘法表 知识点： print()函数的参数 end =&#39;字符&#39;指定print结束之处添加’字符’。 它的默认为换行符\\n。 使用双重循环，并通过print()语句输出乘法表。 12345678910for i in range(1, 4): for j in range(1, 4): print(i,&#x27;*&#x27;, j,&#x27;=&#x27;, i * j, end=&quot; &quot;) print(&#x27;&#x27;) #换行print(&#x27;乘法表&#x27;)# 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3# 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6# 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9# 乘法表 循环体的核心语句print(i,&#39;*&#39;, j,&#39;=&#39;, i * j, end=&quot; &quot;)，输出每个乘法结果。 这个print()语句为输出乘法算式结果，共用了6个字符串拼接，以,相隔。 上述的输出语句非常复杂，那么Python是否提供更好的解决方案？.format()字符串格式函数。 任务：.format()函数的乘法表使用.format()函数来格式化输出乘法表。 123456789101112for i in range(1, 4): for j in range(1, 4): # print(i,&#x27;*&#x27;, j,&#x27;=&#x27;, i * j, end=&quot; &quot;) print(&quot;&#123;&#125;*&#123;&#125;=&#123;&#125;&quot;.format(i,j,i*j), end=&quot; &quot;) print(&#x27;&#x27;)print(&#x27;乘法表&#x27;)# 1*1=1 1*2=2 1*3=3# 2*1=2 2*2=4 2*3=6# 3*1=3 3*2=6 3*3=9# 乘法表 使用list()转换数字列表任务：使用list()将range对象转换为列表 知识点： 由于range()数字序列生成器，不能直接在内存中生成数字列表，只有元素被使用时，才会生成数字。 可以通过list()函数可以将range对象的所有元素转换为列表，返回数值类型的列表。 将range()返回作为list()函数的参数：list(range(10))。 list类型的数据，在内存中真实存在；range类型的数据，在内存中不存在(不占内存)。 123456789# range()数字序列生成器，无论多大的数据都不占内存print(range(1,6000000), type(range(1,6)))# 通过list()将range对象转换为list# list元素在内存中真实存在num = list(range(1,6))print(num, type(num))# range(1, 6000000) &lt;class &#x27;range&#x27;&gt;# [1, 2, 3, 4, 5] &lt;class &#x27;list&#x27;&gt; 使用函数range()时，还可指定step步长。 例如，下面的代码打印1~10内的偶数，函数range()从start=2开始，然后不断地加step=2，直到达到或超过stop(11)。 123even_numbers = list(range(2, 11, 2))print(even_numbers)# [2, 4, 6, 8, 10] 任务：两种生成平方数列表的方式使用函数range()几乎能够创建任何需要的数字序列。 例如，创建一个包含前10个整数的平方数序列。在Python中，两个星号**表示乘方运算。下面的代码演示了如何将前10个整数的平方通过循环逐个加到squares列表中： 1234567squares = []for value in range(1, 11): square = value**2 squares.append(square)print(squares)# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 程序解析： 首先，创建了一个空列表squares。 接下来，使用函数range()让Python遍历1~10的值。 在循环中，计算当前值的平方，并将结果append()到变量square中。 然后，将新计算得到的平方值附加到列表squares末尾。 最后，循环结束后，打印列表squares。 为让这些代码更简洁，在循环体中可不使用临时变量square，而是直接将每个平方结果附加到列表末尾： 123456squares = []for value in range(1, 11): squares.append(value**2)print(squares)# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 创建更复杂的列表时，可使用上述的两种方法。 作为新手，建议使用第1中方式，通过使用临时变量会让代码更易读。 熟悉之后，可以使用第二种更简便的方式，降低代码冗余度。 统计列表的信息任务：列表的信息统计Python提供了几个专门用于处理列表元素的内建(build-in)函数，即python自带函数。 知识点： min()方法返回列表元素中的最小值。 max()方法返回列表元素中的最大值。 sum()方法返回列表元素之和。 1234digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]print(min(digits)) # 0print(max(digits)) # 9print(sum(digits)) # 45 知识点：字符串列表的最小和最大值。 min()和max()同样适合字符串列表。 字符串列表的元素比较，先比第一位，如果相同，则再比第二位。以此类推。 12list1 = [&#x27;113&#x27;, &#x27;11111&#x27;, &#x27;1122&#x27;]print(min(list1)) # 11111 习题第十一题题目要求： 使用一个for循环打印数字1~20(包含)。 代码如下： 12for num in range(1,21,1): print(num,end=&#x27; &#x27;) 运行结果： 11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 第十二题题目要求： 创建一个列表，其中包含数字1~1 000 000，再使用一个for循环将这些数字打印出来（如果输出的时间太长，按Ctrl + C停止输出，或关闭输出窗口）。 代码如下： 12for num in range(1,1000000,1): print(num,end=&#x27; &#x27;) 运行结果： 11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 ...... 第十三题题目要求： 创建一个列表，其中包含数字1~1 000 000，再使用min()和max()核实该列表确实是从1开始，到1 000 000结束的。另外，对这个列表调用函数sum()，看看Python将一百万个数字相加需要多长时间。 代码如下： 1234List=range(1,1000001,1)print(min(List))print(max(List))print(sum(List)) 运行结果： 1234511000000500000500000[Done] exited with code&#x3D;0 in 0.197 seconds 第十四题题目要求： 通过给函数range()指定第三个参数来创建一个列表，其中包含1~20的奇数；再使用一个for循环将这些数字都打印出来。 代码如下： 123mylist=range(1,20,2)for num in mylist: print(num,end=&#x27; &#x27;) 运行结果： 11 3 5 7 9 11 13 15 17 19 枚举：遍历列表的索引认识可迭代对象任务：可迭代对象 知识点： 为何列表可以直接使用for-in语句来遍历元素？ 因为它是黑科技，可迭代对象。 列表可以直接遍历获得列表元素，而不像C++或Java是通过下标索引方式来遍历列表。 for循环并非只限于列表，任何可迭代对象都可使用此功能。 知识点：何谓可迭代对象？(只需要了解基本概念，不需要深入) 可以被遍历的对象，任何可以用for-in语句来获取元素的对象都是可迭代对象。即， 12for iterating_var in sequence: statements(s) 描述：可迭代对象每次循环(迭代)返回一个元素，直到遍历完所有的元素(迭代结束)。 常见可迭代对象：list列表对象，str字符串对象, range对象。 1234567my_list = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;pig&#x27;]for i in my_list: # for-in循环 print(i)# dog# cat# pig 任务：如何判断某个对象为可迭代对象？ 知识点： 通过isinstance(a, Iterable)方式来判断变量a是否为可迭代对象。 需要从collections模块中导入Iterable。 1234567891011121314151617from collections import Iterableobj = &#x27;hello&#x27;print(type(obj), isinstance(obj, Iterable))# &lt;class &#x27;str&#x27;&gt; Trueobj = [1,2,3]print(type(obj), isinstance(obj, Iterable))# &lt;class &#x27;list&#x27;&gt; Trueobj = range(10)print(type(obj), isinstance(obj, Iterable))# &lt;class &#x27;range&#x27;&gt; Trueobj = 123print(type(obj), isinstance(obj, Iterable))# &lt;class &#x27;int&#x27;&gt; False 两种获取元素索引的方式 知识点： 在for-in循环体中，并不能直接获得列表元素所对应的索引。 只能遍历获取元素，但并不知元素在列表中的位置。 为此，下面给出了两种类似C++的for循环方式来同时获得元素索引。 任务：如何获得for循环元素索引？方法一：设置循环的临时变量i为下标索引。 12345my_list = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;pig&#x27;]for i in range(len(my_list)): print(my_list[i], end=&#x27; &#x27;)# dog cat pig 程序解析： range(len(my_list))：对于函数的嵌套写法，应该从里函数len()到外函数range()的顺序来解读程序。 这里使用range()函数，根据my_list列表的长度len(my_list)来构造索引序列。 此时的临时变量i为元素索引。因此，在循环体中，通过下标索引方式访问元素my_list[i]。 方法二：引入额外变量来跟踪迭代过程。 12345678i = 0for item in my_list: print(i, &#x27;: &#x27;, item, sep=&#x27;&#x27;) i += 1# 0: dog# 1: cat# 2: pig 程序解析： 在循环中，引入额外的变量i来跟踪当前循环的迭代情况。 i即为列表元素的下标索引。 知识点(补充)： print()的sep参数，为多个字符串输出添加sep所指定的分割符。 12print(&#x27;hello&#x27;, &#x27;: &#x27;, &#x27;hello&#x27;, sep=&#x27;~~&#x27;)# hello~~: ~~hello enumerate()函数获取元素索引任务：使用enumerate()函数获得元素索引为解决上述需求，python引入了一种更优雅的方案enumerate()函数，能够在迭代列表的同时获取索引。 知识点： 语法：enumerate(iterable, start=0)，即 12for index, item in enumerate(iterable, start&#x3D;0): indented_statements 描述：内置函数，生成一系列index-item对(元组)，其中index是索引，而item为当前元素。 参数：iterable是之前提到的可迭代对象，可以被遍历的对象。 参数：start自定义索引序号的起始值，默认值为0。每次迭代，enumerate()返回的索引值index = 元素item原来的索引 + 起始值start。 123456789101112131415161718my_list = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;pig&#x27;]print(&#x27;--默认起始索引序号start--&#x27;)for i, item in enumerate(my_list): print(i, &#x27;: &#x27;, item, sep=&#x27;&#x27;) print(&#x27;--起始索引序号start=2--&#x27;)for i, item in enumerate(my_list, 2): #建议使用format格式化字符串 print(&#x27;&#123;&#125;: &#123;&#125;&#x27;.format(i, item))# --默认起始索引序号start--# 0: dog# 1: cat# 2: pig# --起始索引序号start=2--# 2: dog# 3: cat# 4: pig 使用.format()格式化打印元素和序号，格式为：两位数序号.+空格+四位数据，右对齐。 12345678910fib_list = [1, 2, 4, 5, 8, 13, 21, 34, 55, 89, 144]format_str = &#x27;&#123;:&gt;2&#125;. &#123;:&gt;4&#125;&#x27;for i, item in enumerate(fib_list, 1): print(format_str.format(i, item))# 1. 1# 2. 2# 3. 4# 4. 5# ... 习题第十五题题目要求： 打印斐波那契数列fib_list = [1、1、2、3、5、8、13、21、34]，输出格式:“第i个元素为XXX”。 分别实现： 手工初始化fib_list，使用range()函数打印斐波那契数列； 手工初始化fib_list，使用enumerate()函数打印斐波那契数列； 代码如下： 12345678fib_list = [1,1,2,3,5,8,3,21,34]for i in range(len(fib_list)): print(&#x27;第&#x27;, i, &#x27;个元素为&#x27;, fib_list[i])print(&#x27;\\n&#x27;)format_str = &#x27;&#123;:&gt;2&#125;&#123;:&gt;1&#125;&#123;:&gt;4&#125;&#123;:&gt;2&#125;&#x27;for i, item in enumerate(fib_list, 1): print(format_str.format(&#x27;第&#x27;, i, &#x27;个元素为&#x27;, item)) 运行结果： 1234567891011121314151617181920第 0 个元素为 1第 1 个元素为 1第 2 个元素为 2第 3 个元素为 3第 4 个元素为 5第 5 个元素为 8第 6 个元素为 3第 7 个元素为 21第 8 个元素为 34 第1个元素为 1 第2个元素为 1 第3个元素为 2 第4个元素为 3 第5个元素为 5 第6个元素为 8 第7个元素为 3 第8个元素为21 第9个元素为34 第十六题题目要求： 斐波那契数列的格式化输出：通过format()格式化字符串输出。模板字符串3个位置索引参数，分别为前个元素、当前元素、当前元素与前一个元素的差；宽度分别设置为3、5、5字宽；由于第1个元素的前一个元素不存在，可以使用if判断只打印索引值大于1的元素输出。 代码如下： 123456fib_list = [1,1,2,3,5,8,3,21,34]format_str = &#x27;&#123;:&gt;3&#125; &#123;:&gt;5&#125; &#123;:&gt;5&#125;&#x27;for i, item in enumerate(fib_list, 1): if i==1: i=i+1 print(format_str.format(fib_list[i-1], item, item-fib_list[i-1])) 运行结果： 123456789 1 1 0 1 1 0 2 2 0 3 3 0 5 5 0 8 8 0 3 3 021 21 034 34 0","categories":[],"tags":[]},{"title":"Python学习笔记4","slug":"Python学习笔记4","date":"2021-06-16T16:21:56.000Z","updated":"2021-06-16T16:25:23.092Z","comments":true,"path":"2021/06/17/py4.html","link":"","permalink":"http://waxll.top/2021/06/17/py4.html","excerpt":"","text":"第四章 数据类型：list列表4.1 列表(序列)的定义任务一：Python内置数据类型知识点： Python内置(build-in)数据类型可以分为数值型和非数值型 数值型：整型(int)、浮点型(float)、布尔型(bool) 、复数型 (complex) 非数值型(序列)：字符串、列表、元组、字典 知识点： 非数值类都是一个 序列 sequence，也可以理解为容器。它们都支持以下功能： 索引取值**[]** 遍历元素for in 计算序列长度、最大/最小值、比较、删除 拼接+运算符和重复*运算符 切片技术 任务二：认识什么是列表列表由一系列按特定顺序排列的元素组成。列表是对象，是集合/容器类型的对象 用方括号（**[]）来表示列表，并用逗号**来分隔其中的元素 下面是一个简单的列表示例，这个列表包含几种自行车： 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles, type(bicycles)) 1、鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters、digits或names）是个不错的主意 2、与Java或C的数组区别： 数组的数据类型必须是一样，而列表可以不一样； 数组长度事先声明固定长度，列表长度可增可减 3、Python列表元素可以是任意类型 123things = [1, &#x27;car&#x27;, 4.2, [2, 1]]print(things, type(things))print(id(things)) 习题：1、输入你最喜欢的四个朋友，并把她们名字打印(英语名) 2、使用type() 查看类型 3、id() 查看列表引用地址 123names = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;ONeal&#x27;,&#x27;Jordan&#x27;]print(names, type(names))print(id(names)) 12[&#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;ONeal&#x27;, &#x27;Jordan&#x27;] &lt;class &#x27;list&#x27;&gt;2203212688320 4.1.1 访问列表元素任务一：使用索引访问列表元素列表是有序的容器类数据类型，要访问列表元素，只需将该元素的位置或索引 即列表名[索引]。列表的第1个元素索引从0开始。例如，下面的代码从列表bicycles中提取第一款自行车： 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[3]) #索引值为当前位置-1 当你请求获取列表元素时，Python只返回该元素，而不包括方括号和引号：trek。可以进一步对返回的列表元素调用特定的方法。例如，可使用方法**title()让元素‘trek’**格式更整洁： 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[0].title(), bicycles[1].upper(), bicycles[2].lower()) 这个示例的输出与前一个示例相同，只是首字母T是大写的 任务二：列表的索引知识点：元素索引 列表的索引从0 开始 所谓的索引就是元素在列表中的位置编号，索引又名为下标序号。 从列表中取值时，如果超出索引范围，程序触发异常IndexError 4.1.2 索引访问任务一：第1个元素的索引是0知识点： 在Python中，第一个列表元素的索引为0，而不是1 第二个列表元素的索引为1 根据这种简单的计数方式，要访问列表的任何元素，都可将其位置减1，并将结果作为索引 例如，要访问第4个列表元素，可使用索引3 下面的代码访问索引1和3处的自行车，这些代码返回列表中的第二个和第四个元素： 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[1])print(bicycles[3]) 知识点： Python为列表提供了一种更强大的元素访问机制，切片索引，来获得一个区间索引中的元素 切片索引区间：list[n:m]索引，其中n为起始，m为终止，元素区间**[n,m)**返回索引为n到m-1的元素 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;,&#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[1:]) 知识点： 负索引(重要)：在不知道列表长度的情况下访问最后的元素 Python为访问最后一个列表元素提供了一种特殊语法 通过将索引指定为**-1，返回最后一个列表元素** 123print(&#x27;---------倒数第一个元素是-1索引---------&#x27;)bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[-2]) 这些代码返回**’specialized’。这种约定也适用于其他负数索引，例如，索引-2返回倒数第二个列表元素，索引-3**返回倒数第三个列表元素，以此类推 4.1.3 使用列表中的值任务一：如何使用列表中的元素值知识点： 使用索引得到的元素进行后续操作。 例如，可以使用拼接根据列表中的值来创建消息 下面来尝试从列表中提取第一款自行车，并使用这个值来创建一条消息： 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]message = &quot;My first bicycle was a &quot; + bicycles[0].title() + &quot;.&quot;print(message) 使用bicycles[0]的值生成了一个句子，并将其存储在变量message中。输出是一个简单的句子，其中包含列表中的第一款自行车：My first bicycle was a Trek. 习题：1、将一些朋友的姓名存储在一个列表中，并将其命名为names。依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来 12names = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]print(names) 123JamesKobeJordan 2、继续上一题，但不打印每个朋友的姓名，而为每人打印一条消息。每条消息都包含相同的问候语，但抬头为相应朋友的姓名 1234names = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]print(names[0] + &quot;,&quot; + &quot; how is everything going on &quot; + &quot;?&quot;) print(names[1] + &quot;,&quot; + &quot; how is everything going on &quot; + &quot;?&quot;)print(names[2] + &quot;,&quot; + &quot; how is everything going on &quot; + &quot;?&quot;) 123James, how is everything going on ?Kobe, how is everything going on ?Jordan, how is everything going on ? 3、为朋友输入他们喜欢的交通方式，如骑摩托车或开汽车，并创建一个包含多种交通方式的列表。根据该列表打印一系列有关这些交通方式的宣言，朋友名字和交通工具字符为全大写，如“Lilei would like to own a Honda motorcycle” 12345names = [&#x27;JAMES&#x27;,&#x27;KOBE&#x27;,&#x27;JORDAN&#x27;]transportations =[&#x27;BIKE&#x27;,&#x27;MOTORCYCLE&#x27;,&#x27;CAR&#x27;]print(names[0] + &quot; would like to ride a &quot; + transportations[0] + &quot;.&quot;)print(names[1] + &quot; would like to ride a &quot; + transportations[1] + &quot;.&quot;)print(names[2] + &quot; would like to drive a &quot; + transportations[2] + &quot;.&quot;) 123JAMES would like to ride a BIKE.KOBE would like to ride a MOTORCYCLE.JORDAN would like to drive a CAR. 4.1.4 列表的通用操作4.2（重要）变量内涵任务一：变量的内涵变量是Python语言最基本的元素。变量是指向具体数据(对象)的地址引用 123a = `python`b = 1b = b + 1 变量：门牌号；具体内容：房间 通过赋值(=)语句进行关联 误区：变量中直接存储了具体了数据/对象。程序通过变量来间接访问和操作变量所指的对象 变量中存的地址引用可通过**id()**查看 python内存共享优化机制： 在python中，所有的对象(变量所指向的具体内容)都存活在系统堆上 对于小整数和字符串对象，可能在程序中会经常的使用。如果将这些经常使用的小整数对象也放在系统堆上，python就会经常的在堆上申请空间，释放空间，会严重的影响python的整体性能 对于小整数和字符串(不可变对象)对象做了一些优化，通过使用了对象池技术，将它们驻留在程序缓存中 变量共享引用相同的地址，小整数[-5,256] 和 字符串(不含空格) 123a = &#x27;trek1111 111111111111111111111111111111&#x27; b = &#x27;trek1111 111111111111111111111111111111&#x27; print(id(a), id(b), a is b) 1234567891011bicycles1 = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]bicycles2 = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(&#x27;bicycles1 id:&#x27;, id(bicycles1))print(&#x27;bicycles2 id:&#x27;, id(bicycles2))print(&#x27;bicycles1[0] id:&#x27;, id(bicycles1[0])) # 常量字符串共享内存print(&#x27;bicycles2[0] id:&#x27;, id(bicycles2[0]))print(&#x27;-------通过is关键字判断两个对象是否是同一个对象(否是来自同个内存地址的数据)----&#x27;)print(bicycles1 is bicycles2)print(bicycles1[0] is bicycles2[0]) 4.3 修改、添加和删除列表元素4.3.1 修改元素知识点：修改列表元素的语法与访问列表元素的语法类似 首先可指定列表名和要修改的元素的索引； 再通过赋值语句，为该元素赋新的值 例如，假设有一个摩托车列表，其中的第一个元素为**’honda’**，如何修改它的值呢？ 12345678motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)# [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]#motorcycles[0] = [[111,111,111],&#x27;hello&#x27;] # 列表元素存的是指向具体内容的内存地址！！motorcycles[0] = &#x27;ducati&#x27;print(motorcycles)# [&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;] 首先定义一个摩托车列表，其中的第一个元素为**’honda’** 接下来，将第一个元素的值改为**’ducati’** 输出表明，第一个元素的值确实变了，但其他列表元素的值没变 4.3.2 添加元素补充知识：Python是面向对象编程语言 通俗讲对象就是某种类型的变量 比如字符串对象，整形对象，浮点数对象等 在python中，可以按需求自定义类型，设计新的类 从面向对象OO(Object Oriented)的概念来讲，对象是类的一个实例；类是对象/实例的类型 比如str message，这里的str是类，而message是str类型的对象或str类型的实例 任务一：在列表末尾添加元素append()知识点： append()方法用于在列表末尾动态添加新的对象 语法：list.append(obj) 参数：obj为添加到列表末尾的元素 返回：该方法无返回值，直接会修改原来的列表 1234list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]list1.append(&#x27;Baidu&#x27;)print (&quot;更新后的列表 : &quot;, list1)# 更新后的列表 : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;] 例子：继续使用前一个示例中的列表，在其末尾添加新元素**’ducati’。方法append()将元素‘ducati’**添加到了列表末尾，而不影响列表中的其他所有元素 1234motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]motorcycles.append(&#x27;ducati&#x27;)print(motorcycles)# [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;] 任务二：创建空列表并动态添加元素知识点： 经常要等程序运行后，你才知道用户要在程序中存储哪些数据 为控制用户，可首先创建一个空列表，用于存储用户将要输入的值，然后将用户提供的每个新值附加到列表中 此外，方法append()让动态地创建列表易如反掌。例如，可以先创建一个空列表，再使用一系列的append()语句添加元素。下面来创建一个空列表，再在其中添加元素‘honda’、‘yamaha’和‘suzuki‘，最终的列表与前述示例中的列表完全相同： 1234567motorcycles = [] # 创建空列表motorcycles.append(&#x27;honda&#x27;)print(motorcycles)motorcycles.append(&#x27;yamaha&#x27;)print(motorcycles)motorcycles.append(&#x27;suzuki&#x27;)print(motorcycles) 任务三：在列表的指定位置插入新元素insert()知识点： insert()方法用于将指定对象插入列表的指定位置。为此，需要指定新元素(对象)的索引和值 语法：list.insert(index, obj) . 可以看作是该方法的对象作用域。指明该方法仅仅是针对某个具体的list对象进行操作 参数：index为元素obj需要插入的索引位置 参数：obj为添加到列表的元素 返回：该方法无返回值，但会在列表指定位置插入对象 注意：将列表中原索引(包括)之后的所有元素都右移一个位置 1234list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]list1.insert(1, &#x27;Baidu&#x27;)print (&#x27;列表插入元素后为 : &#x27;, list1)# 列表插入元素后为 : [&#x27;Google&#x27;, &#x27;Baidu&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;] 例子：将值**’ducati**’存储到这个地方 1234motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]motorcycles.insert(1,&#x27;ducati&#x27;)print(motorcycles)# [&#x27;honda&#x27;, &#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;] 4.3.3 删除元素知识点： 根据位置或值从列表中删除一个或多个元素 玩家将空中的一个外星人射杀后，那么就要将其从存活的外星人列表中删除； 当用户在你创建的Web网站中注销登录的账户时，将该用户从活跃用户列表中删除 任务一：使用del语句删除元素知识点： 语法：del list[index] 描述：del方法用于将指定位置的列表元素永久删除。为此，需要指定删除元素的索引 del其实并不属于列表的方法或者函数 list[index]为特定列表list的index索引位置的原始 条件：使用del可删除任何位置处的列表元素，条件是知道其索引 注意：del是直接删除list元素内容，无法再访问被删除的元素 例子：使用del删除了列表motorcycles中的第一个元素——**’honda’** 123456789motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]del motorcycles[0]print(motorcycles)# [&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]del motorcycles[0]print(motorcycles)# [&#x27;suzuki&#x27;] 任务二：使用方法pop()删除元素知识点： 语法：obj list.pop([index=-1]) 描述：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 将元素从列表中删除，并接着使用它的值 参数: 带方括号的参数指可选参数 **[index=-1]**可选参数，指明要移除列表元素的索引值，不能超过列表总长度，默认为 index=-1，删除最后一个列表值 返回值: 该方法返回从列表中移除的元素对象obj 例子：下面从列表motorcycles中弹出一款摩托车： 123456motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]popped_motorcycle = motorcycles.pop()print(motorcycles)# [&#x27;honda&#x27;, &#x27;yamaha&#x27;]print(popped_motorcycle)# suzuki 分析： 首先定义并打印了列表motorcycles 接下来，我们从这个列表中弹出一个值，并将其存储到变量popped_motorcycle中 然后我们打印这个列表，以核实从其中删除了一个值 最后，我们打印弹出的值，以证明我们依然能够访问被删除的值 输出表明，列表末尾的值**’suzuki’已删除，它现在存储在变量popped_motorcycle**中 知识点： 方法**pop()**是怎么起作用的呢？ 被删除的元素还有用于他用 假设列表中的摩托车是按购买时间存储的，就可使用方法**pop()**打印一条消息，指出最后购买的是哪款摩托车，输出是一个简单的句子，指出了最新购买的是哪款摩托车： 1234motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]last_owned = motorcycles.pop()print(&quot;The last motorcycle I owned was a &quot; + last_owned.title() + &quot;.&quot;)# The last motorcycle I owned was a Suzuki. 任务三：pop()列表中任何位置处的元素实际上，你可以使用pop()来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可 1234567motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)print(&quot;---------first_owned = motorcycles.pop(-1)---------&quot;)first_owned = motorcycles.pop(0)print(motorcycles)print(&#x27;The first motorcycle I owned was a &#x27; + first_owned.title() + &#x27;.&#x27;)# The first motorcycle I owned was a Honda. 首先，弹出列表中的第一款摩托车，然后打印了一条有关这辆摩托车的消息 输出是一个简单的句子，描述了我购买的第一辆摩托车 知识点： 每当使用pop()时，被弹出的元素就不再在列表中了 如果不确定该使用del语句还是**pop()**方法，下面是一个简单的判断标准： 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句； 如果你要在删除元素后还能继续使用它，就使用方法pop() 任务四：使用remove()方法，根据值删除元素知识点： 语法：list.remove(obj) 描述：remove()方法用于移除列表中某个值的第一个匹配项 参数: obj为列表中要移除的元素 返回值：该方法没有返回值，但是会移除列表中的某个值的第一个匹配项 条件：只要知道要删除的元素的值 12345678list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]list1.remove(&#x27;Taobao&#x27;)print (&quot;列表现在为 : &quot;, list1)# 列表现在为 : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Baidu&#x27;]list1.remove(&#x27;Baidu&#x27;)print (&quot;列表现在为 : &quot;, list1)# 列表现在为 : [&#x27;Google&#x27;, &#x27;Runoob&#x27;] 知识点：**remove()**返回值为空 例子：从列表motorcycles中删除值**’ducati’。通过调用remove()方法，查询‘ducati’**出现在列表的什么地方，并将该元素删除： 123456motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]res = motorcycles.remove(&#x27;yamaha&#x27;)print(motorcycles)# [&#x27;honda&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]print(res)# None remove()返回值为空 例子：下面删除值**’ducati’**，并打印一条消息，指出要将其从列表中删除的原因 1234567motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;, &#x27;yamaha&#x27; , &#x27;ducati&#x27;]print(motorcycles)too_expensive = &#x27;ducati&#x27; # 该变量为remove()所删除的元素motorcycles.remove(too_expensive)print(motorcycles)print(&quot;\\nA &quot; + too_expensive.title() + &quot; is too expensive for me.&quot;) 定义列表后，我们将值**’ducati’存储在变量too_expensive**中 接下来，我们使用这个变量来告诉Python将哪个值从列表中删除 最后，值**’ducati’已经从列表中删除，但它还存储在变量too_expensive中，让我们能够打印一条消息，指出将‘ducati’从列表motorcycles**中删除的原因 知识点： remove()只删除第一个指定的值 如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值 习题：1、3-4 嘉宾名单：如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），你会邀请哪些人？请创建一个列表，其中包含至少3个你想邀请的人；然后，使用这个列表打印消息，邀请这些人来与你共进晚餐 1234customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]print(&quot;Wish &quot; + customs[0] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[1] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[2] + &quot; would attend my party&quot;) 123Wish James would attend my partyWish Kobe would attend my partyWish Jordan would attend my party 2、3-5 修改嘉宾名单：你刚得知有位嘉宾无法赴约，因此需要另外邀请一位嘉宾 以完成练习3-4 时编写的程序为基础，在程序末尾添加一条print语句，指出哪位嘉宾无法赴约 修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名 再次打印一系列消息，向名单中的每位嘉宾发出邀请 123456customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]print(customs[2] + &quot; can`t attend the party&quot;)customs[2] = &#x27;ONeal&#x27;print(&quot;Wish &quot; + customs[0] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[1] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[2] + &quot; would attend my party&quot;) 1234Jordan can`t attend the partyWish James would attend my partyWish Kobe would attend my partyWish ONeal would attend my party 3、3-6 添加嘉宾：你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾 以完成练习3-4 或练习3-5时编写的程序为基础，在程序末尾添加一条print语句，指出你找到了一个更大的餐桌 使用**insert()**将一位新嘉宾添加到名单开头 使用**insert()**将另一位新嘉宾添加到名单中间 使用**append()**将最后一位新嘉宾添加到名单末尾 打印一系列消息，向名单中的每位嘉宾发出邀请 123456789101112customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]customs[2] = &#x27;ONeal&#x27;print(&quot;I found a bigger table&quot;)customs.insert(0 ,&#x27;Curry&#x27;)customs.insert(int(len(customs) / 2) ,&#x27;Garnett&#x27;)customs.append(&#x27;Davis&#x27;)print(&quot;Wish &quot; + customs[0] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[1] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[2] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[3] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[4] + &quot; would attend my party&quot;)print(&quot;Wish &quot; + customs[5] + &quot; would attend my party&quot;) 1234567I found a bigger tableWish Curry would attend my partyWish James would attend my partyWish Garnett would attend my partyWish Kobe would attend my partyWish ONeal would attend my partyWish Davis would attend my party 4、3-7 缩减名单：你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾 以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息 使用**pop()**不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐 对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列 使用del将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的 1234567891011customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]customs[2] = &#x27;ONeal&#x27;customs.insert(0 ,&#x27;Curry&#x27;)customs.insert(int(len(customs) / 2) ,&#x27;Garnett&#x27;)customs.append(&#x27;Davis&#x27;)print(&quot;I can only invite two customs to the party&quot;)while len(customs) != 2 : custom= customs.pop() print(custom + &quot;, I`m sorry. You can`t attend this party&quot;)del customs[:]print(customs) 123456I can only invite two customs to the partyDavis, I`m sorry. You can`t attend this partyONeal, I`m sorry. You can`t attend this partyKobe, I`m sorry. You can`t attend this partyGarnett, I`m sorry. You can`t attend this party[] 4.3.4 将列表用作栈和队列任务一：将列表用作栈和队列知识点：列表实现栈 栈是通常所说的一种LIFO(Last In First Out 后进先出)数据结构 它的意思是最后进入的数据第一个出来 一个最简单的例子往一端封闭的管道放入一些弹珠然后取出来，如果想把弹珠取出来，必须从最后放入弹珠的位置挨个拿出来。 使用**append()**将元素追加到列表尾部 使用 pop() 将最后个的元素弹出列 1234567891011121314151617a = [1, 2, 3, 4, 5, 6]print(&#x27;出栈之前的列表：&#x27;, a)print(&#x27;pop()栈尾部弹出元素：&#x27;, a.pop())# pop()栈尾部弹出元素： 6print(&#x27;pop()栈尾部弹出元素：&#x27;, a.pop())# pop()栈尾部弹出元素： 5print(&#x27;pop()栈尾部弹出元素：&#x27;, a.pop())# pop()栈尾部弹出元素： 4print(&#x27;pop()栈尾部弹出元素：&#x27;, a.pop())# pop()栈尾部弹出元素： 3print(&#x27;出栈之后的列表：&#x27;, a)# 出栈之后的列表： [1, 2]a.append(34)print(&#x27;append()栈尾部加入元素：&#x27;, a)# append()栈尾部加入元素： [1, 2, 34] 上面的代码中使用了一个列表的 **pop()和append()**方法实现出栈和入栈操作 知识点：列表实现队列 在日常生活中会经常遇到队列，比如售票窗口、图书馆、超市的结账出口 队列 是一种在末尾追加数据以及在开始弹出数据的数据结构 与栈不同，它是 FIFO(First In First Out 先进先出)的数据结构 使用**append()**将元素追加到列表尾部 使用 pop(0) 将第0位置的元素弹出列表 12345678910111213a = [1, 2, 3, 4, 5]print(&#x27;出栈之前的列表：&#x27;, a)# 出栈之前的列表： [1, 2, 3, 4, 5]a.append(1)print(&#x27;append()队列尾部加入元素：&#x27;, a)# append()队列尾部加入元素： [1, 2, 3, 4, 5, 1]print(&#x27;pop(0)队列首部弹出元素：&#x27;, a.pop(0))# pop(0)队列首部弹出元素： 1print(&#x27;pop(0)队列首部弹出元素：&#x27;, a.pop(0))# pop(0)队列首部弹出元素： 2print(&#x27;出队列之后的列表：&#x27;, a)# 出队列之后的列表： [3, 4, 5, 1] 4.4 列表的排序4.4.1 list.sort()方法进行永久性排序任务一：列表的永久排序所谓永久性排序，指调用**list.sort()**方法会改变原列表 知识点： 描述：list.sort()方法用于对列表进行排序；默认情况下，sort()方法对列表进行(ascending)升序排序；还可以通过自定义比较函数来设置排序规则 语法：list.sort(reverse=False|True, key=myFunc) 参数: reverse – 可选。reverse=True 将对列表进行降序排序。默认是 reverse=False key – 可选。指定排序标准的函数 返回值：该方法没有返回值 该排序方法会修改了列表list元素的排列顺序 123456# vowels listvowels = [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27;i&#x27;]print(&#x27;排序前的list:&#x27;, vowels)vowels.sort()print(&#x27;排序后的list:&#x27;, vowels) 例子：假设你有一个汽车列表，并要让其中的汽车按字母顺序排列。为简化这项任务，假设该列表中的所有值都是小写的 1234567891011cars = [&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;abmw&#x27;, &#x27;abudi&#x27;]print(cars)print(&#x27;------------cars.sort()--------------&#x27;)print(&#x27;------通过print(cars)发现sort()方法永久改变原列表------------&#x27;)cars.sort()print(cars)print(&#x27;------------cars.sort(reverse=True) 降序排列--------------&#x27;)cars.sort(reverse=True)print(cars) 方法sort()永久性地修改了列表元素的排列顺序。现在，汽车是按字母顺序排列的，再也无法恢复到原来的排列顺序 还可以按与字母顺序相反的顺序排列列表元素，为此，只需向sort()方法传递参数reverse=True 任务二：通过sort()的参数key，自定义排序规则例子：按照值的长度对列表进行排序： 123456789101112# 定义函数：返回值为元素的长度def myFunc(e): #e为形参 return len(e)cars = [&#x27;toyotaa&#x27;, &#x27;subaru&#x27;, &#x27;abmw&#x27;, &#x27;abudi&#x27;]print(&#x27;原来的list:&#x27;, cars)cars.sort(key=myFunc)print(&#x27;排序(升序)后的list&#x27;, cars)cars.sort(reverse=True, key=myFunc)print(&#x27;排序(降序)后的list&#x27;, cars) 例子：按二维数组的第二个元素值进行排序 12345678def takeSecond(elem): return elem[1]digits = [[2, 2], [3, 4], [4, 1], [1, 3]]print(&#x27;排序前的list:&#x27;, digits)digits.sort(key=takeSecond)print(&#x27;排序后的list:&#x27;, digits) 练习：1、输入5个数，存到列表中，然后使用**sort()**，对该列表进行按升序、降序进行排序，并输出结果 123456numbers = [&#x27;3&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;5&#x27;]print(numbers)numbers.sort()print(numbers)numbers.sort(reverse=True)print(numbers) 123[&#x27;3&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;5&#x27;][&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;][&#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;] 2、构造拥有5个城市名字元素的列表cities，然后使用**sort()**，对该列表进行按升序、降序、字符串长度方式进行排序，并输出结果 12345citis = [&#x27;China&#x27;, &#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;England&#x27;,&#x27;Japan&#x27;]another_city = sorted(citis)print(&#x27;sorted()排序后(升序默认):&#x27;,another_city)another_city.sort(reverse = True)print(&#x27;list.sort()排序后(降序):&#x27;,another_city) 12sorted()排序后(升序默认): [&#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;China&#x27;, &#x27;England&#x27;, &#x27;Japan&#x27;]list.sort()排序后(降序): [&#x27;Japan&#x27;, &#x27;England&#x27;, &#x27;China&#x27;, &#x27;Canada&#x27;, &#x27;America&#x27;] 4.4.2 sorted()函数进行临时排序任务一：列表的临时排序list.sort()方法是将排序结果覆盖修改原列表 新需求：希望得到列表的排序，但而不希望对原列表进行修改。函数**sorted()**让我们能够对列表进行元素排序(返回一个新的临时列表)，但不影响原始排列顺序 知识点： 描述： sorted() 函数对所有可迭代的对象进行排序操作 语法：sorted(iterable, key=None, reverse=False) 参数： iterable – 可迭代对象。通俗讲是该对象的元素是可以被循环遍历的。通常是集合或序列类型，比如list, str key – 可选。指定排序标准的函数 reverse – 可选。reverse=True 将对列表进行降序排序。默认是 reverse=False 返回值：返回重新排序的列表(与原列表无关) 注意：传进去的是可迭代对象，而返回的是列表(非原来对象类型) 123456789# list 列表对象py_list = [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27;i&#x27;]print(&#x27;排序前:&#x27;, py_list)print(&#x27;排序后:&#x27;, sorted(py_list))# string 字符串对象py_string = &#x27;Python&#x27;print(&#x27;排序前:&#x27;, py_string)print(&#x27;排序后:&#x27;, sorted(py_string, reverse=True)) 任务二：自定义排序规则**sorted()**函数的第二个元素的值为自定义排序规则 1234567def takeSecond(elem): return elem[1]digits = [[2, 2], [3, 4], [4, 1], [1, 3]]print(&#x27;排序前:&#x27;, digits)print(&#x27;排序后:&#x27;, sorted(digits, key=takeSecond))print(&#x27;原来列表:&#x27;, digits) 1234567891011cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]print(&#x27;排序前:&#x27;,cars) #按原始顺序打印列表another_car = sorted(cars) #调用sorted(),按字母顺序排序列表print(&#x27;sorted()排序后(升序默认):&#x27;,another_car)another_car.sort(reverse = True) #调用sorted(),按字母降序排序列表print(&#x27;list.sort()排序后(降序):&#x27;,another_car)print(&#x27;原列表, sorted()并不改变原列表:&#x27;,cars) 任务三：sorted()是python的一个全局函数知识点： sorted()是python的一个全局函数，不是list的方法，因此不能通过**list.sorted()**方式调用 方法：属于对象的函数 函数：全局函数 12print(&quot;------------不能通过cars.sorted()-------------&quot;)print(cars.sorted()) 4.4.3 list.reverse()方法对列表进行逆序要反转列表元素的排列顺序，可使用方法list.reverse() 知识点： 描述：**list.reverse()**方法反转元素的排序顺序 语法：list.reverse() 参数：无 返回值：无 注意：永久性的修改原列表 假设汽车列表是按购买时间排列的，可轻松地按相反的顺序排列其中的汽车： 12345678cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]print(&#x27;原列表：&#x27;, cars)cars.reverse()print(&#x27;reverse()后的列表：&#x27;,cars)cars.reverse()print(&#x27;再次reverse()后的列表：&#x27;,cars) 知识点： reverse()不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序 方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用**reverse()**即可 习题：1、创建一个列表，通过**reverse()**对元素顺序进行翻转，再恢复原来的排序 123456names = [&#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;Jordan&#x27;, &#x27;ONeal&#x27;]print(&#x27;原列表：&#x27;, names)names.reverse()print(&#x27;reverse()后的列表：&#x27;,names)names.reverse()print(&#x27;再次reverse()后的列表：&#x27;,names) 123原列表： [&#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;Jordan&#x27;, &#x27;ONeal&#x27;]reverse()后的列表： [&#x27;ONeal&#x27;, &#x27;Jordan&#x27;, &#x27;Kobe&#x27;, &#x27;James&#x27;]再次reverse()后的列表： [&#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;Jordan&#x27;, &#x27;ONeal&#x27;] 2、输入多个字符串，存在列表中，然后调用**reverse()**对元素顺序进行翻转，并输出结果 1234messages = [&quot;Hello Python world!&quot;,&quot;James&quot;,&quot;Kobe&quot;,&quot;Jordan&quot;]print(&#x27;原列表：&#x27;, messages)messages.reverse()print(&#x27;reverse()后的列表：&#x27;,messages) 12原列表： [&#x27;Hello Python world!&#x27;, &#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;Jordan&#x27;]reverse()后的列表： [&#x27;Jordan&#x27;, &#x27;Kobe&#x27;, &#x27;James&#x27;, &#x27;Hello Python world!&#x27;] 4.4.4 len()函数查询长度任务一：使用len()查询列表长度知识点： 描述：**len()**函数获得列表的长度 语法：len(object) 参数：集合或序列类型的对象。比如list，str等 返回：长度值 属性：Python的build-in(内建)函数。所谓内建，就是Python自带的函数，类似于sorted() 在下面的示例中，列表包含4个元素，因此其长度为4： 12cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]print(&#x27;长度：&#x27;,len(cars)) 12mylist = &quot;Hello&quot;print(&#x27;长度：&#x27;, len(mylist)) 12a = 1len(a) 习题：3-8 放眼世界：想出至少5个你渴望去旅游的地方 将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的 按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表 使用**sorted()**按字母顺序打印这个列表，同时不要修改它 再次打印该列表，核实排列顺序未变 使用**sorted()**按与字母顺序相反的顺序打印这个列表，同时不要修改它 再次打印该列表，核实排列顺序未变 使用**reverse()**修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了 使用**reverse()**再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序 使用**sort()**修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了 使用**sort()**修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了 1234567891011121314places =[&#x27;Japan&#x27;,&#x27;America&#x27;,&#x27;Canada&#x27;,&#x27;Switzerland&#x27;,&#x27;Norway&#x27;]print(places)print(sorted(places))print(places)print(sorted(places,reverse = True))print(places)places.reverse()print(places)places.reverse()print(places)places.sort()print(places)places.sort(reverse = True)print(places) 123456789[&#x27;Japan&#x27;, &#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Switzerland&#x27;, &#x27;Norway&#x27;][&#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Japan&#x27;, &#x27;Norway&#x27;, &#x27;Switzerland&#x27;][&#x27;Japan&#x27;, &#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Switzerland&#x27;, &#x27;Norway&#x27;][&#x27;Switzerland&#x27;, &#x27;Norway&#x27;, &#x27;Japan&#x27;, &#x27;Canada&#x27;, &#x27;America&#x27;][&#x27;Japan&#x27;, &#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Switzerland&#x27;, &#x27;Norway&#x27;][&#x27;Norway&#x27;, &#x27;Switzerland&#x27;, &#x27;Canada&#x27;, &#x27;America&#x27;, &#x27;Japan&#x27;][&#x27;Japan&#x27;, &#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Switzerland&#x27;, &#x27;Norway&#x27;][&#x27;America&#x27;, &#x27;Canada&#x27;, &#x27;Japan&#x27;, &#x27;Norway&#x27;, &#x27;Switzerland&#x27;][&#x27;Switzerland&#x27;, &#x27;Norway&#x27;, &#x27;Japan&#x27;, &#x27;Canada&#x27;, &#x27;America&#x27;] 3-9 晚餐嘉宾：在完成练习3-4~练习3-7时编写的程序之一中，使用**len()**打印一条消息，指出你邀请了多少位嘉宾来与你共进晚餐 1234567customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]customs[2] = &#x27;ONeal&#x27;print(&quot;I found a bigger table&quot;)customs.insert(0 ,&#x27;Curry&#x27;)customs.insert(int(len(customs) / 2) ,&#x27;Garnett&#x27;)customs.append(&#x27;Davis&#x27;)print(len(customs)) 12I found a bigger table6 3-10 尝试使用各个函数：想想可存储到列表中的东西，如山岳、河流、国家、城市、语言或你喜欢的任何东西。编写一个程序，在其中创建一个包含这些元素的列表，然后，对于本章介绍的每个函数，都至少使用一次来处理这个列表 12345678910111213141516customs = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]customs[2] = &#x27;ONeal&#x27;customs.insert(0 ,&#x27;Curry&#x27;)customs.insert(int(len(customs) / 2) ,&#x27;Garnett&#x27;)customs.append(&#x27;Davis&#x27;)print(len(customs))print(sorted(customs))customs.sort()print(customs)customs.reverse()print(customs)print(customs.pop())customs.remove(&#x27;Kobe&#x27;)print(customs)del customs[:]print(customs) 12345676[&#x27;Curry&#x27;, &#x27;Davis&#x27;, &#x27;Garnett&#x27;, &#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;ONeal&#x27;][&#x27;Curry&#x27;, &#x27;Davis&#x27;, &#x27;Garnett&#x27;, &#x27;James&#x27;, &#x27;Kobe&#x27;, &#x27;ONeal&#x27;][&#x27;ONeal&#x27;, &#x27;Kobe&#x27;, &#x27;James&#x27;, &#x27;Garnett&#x27;, &#x27;Davis&#x27;, &#x27;Curry&#x27;]Curry[&#x27;ONeal&#x27;, &#x27;James&#x27;, &#x27;Garnett&#x27;, &#x27;Davis&#x27;][] 4.4.5 列表list常用操作4.5 使用列表时避免索引错误任务一：熟悉列表常见的索引错误刚开始使用列表时，经常会遇到一种错误。假设你有一个包含三个元素的列表，想获得最后一个元素，误用索引为3： 12motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles[3]) Python试图向你提供位于索引3处的元素，但它搜索列表motorcycles时，却发现索引3处没有元素。鉴于列表索引差一的特征，这种错误很常见。有些人从1开始数，因此以为第三个元素的索引为3；但在Python中，第三个元素的索引为2，因为索引是从0开始的 知识点： 索引错误意味着Python无法理解你指定的索引 程序发生索引错误时，请尝试将你指定的索引减1，然后再次运行程序，看看结果是否正确 每当需要访问最后一个列表元素时，都可使用索引**-1**。对于列表长度发生变化的情形特别有效： 12motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles[-1]) 索引**-1总是返回最后一个列表元素，这里为值‘suzuki’**。仅当列表为空时，这种访问最后一个元素的方式才会导致错误： 123motorcycles = []print(motorcycles, len(motorcycles))print(motorcycles[-1]) 知识点： 找不到解决办法时，请尝试将列表或其长度打印出来 列表可能与想象中的截然不同，在程序对其进行了动态处理时尤其如此。通过查看列表或其包含的元素数，可帮助找出这种逻辑错误 习题：3-11 有意引发错误：如果你还没有在程序中遇到过索引错误，就尝试引发一个这种错误。在你的一个程序中，修改其中的索引，以引发索引错误。关闭程序前，务必消除这个错误 12names = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]print(names[3]) 1234567---------------------------------------------------------------------------IndexError Traceback (most recent call last)&lt;ipython-input-97-8e4ac68e70ad&gt; in &lt;module&gt; 1 names = [&#x27;James&#x27;,&#x27;Kobe&#x27;,&#x27;Jordan&#x27;]----&gt; 2 print(names[3])IndexError: list index out of range","categories":[],"tags":[]},{"title":"Python学习笔记3","slug":"Python学习笔记3","date":"2021-04-01T13:51:14.000Z","updated":"2021-04-01T13:56:12.487Z","comments":true,"path":"2021/04/01/p3.html","link":"","permalink":"http://waxll.top/2021/04/01/p3.html","excerpt":"","text":"第三章 数据类型：字符串字符串字符串使用语法使用引号创建字符串类型数据 知识点： 字符串就是一系列字符。 使用引号创建字符串，引号必须要用英文输入法，中文会出错！。 用引号括起的都是字符串，可以是单引号，也可以是双引号。 字面量：直接通过引号创建的字符串称为字面量。 1234&quot;This is a string.&quot;&#x27;This is also a string.&#x27;#&#x27;This is also a string.&#x27; 通过print在Jupyter中输出所有内容 知识点： Jupyter只输出最后一个字符串。 使用print()函数输出需要输出的内容(不仅是字符串，也可是变量值)。 12345print(&quot;This is a string.&quot;)print(&#x27;This is also a string.&#x27;)#This is a string.#This is also a string. 正确使用引号创建字符串类型数据 知识点： 由于引号在python中有特殊意义，用于标识字符串的起止标识。 如果在&quot;&quot;双引号作为标识的字符串中使用&quot;字符，那么，python就只能把&quot;错误地解析为起止标识，而无法解析为该&quot;字符本身，进而引发语法错误。 为了解决此歧义问题，Python引入了转移字符技术，即通过转义字符\\&#39;和\\&quot;方式来明确告诉Python，当前的字符解析为字符本身，而非起止标识。 123456789print(&#x27;-----------两种引号的嵌套使用------------&#x27;)print(&#x27;I told my friend, &quot;Python is my favorite language!&quot;&#x27;)print(&quot;The language \\&#x27;Python\\&quot; is named after Monty Python.&quot;)print(&quot;One of Python&#x27;s strengths is its diverse.&quot;)#-----------两种引号的嵌套使用------------#I told my friend, &quot;Python is my favorite language!&quot;#The language &#x27;Python&quot; is named after Monty Python.#One of Python&#x27;s strengths is its diverse. 习题 第1题 第2题 第3题 使用方法修改字符串的大小写使用方法title()修改字符串为首字母大写 知识点： Python的字符串敏感于大小写。 比如Ada和ada是不同的字符串。 方法：在类中定义的函数。这里的类指的是特定的类型。 比如在字符串类型str中定义了字符串首字母大写转换函数title()。 方法的调用：变量名.方法()。 首先，创建该类型的变量。 然后，通过该变量来调用对应的方法。 具体程序如下： 123456name = &quot;ada lovelace&quot; # 创建该类型的变量print(type(name)) # &lt;class &#x27;str&#x27;&gt; 查询变量类型print(name.title()) # Ada Lovelace，通过该变量来调用对应的方法# &lt;class &#x27;str&#x27;&gt;# Ada Lovelace 在这个示例中，小写的字符串&quot;ada lovelace&quot;存储到了变量name中。 在print()语句中，方法title()出现在这个变量(对象)的后面。 在name.title()中，name后面的句点（.）让Python对变量name执行方法title()指定的操作。 每个方法后面都跟着一对括号，为方法传入额外的参数(信息)。 函数title()不需要额外的信息，因此它后面的括号是空的。 title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。这很有用，因为你经常需要将名字视为信息。例如，你可能希望程序将值Ada、ADA和ada视为同一个名字，并将它们都显示为Ada。 使用方法upper()和lower()修改字符串大小写 知识点： # message.lower() : this is string example from runoob….wow!!! # message.upper() : THIS IS STRING EXAMPLE FROM RUNOOB….WOW!!!str.lower()：转换字符串中所有大写字符为小写。 无参数，返回全为小写的字符串。 str.upper()：转换字符串中所有小写字符为大写。 无参数，返回全为大写的字符串。 123456name = &quot;Ada Lovelace&quot;print(name.upper())print(name.lower())# ADA LOVELACE# ada lovelace 123456message = &quot;this is string example from runoob....wow!!!&quot;print(&quot;message.lower() : &quot;, message.lower())print(&quot;message.upper() : &quot;, message.upper())# message.lower() : this is string example from runoob....wow!!!# message.upper() : THIS IS STRING EXAMPLE FROM RUNOOB....WOW!!! 习题 第4题 合并（拼接)字符串字符串拼接操作 知识点： Python使用加号（+）来合并字符串。 拼接的类型必须是字符串，否则会出错。 例如，你可能想将姓和名存储在不同的变量中，等要显示姓名时再将它们合而为一： 12345678print(&quot;--字符串的拼接 通过 + 操作----&quot;)first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = first_name + &quot; &quot; + last_nameprint(full_name)# --字符串的拼接 通过 + 操作----# ada lovelace 在这个示例中，我们使用+来合并first_name、空格和last_name，以得到完整的姓名。这种合并字符串的方法称为拼接。通过拼接，可使用存储在变量中的信息来创建完整的消息。下面来看一个例子： 123456first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = first_name + &quot; &quot; + last_nameprint(&quot;Hello, &quot; + full_name.title() + &quot;!&quot;)# Hello, Ada Lovelace! 将字符串拼接的结果存变量中在这里，一个问候用户的句子中使用了全名，并使用了方法title()来将姓名设置为合适的格式。这些代码显示一条格式良好的简单问候语。还可以使用拼接来创建消息，再把整条消息都存储在一个变量中： 12345678first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = first_name + &quot; &quot; + last_namemessage = &quot;Hello, &quot; + full_name.title() + &quot;!&quot;print(message)# Hello, Ada Lovelace! 上述代码也显示消息“Hello, Ada Lovelace!”，但将这条消息存储在了一个变量中，这让最后的print语句简单得多。 习题 第5题 转义字符使用制表符 知识点： 在程序中，空白泛指任何非打印字符，如空格、制表符和换行符。 可使用空白来组织输出，以使其更易读。 横向制表符：转义字符\\t。 12345print(&quot;\\tPython\\tPython\\tPython\\tPython&quot;)print(&quot;\\tJava\\tJava\\tJava\\tJava&quot;)#Python Python Python Python#Java Java Java Java 使用换行符 知识点： 换行符 ：在字符串中添加换行符，可使用转义字符\\n。 123456print(&quot;Languages:\\nPython\\nC\\nJavaScript&quot;)# Languages:# Python# C# JavaScript 组合使用 知识点： 组合使用：可在同一个字符串中同时包含制表符和换行符。 字符串&quot;\\n\\t&quot;让Python换到下一行，并在下一行开头添加一个制表符。 下面的示例演示了如何使用一个单行字符串来生成四行输出： 123456print(&quot;Languages:\\n\\tPython11111\\tPython\\tPython\\n\\tC\\tC\\n\\tJava\\tJava&quot;)# Languages:# Python11111 Python Python# C C# Java Java 引号和反斜杠 知识点： 单引号：\\&#39;。 双引号：\\&quot;。 反斜杠符号：\\\\。 习题 第6题 第7题 删除字符串中的空白认识程序中的空白 知识点： 对人来说，&#39;python&#39;和&#39;python &#39;看起来几乎一样。 对程序来说，它们却是两个不同的字符串。 程序对字符串中的空白敏感。 处理字符串中的空白很重要，因为经常需要比较两个字符串是否相同。例如，在用户登录网站时检查其用户名。通过对字符串空白删除操作，对用户输入数据中的多余空白进行删除。 使用方法rstrip()删除字符串末尾空白 知识点：rstrip()方法 调用语法：str.rstrip([chars])。 描述：删除 string字符串末尾的指定字符，默认为空格。 参数：chars，指定删除的字符，默认为空格。 返回：删除 string字符串末尾的指定字符后生成的新字符串。 123456789favorite_language = &#x27; python &#x27;print(favorite_language)# &#x27; python &#x27;print(favorite_language.rstrip())# &#x27; python&#x27;print(favorite_language)# &#x27; python &#x27; 分析： 存储在变量favorite_language中的字符串末尾包含多余的空白。Jupyter输出可看到末尾的空格。 对变量favorite_language调用方法rstrip()后，这个多余的空格被删除了。 然而，这种删除只是暂时的，在Jupyter输出中输出favorite_language时，会发现它依然包含多余的空白。 设置参数chars，删除指定的字符。 1234567str = &quot; this is string example....wow!!! &quot;print (str.rstrip()) # 默认为空白# this is string example....wow!!!str = &quot;*****this is string example....wow!!!*****&quot;print (str.rstrip(&#x27;*&#x27;)) # 指定字符*# *****this is string example....wow!!! 永久删除字符串的空白要永久删除这个字符串中的空白，必须将删除操作的结果存回到变量中。 12345print(&#x27;-------通过赋值的方式覆盖原字符串-----------&#x27;)favorite_language = &#x27; python &#x27;favorite_language = favorite_language.rstrip()print(favorite_language)# &#x27; python&#x27; 分析： 因为rstrip()操作不直接修改字符串，而是返回一个新的字符串。 在编程中，经常需要修改变量的值，再将新值存回到原来的变量中。 使用方法lstrip()和strip()删除字符串首和两端空白Python还可以删除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法lstrip()和strip()。在这个示例中，我们首先创建了一个开头和末尾都有空白的字符串。接下来，我们分别删除末尾、开头和两端的空格。 12345678910111213print(&#x27;------Jupyter对赋值语句结果不输出----------&#x27;)favorite_language = &#x27; python &#x27;print(favorite_language)# &#x27; python &#x27;print(favorite_language.rstrip())# &#x27; python&#x27;print(favorite_language.lstrip())# &#x27;python &#x27;print(favorite_language.strip())# &#x27;python&#x27; 习题 第8题 第9题 字符串引起的语法错误字符串引号引起的语法错误 知识点： 语法错误在编程过中经常会被遇到，当程序中包含非法的Python代码时，就会导致语法错误。 可通过Python解释器提供的错误信息，来较快的解决。 下面演示了如何正确地使用单引号和双引号。撇号位于两个双引号之间，因此Python解释器能够正确地理解这个字符串： 1234message = &quot;One of Python&#x27;s strengths is its diverse community.&quot;print(message)# One of Python&#x27;s strengths is its diverse community. 在用单引号括起的字符串中，如果包含撇号，就将导致错误。这是因为这会导致Python将第一个单引号和撇号之间的内容视为一个字符串，进而将余下的文本视为Python代码，从而引发错误。因为，Python将无法正确地确定字符串的结束位置： 12345message = &#x27;One of Python&#x27;s strengths is its diverse community.&#x27;# File &quot;&lt;stdin&gt;&quot;, line 1# message = &#x27;One of Python&#x27;s strengths is its diverse community.&#x27;# ^#SyntaxError: invalid syntax 从上述输出可知，错误发生在第二个单引号后面。这种语法错误表明，在解释器看来，其中的有些内容不是有效的Python代码。 知识点： 编写程序时，编辑器的语法突出功能可帮助你快速找出某些语法错误。 看到Python代码以普通句子的颜色显示，或者普通句子以Python代码的颜色显示时，就可能意味着文件中存在引号不匹配的情况。 习题 第10题 第11题 第12题 第13题 第14题 (重要)格式化字符串.format()函数的语法认识.format()字符串格式化函数Python提供了.format()字符串格式化函数。该函数操作起来方便，可读性很强。 .format()函数常与print()函数结合使用，具备很强的格式化输出能力。 知识点：.format()字符串格式化函数。 语法：str.format(**args)。 例如：&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)。 描述：该函数将通过&#123;&#125;和:来设置模板字符串str，然后通过.format(**args)传入实参来对str进行格式化。 模板字符串str中包含由大括号&#123;&#125;包围的“替换字段”。 &#123;&#125;中填写文本替换和格式化规则，如果不填任何规则(直接使用&#123;&#125;)，则进行直接替换。 具体的“替换字段”由args参数传入。 .format()函数中有几个参数，模板字符串str中包含几个&#123;&#125;。 该函数使用方法较多，下面将一一介绍。 认识.format()函数默认参数位置知识点：.format()函数的默认位置。 不指定格式化位置，按照默认顺序格式化。 args参数以,相隔，按顺序填入相应的&#123;&#125;。 str字符串模板中的&#123;&#125;数量不能超过参数个数，否则会出错。 1234str1 = &quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)print(str1)# hello world .format()函数中有2个参数，模板字符串str中包含2个&#123;&#125;。 模板字符串str为&quot;&#123;&#125; &#123;&#125;&quot;，仅包含两个&#123;&#125;。 args参数包括：&quot;hello&quot;和&quot;world&quot;。 根据规则，按照默认顺序格式化str。&quot;hello&quot;填入第1个&#123;&#125;；&quot;world&quot;填入第2个&#123;&#125;。 IndexError错误知识点：当&#123;&#125;超过args输入参数个数时，会出错IndexError。 12345678910str1 = &quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)print(str1)# ---------------------------------------------------------------------------# IndexError Traceback (most recent call last)# &lt;ipython-input-3-eb58e09cec2c&gt; in &lt;module&gt;# ----&gt; 1 str1 = &quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)# 2 print(str1)# IndexError: Replacement index 2 out of range for positional args tuple .format()函数的位置索引知识点：.format()函数的3中位置索引方式：默认位置索引、序号位置索引和关键字位置索引。 参数的序号位置索引 知识点：.format()函数的参数的序号位置索引。 设置参数索引来指定格式化的位置。 为str字符串模板设置带参数索引的&#123;&#125;。 参数索引从0开始，即第1个参数，对应&#123;0&#125;。 1234str1 = &quot;&#123;1&#125; &#123;0&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)print(str1)# world hello 模板字符串str为&quot;&#123;0&#125; &#123;1&#125;&quot;，在每个&#123;&#125;中包含数字，来指明所替换的参数索引。 args参数包括：&quot;hello&quot;对应第0参数索引、&quot;world&quot;对应第1参数索引。 根据规则，按照参数索引格式化str。&quot;hello&quot;填入&#123;0&#125;；&quot;world&quot;填入&#123;1&#125;。 位置索引可重复使用 知识点：参数索引可以重复使用来替换字符串。 1234str1 = &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)print(str1)# world hello world .format()参数的关键字位置索引 知识点：.format()函数的关键字位置索引。 设置关键字来指定格式化的位置。该功能与数字位置类似。 为str字符串模板设置带关键字的&#123;&#125;，指定参数替代字符串模板的位置。 关键字可以为位置取更有意义的标识。 注意：在使用关键字索引时，避免使用0和o、1和l，以免混淆。 123# 下面的关键字l很容易被误认为是1str1 = &#x27;I &#123;l&#125; &#123;p&#125;, and I\\&#x27;am learning &#123;p&#125;&#x27;.format(p=&#x27;Python&#x27;, l=&#x27;like&#x27;)print(str1) .format()函数样式格式输出.format()函数的填充与格式化 知识点：.format()函数的填充与格式化。 大括号中可以设定特殊的格式：&#123;:[填充字符][对齐方式 &lt;^&gt;][宽度]&#125; :为格式起始标志，不能少。 :号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 对齐方式：&lt;^&gt;分别为左、中、右对齐。 宽度：整形，指定填充位置宽度，如果替换文本比这个宽度小，则用填充字符进行填充。 123456789101112# 左对齐，使用*填充，宽度为10str1 = &#x27;Hello &#123;:*&lt;10&#125; &#x27;.format(1111)print(str1)# 居中对齐，使用@填充，宽度为20str1 = &#x27;Hello &#123;:@^20&#125; &#x27;.format(1111)print(str1)# 右对齐，使用&gt;填充，宽度为12。#第一个&gt;为填充字符，第2个&gt;为右对齐str1 = &#x27;Hello &#123;:&gt;&gt;12&#125; &#x27;.format(1111)print(str1) 定制输出格式： &#123;:&gt;n&#125; 将字段设置为n个字符，并让内容右对齐。数字默认右对齐。 &#123;: 将字段设置为n`个字符，并让内容左对齐。非数字的字符默认左对齐。 &#123;:^n&#125; 将字段设置为n个字符，并让内容居中。 12345678910111213141516171819x = &#x27;hello&#x27;y = &#x27;hi&#x27;print(&#x27;------format(): 字符默认左对齐，数字默认右对齐 -----&#x27;)format_str = &#x27;&#123;:8&#125; results in &#123;&#125;.&#x27;print(format_str.format(x, y))print(format_str.format(1111, y))# hello results in hi.# 1111 results in hi.print(&#x27;------format(): 右对齐 -----&#x27;)format_str = &#x27;&#123;:&gt;8&#125; results in &#123;&#125;.&#x27;print(format_str.format(x, y))print(format_str.format(1111, y))# hello results in hi.# 1111 results in hi.print(&#x27;------普通输出 -----&#x27;)print(x + &#x27; results in&#x27; + y)# hello results inhi 输出以右对齐的方式打印2~20的偶数，每个字段的宽度都设置为3个字符。 .format()函数的精度 知识点：.format()函数的精度。 大括号中可以设定特殊的格式：&#123;:[m].[n][格式]&#125; :为格式起始标志，不能少。 m为整形，整数部分的宽度。 默认值为原数字整数部分的长度。 如果m大于整数部分的长度，则有空格左边填充。 .为小数点。 n为整形，小数点后保留几位精度。 默认值为原数字小数部分的长度。 如果n大于小数部分的长度，则有0补全填充。 格式：f为浮点数。 1234567#m=10，n=1，f为浮点数print(&#x27;&#123;:10.1f&#125;&#x27;.format(311.1415926))# 311.1#m为默认，n=4，f为浮点数print(&#x27;&#123;:.4f&#125;&#x27;.format(3.14))# 3.1400 .format()函数的进制转换 知识点：进制转换，b、d、o、x 分别是二进制、十进制、八进制、十六进制。 12345678print(&#x27;&#123;:b&#125;&#x27;.format(11))print(&#x27;&#123;:d&#125;&#x27;.format(11))print(&#x27;&#123;:o&#125;&#x27;.format(11))print(&#x27;&#123;:x&#125;&#x27;.format(11))# 1011# 11# 13# b .format()函数的数字格式输出 请使用.format()函数得到下面的结果运行结果。 数字(输入) 格式 输出 描述(结果) 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) f-string技术初识f-stringf-string基本介绍f-string，亦称为格式化字符串常量（formatted string literals），是Python3.6新引入的一种字符串格式化方法，主要目的是使格式化字符串的操作更加简便。 知识点： f-string在形式上是以 f 或 F 修饰符引领的字符串（f&#39;xxx&#39; 或 F&#39;xxx&#39;），以大括号 &#123;&#125; 标明被替换的字段 f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式。 f-string在功能方面不逊于传统的%-formatting语句和str.format()函数，同时性能又优于二者，且使用起来也更加简洁明了，因此对于Python3.6及以后的版本，推荐使用f-string进行字符串格式化。 f-string语法 知识点： 语法：f&#39;&lt;text&gt; &#123;&lt;content:format specifier&gt;&#125; &lt;text&gt; ...&#39; f是f-string的标识符，位于字符串标识符&#39;之前。标识符不能忘记。 &lt;text&gt;：为普通字符串文本。 &#123;&lt;content&gt;&#125;：大括号是需要被替换的字段，外部传入的变量名为&lt;expr&gt;。 &lt;:format specifier&gt;：可选，类似于.format()，自定义的格式。 例如：f&#39;s is &#123;s:8s&#125;&#39;，其中s is 是&lt;text&gt;；&#123;s:8s&#125;中s为&lt;content&gt;，8s为格式，中间:间隔。 f-string用大括号 &#123;&#125; 表示被替换字段，其中直接填入替换内容： 123456789101112131415name = &#x27;Eric&#x27;str = f&#x27;Hello, my name is &#123;name&#125;&#x27;# &#x27;Hello, my name is Eric&#x27;print(str)number = 7str = f&#x27;My lucky number is &#123;number&#125;&#x27;# &#x27;My lucky number is 7&#x27;print(str)price = 19.99str = f&#x27;The price of this book is &#123;price&#125;&#x27;# &#x27;The price of this book is 19.99&#x27;print(str) 深入f-string表达式求值与函数调用f-string的大括号 &#123;&#125; 可以填入表达式或调用函数，Python会求出其结果并填入返回的字符串内： 1234567891011121314151617str = f&#x27;A total number of &#123;24 * 8 + 4&#125;&#x27;# &#x27;A total number of 196&#x27;print(str)str = f&#x27;Complex number &#123;(2 + 2j) / (2 - 3j)&#125;&#x27;# &#x27;Complex number (-0.15384615384615388+0.7692307692307692j)&#x27;print(str)name = &#x27;ERIC&#x27;str = f&#x27;My name is &#123;name.lower()&#125;&#x27;# &#x27;My name is eric&#x27;print(str)import mathstr = f&#x27;The answer is &#123;math.log(math.pi)&#125;&#x27;# &#x27;The answer is 1.1447298858494002&#x27;print(str) 引号、大括号与反斜杠f-string大括号内所用的引号不能和大括号外的引号定界符冲突，可灵活切换 &#39; 和 &quot;： 123456str = f&#x27;I am &#123;&quot;Eric&quot;&#125;&#x27;# &#x27;I am Eric&#x27;print(str)# SyntaxError: invalid syntaxstr = f&#x27;I am &#123;&#x27;Eric&#x27;&#125;&#x27; 若 &#39; 和 &quot; 不足以满足要求，还可以使用 &#39;&#39;&#39; 和 &quot;&quot;&quot;： 12345# SyntaxError: invalid syntaxstr = f&quot;He said &#123;&quot;I&#x27;m Eric&quot;&#125;&quot;# SyntaxError: invalid syntaxstr = f&#x27;He said &#123;&quot;I&#x27;m Eric&quot;&#125;&#x27; 1234567str = f&quot;&quot;&quot;He said &#123;&quot;I&#x27;m Eric&quot;&#125;&quot;&quot;&quot;# &quot;He said I&#x27;m Eric&quot;print(str)str = f&#x27;&#x27;&#x27;He said &#123;&quot;I&#x27;m Eric&quot;&#125;&#x27;&#x27;&#x27;# &quot;He said I&#x27;m Eric&quot;print(str) 大括号外的引号还可以使用 \\ 转义，但大括号内不能使用 \\ 转义： 123str = f&#x27;&#x27;&#x27;He\\&#x27;ll say &#123;&quot;I&#x27;m Eric&quot;&#125;&#x27;&#x27;&#x27;# &quot;He&#x27;ll say I&#x27;m Eric&quot;print(str) 12# SyntaxError: f-string expression part cannot include a backslashstr = f&#x27;&#x27;&#x27;He&#x27;ll say &#123;&quot;I\\&#x27;m Eric&quot;&#125;&#x27;&#x27;&#x27; f-string大括号外如果需要显示大括号，则应输入连续两个大括号 &#123;&#123;` 和 `&#125;&#125;： 1234567str = f&#x27;5 &#123;&quot;&#123;stars&#125;&quot;&#125;&#x27;# &#x27;5 &#123;stars&#125;&#x27;print(str)str = f&#x27;&#123;&#123;5&#125;&#125; &#123;&quot;stars&quot;&#125;&#x27;# &#x27;&#123;5&#125; stars&#x27;print(str) f-string大括号内不能使用 \\ 转义，事实上不仅如此，f-string大括号内根本就不允许出现 \\。如果确实需要 \\，则应首先将包含 \\ 的内容用一个变量表示，再在f-string大括号内填入变量名： 12# SyntaxError: f-string expression part cannot include a backslashstr = f&quot;newline: &#123;ord(&#x27;\\n&#x27;)&#125;&quot; 12345# ord()为将&#x27;\\n&#x27;的ASCII码转为八进制newline = ord(&#x27;\\n&#x27;)str = f&#x27;newline: &#123;newline&#125;&#x27;# &#x27;newline: 10&#x27;print(str) 多行f-stringf-string还可用于多行字符串： 123456789101112131415name = &#x27;Eric&#x27;age = 27# 多行字符串用 \\ 拼接str = f&quot;Hello!&quot; \\f&quot;I&#x27;m &#123;name&#125;.&quot; \\f&quot;I&#x27;m &#123;age&#125;.&quot;# &quot;Hello!I&#x27;m Eric.I&#x27;m 27.&quot;print(str)# &quot;&quot;&quot;中间的字符串可以直接换行str = f&quot;&quot;&quot;Hello!I&#x27;m &#123;name&#125;.I&#x27;m &#123;age&#125;.&quot;&quot;&quot;# &quot;Hello!\\n I&#x27;m Eric.\\n I&#x27;m 27.&quot;print(str) 自定义f-string格式自定义格式f-string采用 &#123;content:format&#125; 设置字符串格式，其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format 是格式描述符。自定义格式与.format()类似。采用默认格式时不必指定 &#123;:format&#125;，如上面例子所示只写 &#123;content&#125; 即可。 宽度与精度相关格式描述符 格式描述符 含义与作用 width 整数 width 指定宽度 0width 整数 width 指定宽度，开头的 0 指定高位用 0 补足宽度 width.precision 整数 width 指定宽度，整数 precision 指定显示精度 数值类型基本格式 格式描述符 含义与作用 适用变量类型 s 普通字符串格式 字符串 b 二进制整数格式 整数 c 字符格式，按unicode编码将整数转换为对应字符 整数 d 十进制整数格式 整数 o 八进制整数格式 整数 x 十六进制整数格式（小写字母） 整数 X 十六进制整数格式（大写字母） 整数 e 科学计数格式，以e表示×10^ 浮点数、复数、整数（自动转换为浮点数） E 与e等价，但以E表示×10^ 浮点数、复数、整数（自动转换为浮点数） f 定点数格式，默认精度（precision）是6 浮点数、复数、整数（自动转换为浮点数） F 与f等价，但将nan和inf换成NAN和INF 浮点数、复数、整数（自动转换为浮点数） g 通用格式，小数用f，大数用e 浮点数、复数、整数（自动转换为浮点数） G 与G等价，但小数用F，大数用E 浮点数、复数、整数（自动转换为浮点数） % 百分比格式，数字自动乘上100后按f格式排版，并加%后缀 浮点数、整数（自动转换为浮点数） 12345678910111213141516171819# &#123;content:format&#125;# a 为 content# : 之后为formata = 123.456str = f&#x27;a is &#123;a:8.2f&#125;&#x27;# &#x27;a is 123.46&#x27;print(str)str = f&#x27;a is &#123;a:08.2f&#125;&#x27;# &#x27;a is 00123.46&#x27;print(str)str = f&#x27;a is &#123;a:8.2e&#125;&#x27;# &#x27;a is 1.23e+02&#x27;print(str)str = f&#x27;a is &#123;a:8.2%&#125;&#x27;# &#x27;a is 12345.60%&#x27;print(str) 123456789101112str = f&#x27;a is &#123;a:8.2g&#125;&#x27;# &#x27;a is 1.2e+02&#x27;print(str)s = &#x27;hello&#x27;str = f&#x27;s is &#123;s:8s&#125;&#x27;# &#x27;s is hello &#x27;print(str)str = f&#x27;s is &#123;s:8.3s&#125;&#x27;# &#x27;s is hel &#x27;print(str) 对齐方式相关格式描述符 格式描述符 含义与作用 &lt; 左对齐（字符串默认对齐方式） &gt; 右对齐（数值默认对齐方式） ^ 居中 数字符号相关格式描述符（只适合数值类型） 格式描述符 含义与作用 + 负数前加负号（-），正数前加正号（+） - 负数前加负号（-），正数前不加任何符号（默认） （空格） 负数前加负号（-），正数前加一个空格 数字显示方式相关格式描述符(是否加#) 数值类型 不加**#**（默认） 加**#** 区别 二进制整数 ‘1111011’ ‘0b1111011’ 开头是否显示 0b 八进制整数 ‘173’ ‘0o173’ 开头是否显示 0o 十进制整数 ‘123’ ‘123’ 无区别 十六进制整数（小写字母） ‘7b’ ‘0x7b’ 开头是否显示 0x 十六进制整数（大写字母） ‘7B’ ‘0X7B’ 开头是否显示 0X 12345# 居中&#x27;^&#x27;，显示0X前缀&#x27;#&#x27;，宽度10位，十六进制整数（大写字母）a = 1234str = f&#x27;a is &#123;a:^#10X&#125;&#x27; # &#x27;a is 0X4D2 &#x27;print(str) 12345# 左对齐，宽度10位，显示正号（+），定点数格式，2位小数b = 1234.5678str = f&#x27;b is &#123;b:&lt;+10.2f&#125;&#x27; # &#x27;b is +1234.57 &#x27;print(str) 12345# 高位补零，宽度15位，十进制整数，使用,作为千分分割位c = 12345678str = f&#x27;c is &#123;c:015,d&#125;&#x27; # &#x27;c is 000,012,345,678&#x27;print(str) 12345# 宽度30位，科学计数法，3位小数d = 0.5 + 2.5jstr = f&#x27;d is &#123;d:30.3e&#125;&#x27; # &#x27;d is 5.000e-01+2.500e+00j&#x27;print(str) 任务第1题题目要求： 使用单引号和双引号分别创建字符串(可以用中文作为字符串内容)。 代码如下： 12&quot;hello world&quot;&#x27;hello world&#x27; 运行结果： 1&#39;hello world&#39; 第2题题目要求： 创建含有引号的字符串，观察引号错误使用引起的错误。 代码如下： 1&quot;hello&quot;world&quot; 运行结果： 1234 File &quot;&lt;ipython-input-2-47bd8e44abc4&gt;&quot;, line 1 &quot;hello&quot;world&quot; ^SyntaxError: invalid syntax 第3题题目要求： 创建含有引号的字符串，使用转义字符。 代码如下： 1print(&quot;\\&quot;hello\\&quot;wprld&quot;) 运行结果： 1&quot;hello&quot;wprld 第4题题目要求： 使用input()输入1个字符串，并使用上述3个字符串的方法对该字符串进行修改操作，并输出结果。 代码如下： 12345massage=input()print(massage.title())print(massage.upper())print(massage.lower())# massage=&#x27;hello world&#x27; 运行结果： 123Hello WorldHELLO WORLDhello world 第5题题目要求： 接受键盘输入，将输入字符串储存到变量，然后进行字符串拼接，最后输出 “你好，姓名”。 代码如下： 123name=input()print(&#x27;你好，&#x27;+name)# name=XieSenshi 运行结果： 1你好，XieSenshi 第6题题目要求： 使用制表符和换行符分别自定义创建字符串(可以为中文)，并输出结果。 代码如下： 12print(&quot;System:\\tWindows\\tLinux\\tMacOS\\tAndroid\\tiOS&quot;)print(&quot;System:\\nWindows\\nLinux\\nMacOS\\nAndroid\\niOS&quot;) 运行结果： 1234567System: Windows Linux MacOS Android iOSSystem:WindowsLinuxMacOSAndroidiOS 第7题题目要求： 组合使用制表符(3列)和换行符(2行)自定义创建字符串(可以为中文)，并输出结果。 代码如下： 1print(&quot;System:\\tWindows\\tLinux\\tMacOS\\n\\tAndroid\\tiOS&quot;) 运行结果： 12System: Windows Linux MacOS Android iOS 第8题题目要求： 外部输入含有空格的字符串，使用上述方法对字符串进行空白删除处理。 代码如下： 123456massage=input()print(massage)print(massage.lstrip())print(massage.rstrip())print(massage.strip())# massage=&quot; Hello world &quot; 运行结果： 1234 hello world hello world hello worldhello world 第9题题目要求： 外部输入含有空格的字符串，指定chars参数，分别rstrip()、lstrip()和strip()调用删除特定字符。 代码如下： 123456massage=input()print(massage)print(massage.lstrip(&#x27;h&#x27;))print(massage.rstrip(&#x27;d&#x27;))print(massage.strip(&#x27;h&#x27;))# masage=&quot;hello world&quot; 运行结果： 1234hello worldello worldhello worlello world 第10题题目要求： 个性化消息：将用户的姓名存到一个变量中，并向该用户显示一条消息。显示的消息应非常简单，如“Hello Eric, would you like to learn some Python today?”。 代码如下： 12name=&#x27;Eric&#x27;print(&#x27;Hello &#x27;+name+&#x27;, would you like to learn some Python today?&#x27;) 运行结果： 1Hello Eric, would you like to learn some Python today? 第11题题目要求： 调整名字的大小写：将一个人名存储到一个变量中，再以小写、大写和首字母大写的方式显示这个人名。 代码如下： 1234name=&quot;xiesenshi&quot;print(name.lower # 小写print(name.upper()) # 大写print(name.title()) # 首字母大写 运行结果： 123xiesenshiXIESENSHIXiesenshi 第12题题目要求： 名言：找一句你钦佩的名人说的名言，将这个名人的姓名和他的名言打印出来。输出应类似于下面这样（包括引号）：Albert Einstein once said, “A person who never made a mistake never tried anything new.” 代码如下： 1print(&#x27;Albert Einstein once said, “A person who never made a mistake never tried anything new.”&#x27;) 运行结果： 1Albert Einstein once said, “A person who never made a mistake never tried anything new.” 第13题题目要求： 名言2：重复练习11-14，但将名人的姓名存储在变量famous_person中，再创建要显示的消息，并将其存储在变量message中，然后打印这条消息。 代码如下： 123famous_person=&quot;Albert Einstein&quot;massage=famous_person + &quot; once said, “A person who never made a mistake never tried anything new.”&quot;print(massage) 运行结果： 1Albert Einstein once said, “A person who never made a mistake never tried anything new.” 第14题题目要求： 剔除人名中的空白：存储一个人名，并在其开头和末尾都包含一些空白字符。务必至少使用字符组合&quot;\\t&quot;和&quot;\\n&quot;各一次。打印这个人名，以显示其开头和末尾的空白。然后，分别使用剔除函数lstrip()、rstrip()和strip()对人名进行处理，并将结果打印出来。 代码如下： 123456name=&quot; XieSenshi &quot;print(name+&#x27;\\t&#x27;+name+&#x27;\\t&#x27;+name)print(name+&#x27;\\n&#x27;+name+&#x27;\\n&#x27;+name)print(name.lstrip())print(name.rstrip())print(name.strip()) 运行结果： 1234567 XieSenshi XieSenshi XieSenshi XieSenshi XieSenshi XieSenshi XieSenshi XieSenshiXieSenshi","categories":[],"tags":[]},{"title":"Python学习笔记2","slug":"Python学习笔记2","date":"2021-03-24T18:55:10.000Z","updated":"2021-06-16T16:46:17.323Z","comments":true,"path":"2021/03/25/p2.html","link":"","permalink":"http://waxll.top/2021/03/25/p2.html","excerpt":"","text":"第二章 变量与数据类型变量变量的定义为何需要变量？ 变量的功能：通过一个有意义的标识(变量)，将变量与某个具体内容(数值、数组、对象等)进行关联，方便访问。 门牌号与房子、人与人名。 通过变量，不需要记住存放内容的内存物理地址。 在Python中，变量存的是记录具体数据的地址。 123456print(&#x27;---------将变量与字面量进行关联，便于访问和使用。--------------&#x27;)message = &quot;Hello Python world!&quot; #将字符串字面量赋值给message变量print(message, type(message))输出：---------将变量与字面量进行关联，便于访问和使用。--------------Hello Python world! &lt;class &#x27;str&#x27;&gt; 知识点： Jupyter在命令模式下开启cell的行号。 快捷键L。 变量的命名和使用在Python中使用变量时，需要遵守一些规则。违反这些规则将引发错误。请务必牢记下述有关变量的规则： 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。 有意义的变量名，应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着你编写的程序越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。 注意 就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。 1234greeting_message = 111print(greeting_message)输出：111 变量命名的常见错误123456789101112print(&quot;------------没有被赋值的变量，使用会出现NameError错误----------&quot;)mesage = &quot;Hello Python World!&quot;print(message)#-------------报错信息-------------NameError Traceback (most recent call last)&lt;ipython-input-41-80779f5fb05f&gt; in &lt;module&gt; 1 print(&quot;---没有被赋值的变量，使用会出现NameError错误---&quot;) 2 mesage = &quot;Hello Python World!&quot;----&gt; 3 print(message)NameError: name &#x27;message&#x27; is not defined 数值类型整数类型掌握整数类型的四则运算​ 在Python中，可对整数执行加（+）减（-）乘（*）除（/）等运算。 123456789101112print(2 + 3)#结果：5print(3 - 2)#结果：1print(2 * 3)#结果：6print(3 / 2) # 浮点数除法#结果：1.5print(3 // 2) # 商#结果：1print(3 % 2) # 余数#结果：1 掌握整数类型的指数运算​ 在终端会话中，Python直接返回运算结果。Python使用两个乘号表示乘方运算. 123456print(3 ** 2)#结果：9print(3 ** 3)#结果：27print(10 ** 6)#结果：1000000 掌握运算的优先级​ Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修改运算次序，让Python按你指定的次序执行运算，如下所示： 12print(2 + 3*4)print((2 + 3) * 4) ​ 运行结果： 121420 在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能迅速确定先执行哪些运算。 习题四。 浮点类型掌握浮点数类型运算操作知识点： Python将带小数点的数字都称为浮点数。 小数点可出现在数字的任何位置。 1234print(0.1 + 0.1)# 结果：0.2print(0.2 - 0.2)# 结果：0.0 掌握浮点数运算误差知识点： 由于计算机采用二进制工作，很多小数都没法被二进制准确表示。 因此，Python的浮点数小数位并不精确。 123456print(0.2 * 0.1)# 结果：0.020000000000000004print(0.3 / 0.2)# 结果：1.4999999999999998print(3 * 0.1)# 结果：0.30000000000000004 如何正确比较两个浮点数大小知识点： 浮点数是不确定数，所以不能用==等号判断两个浮点数相等。 整数是确定数，所以能用==等号判断两个整数相等。 不仅仅是Python，其他所有语言的浮点数都存在误差。 1234a = 0.2 + 0.1b = 3 * 0.1print( (a - b) &lt;= 10**(-6) )# 结果：True 习题五 str()的使用字符串不能和数值类型拼接 常常需要在消息中使用字符串拼接，在构造完整的消息信息。例如，要祝某人生日快乐，可能会编写代码打印一条简单的生日祝福语：Happy 23rd birthday!。但如果运行如下代码，将会触发类型错误： 12345678910111213age = 23message = &quot;Happy &quot; + age + &quot;rd Birthday!&quot;print(message)---------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-103-4d54be8cf23f&gt; in &lt;module&gt; 1 age = 23----&gt; 2 message = &quot;Happy &quot; + age + &quot;rd Birthday!&quot; 3 4 print(message)TypeError: can only concatenate str (not &quot;int&quot;) to str 分析： 这是一个**类型错误(TypeError)**，无法执行对字符类型str和数值类型int的数据直接相加。 运算操作数需要类型匹配，否则将会触发TypeError。 使用str()转换非字符类型数据知识点： 需要显式地将数值类型转换为字符串类型。 可调用函数str()，它让Python将非字符串值转换为字符串。 在字符串拼接时，特别要注意拼接的变量类型是否是字符串，否则就会出现类型错误。 1234age = 23message = &quot;Happy &quot; + str(age) + &quot;rd Birthday!&quot;print(message)# Happy 23rd Birthday! 习题六 注释如何编写注释(快捷键ctrl+/)知识点： 注释让你能够使用自然语言在程序中添加说明。 在Python中，注释用井号（#）标识。井号后面的内容都会被Python解释器忽略。 注释快捷键：ctrl+/ 123# 向大家问好print(&quot;Hello Python people!&quot;)# 结果：Hello Python people! Python解释器将忽略第1行，只执行第2行。 多行注释知识点： 多行注释用三个单引号 &#39;&#39;&#39; 或者三个双引号 &quot;&quot;&quot; 将注释括起来。 123456&#x27;&#x27;&#x27;这是多行注释，用三个单引号这是多行注释，用三个单引号这是多行注释，用三个单引号&#x27;&#x27;&#x27;print(&quot;Hello, World!&quot;) 123456&quot;&quot;&quot;这是多行注释，用三个双引号这是多行注释，用三个双引号这是多行注释，用三个双引号&quot;&quot;&quot;print(&quot;Hello, World!&quot;) 熟悉该编写什么样的注释 在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了。当然，你总是可以通过研究代码来确定各个部分的工作原理，但通过编写注释，以清晰的自然语言对解决方案进行概述，可节省很多时间。 要成为专业程序员或与其他程序员合作，就必须编写有意义的注释。当前，大多数软件都是合作编写的，编写者可能是同一家公司的多名员工，也可能是众多致力于同一个开源项目的人员。训练有素的程序员都希望代码中包含注释，因此你最好从现在开始就在程序中添加描述性注释。作为新手，最值得养成的习惯之一是，在代码中编写清晰、简洁的注释。 如果不确定是否要编写注释，就问问自己，找到合理的解决方案前，是否考虑了多个解决方案。如果答案是肯定的，就编写注释对你的解决方案进行说明吧。相比回过头去再添加注释，删除多余的注释要容易得多。 习题七 任务第1题题目要求： 添加了一个名为message的变量。每个变量都存储了一个值——与变量相关联的信息。 在这里，存储的值为字符串“Hello Python world!”。 第1行代码，用于代码注释输出。 第2行代码，它将字符串字面量“Hello Python world!”与变量message关联起来； 第3行代码，它将与变量message关联的值打印到屏幕。 修改程序，使其再打印一条消息： 代码如下： 123print(&#x27;---------在创建或赋值变量时，不需要为变量指定 类型--------------&#x27;)message = 2019print(message, type(message)) 1234567891011print(&#x27;--------不能使用未创建的变量---------------&#x27;)message1 = 3.14print(message1, type(message1))```````pythonmessage = &quot;Hello Python world!&quot;print(message)message = &quot;Hello Python Crash Course world!&quot;print(message) 运行结果： 12---------在创建或赋值变量时，不需要为变量指定 类型--------------2019 &lt;class &#x27;int&#x27;&gt; 12--------不能使用未创建的变量---------------3.14 &lt;class &#x27;float&#x27;&gt; 12Hello Python world!Hello Python Crash Course world! 第2题题目要求： 在程序中可随时修改变量的值，而Python将始终记录变量的最新值。通过input函数接受用户的输入，注意该函数的返回为str类型。 代码如下 12345# input 函数的返回是strmessage = input(&quot;请输入float类型的数据：&quot;)message = float(message) # str --&gt; floatmessage = message * 10print(message, type(message)) 运行结果： 122.0 &lt;class &#x27;float&#x27;&gt; 第3题题目要求： 创建变量，将一条消息存储到变量中，再将其打印出来。 将一条消息存储到变量中，将其打印出来；再将变量的值修改为一条新消息，并将其打印出来。 使用input()函数，接收外部输入(输入字符)，并把结果存到变量中，组织消息内容，打印结果。 使用input()函数，接收外部输入(输入数字)，并把结果存到变量中，对这数进行平方运算，打印结果 代码如下 12345678910massage=&#x27;Hello World!&#x27;print(massage)massage1=2.2massage1=str(massage1)print(massage1)massage2=input(&#x27;输入字符&#x27;)print(massage2)massage3=input(&#x27;输入数字&#x27;)massage3=float(massage3)print(massage3**2) 运行结果： 1234Hello World!2.21.31.6900000000000002 第4题题目要求： 数字8：编写4个表达式，它们分别使用加法、减法、乘法和除法运算，但结果都是数字8。为使用print语句来显示结果，务必将这些表达式用括号括起来，也就是说，你应该编写4行类似于下面的代码：print(5 + 3)。输出应为4行，其中每行都只包含数字8。 使用input()函数，键盘输入两个整数，然后再对这两个数进行上述运算操作。 代码如下： 123456789101112print(2+6)print(11-3)print(2*4)print(32//4)num1=float(input(&#x27;num1&#x27;))num2=float(input(&#x27;num2&#x27;))print(num1+num2)print(num1-num2)print(num1*num2)print(num1/num2)#num1=4.5#num2=5.6 运行结果： 12345678888810.1-1.099999999999999625.20.8035714285714286 第5题题目要求： 使用input()函数，键盘输入两个浮点数，然后再对这两个数进行四则运算操作，观察浮点数计算误差。 使用input()函数，键盘输入两个浮点数，比较整这两个数的大小，并输出结果。 代码如下： 12345678910num1=float(input(&#x27;num1&#x27;))num2=float(input(&#x27;num2&#x27;))print(num1+num2)print(num1-num2)print(num1*num2)print(num1/num2)print(num1&gt;num2)print(num1&lt;num2)#num1=4.5#num2=6.7 运行结果： 12345611.2-2.230.1500000000000020.6716417910447761FalseTrue 第6题题目要求： 最喜欢的数字：将你最喜欢的数字存储在一个变量中，再使用这个变量创建一条消息，指出你最喜欢的数字，然后将这条消息打印出来。 使用input()函数，键盘输入两个3位数的整数，然后通过str()将它们转换为字符串，再使用+对它们进行拼接，并输出结果。 代码如下： 1234567massage=98print(&#x27;我最喜欢的数字是：&#x27;+str(massage))num1=str(input(&#x27;三位整数&#x27;))num2=str(input(&#x27;三位整数&#x27;))print(num1+um2)#num1=234#num2=456 运行结果： 12我最喜欢的数字是：98234456 第7题题目要求： 添加注释：选择你编写的两个程序，在每个程序中都至少添加一条注释。如果程序太简单，实在没有什么需要说明的，就在程序文件开头加上你的姓名和当前日期，再用一句话阐述程序的功能。 代码如下： 12345678num1=float(input(&#x27;num1&#x27;)) # str --&gt; floatnum2=float(input(&#x27;num2&#x27;)) # str --&gt; floatprint(num1+num2)print(num1-num2)print(num1*num2)print(num1/num2)print(num1&gt;num2)print(num1&lt;num2) 123#谢森时 3/20massage=&#x27;Hello World!&#x27;print(massage)","categories":[{"name":"Python","slug":"Python","permalink":"http://waxll.top/categories/Python/"}],"tags":[{"name":"PythonLearn","slug":"PythonLearn","permalink":"http://waxll.top/tags/PythonLearn/"}]},{"title":"Python学习笔记1","slug":"Python学习笔记1","date":"2021-03-17T12:02:43.000Z","updated":"2021-03-24T18:57:57.959Z","comments":true,"path":"2021/03/17/py1.html","link":"","permalink":"http://waxll.top/2021/03/17/py1.html","excerpt":"","text":"开发环境安装及配置安装Anaconda从官网下载安装包。 注意： Anaconda应安装在根目录； 安装路径中不能有中文目录； 此处两个选项都应打勾。 安装VS Code在插件栏中搜索安装Python插件 安装黑暗主题插件 安装Windows Terminal在Windows10应用商店中安装Windows Terminal。 设定缺省shell 在Windows Terminal中 Ctrl + ,打开配置文件， 先找到 profiles配置项，看里面 cmd.exe 对应的 guid是什么，拷贝 cmd.exe 对应的guid到defaultProfile中。 安装Jupyter Lab先更换pypi源为国内镜像源。 在控制台中输入： 1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 即可将pipy源更换为清华镜像源。 在控制台中输入： 1pip install &quot;jupyterlab&gt;=3.0.0&quot; 当控制台出现**Successfully installed jupyterlab-3.0.5**即表明安装成功。 在控制台中输入： 1jupyter lab 即可启动Jupyter Lab 作业笔记工具安装安装Typora从官网下载安装包，安装 更改黑暗主题 安装Xmind使用QQ群里的文件安装破解版 Python编程常见问题使用英文输入法代码所有的字符都用英文输入法，特别是标点符号。 注意：字符串内容可使用中文。 代码编程一定要用 英文输入法，包括标点，否则就会出错。 代码编程一定要用 英文输入法，包括标点，否则就会出错。 代码编程一定要用 英文输入法，包括标点，否则就会出错。 Python缩进错误如果发现IndentationError: unexpected indent这个问题，检查代码缩进。 Python对缩进敏感，它通过缩进来判断语句块。 不允许同一级别的代码存在不同级别的缩进。 程序正确但Jupyter运行不出结果显示In[*]，如下图。 主要原因是Python程序后台运行繁忙(卡了)，来不及输出程序的结果，可能本身程序没问题。 请重新启动jupyter的kernel。 Jupyter Lab中，Kernel菜单–&gt;Restart。 VSCode中，关闭程序，重新开启。 重启Kernel后，所有的变量将被清空。 Hello World程序.py代码如下： 1print(&quot;Hello World&quot;) 运行结果： 1Hello World 运行结果截图： .ipynb代码如下： 1print(&quot;Hello World&quot;) 运行结果： 1Hello World 运行结果截图：","categories":[{"name":"Python","slug":"Python","permalink":"http://waxll.top/categories/Python/"}],"tags":[{"name":"PythonLearn","slug":"PythonLearn","permalink":"http://waxll.top/tags/PythonLearn/"}]},{"title":"一个带两个LED,两个独立式按键的系统","slug":"按键","date":"2020-07-25T04:33:17.000Z","updated":"2021-03-17T12:09:01.084Z","comments":true,"path":"2020/07/25/a2.html","link":"","permalink":"http://waxll.top/2020/07/25/a2.html","excerpt":"一个基于STC89C51设计的带两个LED，两个独立按键的系统。","text":"一个基于STC89C51设计的带两个LED，两个独立按键的系统。 设计要求按键K0为LED0的开关，按键K1为系统自锁状态切换按键；LED0为系统控制对象，LED1为自锁状态指示。系统处于非自锁状态时，按下K0，则LED0亮，松手即灭。当系统处于自锁状态时，每按下一次K0，LED0的亮灭状态发生一次改变。 按键去抖动 按键消去抖动原理 按键去抖动主要有硬件去抖与软件去抖，这里采用低采样率去抖的方式。实际操作是使用定时中断的方式实现，设定定时时长在20ms-200ms即可。实现代码如下： 1234567891011121314151617181920212223242526272829KEY0 EQU P1.0KEY1 EQU P1.1LED0 EQU P2.0LED1 EQU P2.1ORG 0000HAJMP MAINORG 000BHAJMP TIMEROORG 0030HMAIN: CLR F0 ;自锁标志位 SETB LED0 SETB LED1 MOV TMOD,#01H ;设置50ms定时 MOV TH0,#03CH MOV TL0,#0B0H MOV IE,#82H SETB TR0 SJMP $TIMERO: MOV TH0,#03CH ;中断复位 MOV TL0,#0B0H ACALL KEYPRESS RETIKEYPRESS: ;按键子程序 . . . RET 按键延迟处理为防止一次按键按下时被多次读键，因而要加入按键延时。由于在该设计方案中涉及到长按的操作为防止闪烁，因此要在按键按下时加入死循环。实现代码如下： 12345678910111213141516171819KEYPRESS: JNB KEY0,K0 JNB KEY1,K1 AJMP OUTK0: JNB F0,T001 CPL LED0 JNB KEY0,$ ;加入死循环 AJMP OUTT001: CLR LED0 JNB KEY0,$ ;加入死循环 SETB LED0 AJMP OUTK1: CPL F0 CPL LED1 JNB KEY1,$ ;加入死循环OUT:RET 最终完成代码12345678910111213141516171819202122232425262728293031323334353637383940414243KEY0 EQU P1.0KEY1 EQU P1.1LED0 EQU P2.0LED1 EQU P2.1ORG 0000HAJMP MAINORG 000BHAJMP TIMEROORG 0030HMAIN: CLR F0 ;自锁标志位 SETB LED0 SETB LED1 MOV TMOD,#01H ;设置50ms定时 MOV TH0,#03CH MOV TL0,#0B0H MOV IE,#82H SETB TR0 SJMP $TIMERO: MOV TH0,#03CH ;中断复位 MOV TL0,#0B0H ACALL KEYPRESS RETIKEYPRESS: ;按键子程序 JNB KEY0,K0 JNB KEY1,K1 AJMP OUTK0: JNB F0,T001 CPL LED0 JNB KEY0,$ ;加入死循环 AJMP OUTT001: CLR LED0 JNB KEY0,$ ;加入死循环 SETB LED0 AJMP OUTK1: CPL F0 CPL LED1 JNB KEY1,$ ;加入死循环OUT:RET 返回","categories":[{"name":"单片机","slug":"单片机","permalink":"http://waxll.top/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51汇编","slug":"C51汇编","permalink":"http://waxll.top/tags/C51%E6%B1%87%E7%BC%96/"}]},{"title":"发现一个不错的鼠标点击特效","slug":"发现一个不错的鼠标点击特效","date":"2020-07-24T21:36:49.000Z","updated":"2021-03-24T19:00:10.400Z","comments":true,"path":"2020/07/25/a1.html","link":"","permalink":"http://waxll.top/2020/07/25/a1.html","excerpt":"点击查看效果","text":"点击查看效果 使用方法在volantis/layout/layout.ejs 的body下方填入以下代码： 12&lt;div id=&quot;clickCanvas&quot; style=&quot; position:fixed;left:0;top:0;&quot;&gt;&lt;canvas class=&quot; sketch&quot; height=&quot;0&quot; width=&quot;0&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/waxll/blog-js/dj.js&quot;&gt;&lt;/script&gt; 我使用的主题是Votlantis其他主题方法位置可能有所不同。 返回","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://waxll.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://waxll.top/tags/Hexo/"}]},{"title":"Hexo博客搭建教程","slug":"Hexo博客搭建教程","date":"2020-05-03T16:00:00.000Z","updated":"2020-07-26T18:37:01.000Z","comments":true,"path":"2020/05/04/blogjcjc.html","link":"","permalink":"http://waxll.top/2020/05/04/blogjcjc.html","excerpt":"&emsp;&emsp;自从上次成功搭建博客之后我就一直想写篇教程，但是由于没有时间（主要是懒）也就一直没有写。直到这次五一放假，终于有了空闲的时间。我自己觉得我这样的小白写的教程应该比较全面，毕竟把什么坑都踩了一遍。接下来开始我们的博客搭建。","text":"&emsp;&emsp;自从上次成功搭建博客之后我就一直想写篇教程，但是由于没有时间（主要是懒）也就一直没有写。直到这次五一放假，终于有了空闲的时间。我自己觉得我这样的小白写的教程应该比较全面，毕竟把什么坑都踩了一遍。接下来开始我们的博客搭建。 搭建平台：Windos10 v1909 x64 博客框架：Hexo 安装环境下载Node.js前往官网下载Node.js 安装Node.js 点击Next即可 下载Git前往官网下载Git 安装Git 点击Next即可 部署环境注册Github并创建仓库注册成功Github账号后需要创建一个仓库 在Repository name 中输入”用户名.github.io” 注意用户名与注册用户名相同否则博客无法正常打开 配置SSH密钥 win+R 输入 “cmd”打开CMD 设置 “user name”和 “email” 12git config --global user.name &quot;Github用户名&quot;git config --global user.email &quot;GitHub注册邮箱&quot; 生成SSH密钥 1ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 这里回车就行然后会在C盘用户目录下会生成一个***.ssh文件夹,里面有私钥id_rsa和公钥id_rsa_pub***。 在Github上添加SSH密钥。具体步骤如下： 验证SSH密钥在CMD中输入: 1ssh -T git@github.com 安装Hexo 在D盘创建以后个Blog文件，切换到Blog目录下。 使用淘宝的npm源安装hexo 123npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install hexo-cli -gcnpm install hexo --save 初始化Hexo 1hexo init 此处若出现以下情形这需要将Blog文件夹下的文件清空再重试 安装相关插件 12345678910111213cnpm install hexo-generator-index --savecnpm install hexo-generator-archive --savecnpm install hexo-generator-category --savecnpm install hexo-generator-tag --savecnpm install hexo-server --savecnpm install hexo-deployer-git --savecnpm install hexo-deployer-heroku --savecnpm install hexo-deployer-rsync --savecnpm install hexo-deployer-openshift --savecnpm install hexo-renderer-marked@0.2 --savecnpm install hexo-renderer-stylus@0.2 --savecnpm install hexo-generator-feed@1 --savecnpm install hexo-generator-sitemap@1 --save 启动Hexo 在浏览器打开https://localhost:4000即可看到刚刚搭建的博客 部署博客到Github 配置**_config.yml在Blog目录下找到*_config.yml***文件,用文本编辑器(推荐Typora)打开编辑以下项目: 1234deploy: type: git repo: git@github.com:用户名/用户名.github.io.git branch: master 新建一篇帖子 1hexo new &quot;first post&quot; 便会在D:\\Blog\\source\\ _posts目录下生成first post.md的文件，可以用markdown编辑器编辑帖子。 设置身份信息 12git config --global user.name &quot;GitHub用户名&quot;git config --global user.email &quot;GitHub注册邮箱&quot; 部署Github 1hexo d -g 在浏览器打开:用户名.github.io即可看到刚刚编辑的博客。 到这里Hexo博客的基础搭建已经完成，更换主题的教程会下次更新。 返回","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://waxll.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://waxll.top/tags/Hexo/"}]},{"title":"鬼火少年","slug":"单片机","date":"2020-05-03T16:00:00.000Z","updated":"2020-07-26T18:37:01.000Z","comments":true,"path":"2020/05/04/ghsn.html","link":"","permalink":"http://waxll.top/2020/05/04/ghsn.html","excerpt":"","text":"刚开始学单片机，是个单片机小白，如果有哪里不对的请大家多多指教谢谢！ 爆闪灯：123456789101112131415161718192021222324252627282930ORG 0000H AJMP MAIN ORG 000BH AJMP TIMER0MAIN: CLR F0 //设置状态标志 MOV 30H,#5H //每个状态次 MOV TH0,#3CH //初始化中断定时器设置50ms MOV TL0,#0B0H MOV IE,#82H SETB TR0 SJMP $ TIMER0: MOV TH0,#3CH MOV TL0,#0B0H DJNZ 30H,T001 //判断循环次数 CPL F0 MOV 30H,#5HT001: JB F0,T002 //判断状态 CPL P1.0 CLR P1.1 CPL P1.2 CLR P1.3 SJMP T0_EXT002: CLR P1.0 CPL P1.1 CLR P1.2 CPL P1.3T0_EX: RETI 流水灯1234567891011121314151617181920212223 ORG 000H MOV R0,#0AH MOV A,#0FEH MOV P1,A AJMP MAIN ORG 000BH AJMP TIMEROMAIN: MOV TMOD,#10H MOV TL0,#0B0H MOV TH0,#3CH MOV R0,#0AH MOV IE,#82H SETB TR0 SJMP $TIMERO: MOV TL0,#0B0H MOV TH0,#3CH DJNZ R0,T0_EX RL A MOV P1,A MOV R0,#0AH T0_EX:RETI 最后放一个老师写的流水灯（我稍微改了下参数）1234567891011121314151617181920212223242526272829303132ORG 0000H AJMP MAIN ORG 000BH AJMP TIMER0MAIN: MOV P1,#0FEH CLR F0 MOV 30H,#10H //这里的原值是10H MOV 31H,#0FDH //这里的原值是0FEH MOV 32H,#10H MOV TMOD,#01H MOV TH0,#3CH MOV TL0,#0B0H MOV IE,#82H SETB TR0 SJMP $TIMER0: MOV TH0,#3CH MOV TL0,#0B0H DJNZ 32H,T0_EX MOV 32H,#10H DJNZ 30H,T001 CPL F0 MOV 30H,#15 //这里的原值是10HT001: MOV A,31H JB F0,T002 RL A SJMP T003T002: RR AT003: MOV 31H,A MOV P1,A T0_EX: RETI 这两个参数改动后便可流畅亮灯。 返回","categories":[{"name":"单片机","slug":"单片机","permalink":"http://waxll.top/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"AT89C51","slug":"AT89C51","permalink":"http://waxll.top/tags/AT89C51/"}]},{"title":"我的第一篇博客","slug":"第一篇Hexo博客","date":"2020-04-13T16:00:00.000Z","updated":"2020-07-26T18:37:01.000Z","comments":true,"path":"2020/04/14/firstblog.html","link":"","permalink":"http://waxll.top/2020/04/14/firstblog.html","excerpt":"1.为什么想搭建博客&emsp;&emsp;最初是在油管上学习如何建立V2ray服务器，找到了一个用博客伪装V2ray服务器的教程视频。在认真学习了视频的内容后，我便兴匆匆的去租了一个美国VPS的服务器。在经过一系列的操作后，V2ray服务器成功搭建。然而这个服务器根本不能用，太慢了，延迟上天，果然便宜没好货，跟隔着太平洋买了个垃圾差不多（穷是原罪T_T)。于是我对V2ray服务器的兴趣被磨得一干二净，却对博客起了兴趣。","text":"1.为什么想搭建博客&emsp;&emsp;最初是在油管上学习如何建立V2ray服务器，找到了一个用博客伪装V2ray服务器的教程视频。在认真学习了视频的内容后，我便兴匆匆的去租了一个美国VPS的服务器。在经过一系列的操作后，V2ray服务器成功搭建。然而这个服务器根本不能用，太慢了，延迟上天，果然便宜没好货，跟隔着太平洋买了个垃圾差不多（穷是原罪T_T)。于是我对V2ray服务器的兴趣被磨得一干二净，却对博客起了兴趣。 2.第一次&emsp;&emsp;于有之前购买垃圾服务器的经历，我便不打算购买服务 器搭建博客，而是使用了GitHub。我先是在油管上找了很多有关搭建博客的视频，在对这些视频认真学习之后。我开始了博客搭建。鉴于教程视频中是在Mc环境下进行搭建的，于是我打算在电脑上安装Linux虚拟机，并使用Hugo来搭建。在下载安装了Git和Hugo之后终于#hugo server，在本地成功建立博客。似乎快要成功了，然 而在部署到GitHub的时候出现了问题。不知道是什么原因虚拟机下的Deepin无法连接到GitHub，在上网查询很久依然无法解决，毕竟像我这样在虚拟机里搭建博客的是少数。这第一次搭建博客算是失败了。 3.第二次&emsp;&emsp;这次我推翻了上次用虚拟机搭建的方式，因为有人给我推荐了阿里云的试用服务器。这次我打算直接将博客搭建在阿里云服务器里。我先是在Freenom申请了一个免费域名。然后注册了阿里云的账号并完成实名认证获得了一台服务器。然后我安装了Finalshell成功连接上服务器，并在服务器里安装了宝塔面板。域名解析好后，将域名与网站绑定。但当我打开那个网址时显示网址需要备案。于是我便去备案，结果有我申请的是.tk(不要钱)的域名,不支持备案我晕(((φ(◎ロ◎;)φ)))，所以贫穷是原罪。自然这次也失败了。 4.第三次&emsp;&emsp;在吸取前两次失败的教训，我决定推倒重来。将Linux换成Windos，把Hugo换成Hexo，继续使用Github。这次有了前两次的经验，在看了晚上的教程后还是比较顺利的。然而在生成SSH密钥时出现了问题，密钥无法生成。于是我又上油管上搜索如何在Git上生成SSH密钥的视频，这次我按照视频中的方法成功生成了密钥，并成功连接上了Github。然而在部署到GitHub上时，遇到了问题，一直显示_config文件中deployer的设置不正确。于是我上网查找了很多关于这个问题的解决方法，试了不知多少次依然无法部署。于是我决定，重新生成一个博客，原模原样试了一遍，依然不行。功夫不负有心人，就在我在GitHub的仓库里乱翻的时候，发现了在仓库里也需要上传SSH公钥。于是我抱着试一试的心态往里面上传了SSH公钥，并重新部署了一次，居然成功了。我太激动了，声音都颤抖了q(≧▽≦q)！！！第三次搭建博客成功ψ(｀∇´)ψ！！！&emsp;&emsp;之后我写下了这篇博客，用来纪念这次搭建博客的经历。 5.小结&emsp;&emsp;这第一篇博客耗时四天，踩了无数的坑，当然也收获了很多,感觉自己能有一个能与别人分享自己想法的博客特别的开心O(∩_∩)O。虽然有点累,但是生命在于折腾!第一次写博客，内容比较简陋，望谅解。当然以后会进步的q(≧▽≦q)！ 以下是这次搭建博客所用到的教程资料和视频： Hexo&amp;Github Blog 搭建 FATAL E:\\blog not empty, please run hexo init on an empty folder and then copy your files into it解决方法 Win10+Hexo+GitHub搭建个人博客详解 5分钟搞定个人博客-hexo md 文件的编辑 如何用SSH密钥连接到Git仓库和远程服务器 手把手教你从0开始搭建自己的个人博客 |第二种姿势 | hugo手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo波仔分享… … 十分感谢他们的分享！ 返回","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://waxll.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://waxll.top/tags/Hexo/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://waxll.top/categories/Python/"},{"name":"单片机","slug":"单片机","permalink":"http://waxll.top/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://waxll.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"PythonLearn","slug":"PythonLearn","permalink":"http://waxll.top/tags/PythonLearn/"},{"name":"C51汇编","slug":"C51汇编","permalink":"http://waxll.top/tags/C51%E6%B1%87%E7%BC%96/"},{"name":"Hexo","slug":"Hexo","permalink":"http://waxll.top/tags/Hexo/"},{"name":"AT89C51","slug":"AT89C51","permalink":"http://waxll.top/tags/AT89C51/"}]}